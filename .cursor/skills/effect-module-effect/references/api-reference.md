# API Reference: effect/Effect

- Import path: `effect/Effect`
- Source file: `packages/effect/src/Effect.ts`
- Function exports (callable): 190
- Non-function exports: 33

## Purpose

The `Effect` module is the core of the Effect library, providing a powerful and expressive way to model and compose asynchronous, concurrent, and effectful computations.

## Key Function Exports

- `acquireRelease`
- `acquireUseRelease`
- `addFinalizer`
- `all`
- `andThen`
- `annotateCurrentSpan`
- `annotateLogs`
- `annotateSpans`
- `as`
- `asSome`
- `asVoid`
- `atomic`
- `atomicWith`
- `awaitAllChildren`
- `cached`
- `cachedInvalidateWithTTL`
- `cachedWithTTL`
- `callback`

## All Function Signatures

```ts
export declare const acquireRelease: <A, E, R>(acquire: Effect<A, E, R>, release: (a: A, exit: Exit.Exit<unknown, unknown>) => Effect<unknown>): Effect<A, E, R | Scope>;
export declare const acquireUseRelease: <Resource, E, R, A, E2, R2, E3, R3>(acquire: Effect<Resource, E, R>, use: (a: Resource) => Effect<A, E2, R2>, release: (a: Resource, exit: Exit.Exit<A, E2>) => Effect<void, E3, R3>): Effect<A, E | E2 | E3, R | R2 | R3>;
export declare const addFinalizer: <R>(finalizer: (exit: Exit.Exit<unknown, unknown>) => Effect<void, never, R>): Effect<void, never, R | Scope>;
export declare const all: <const Arg extends Iterable<Effect<any, any, any>> | Record<string, Effect<any, any, any>>, O extends { readonly concurrency?: Concurrency | undefined; readonly discard?: boolean | undefined; readonly mode?: "default" | "result" | undefined; }>(arg: Arg, options?: O): All.Return<Arg, O>;
export declare const andThen: <A, B, E2, R2>(f: (a: A) => Effect<B, E2, R2>): <E, R>(self: Effect<A, E, R>) => Effect<B, E | E2, R | R2>; // overload 1
export declare const andThen: <B, E2, R2>(f: Effect<B, E2, R2>): <A, E, R>(self: Effect<A, E, R>) => Effect<B, E | E2, R | R2>; // overload 2
export declare const andThen: <A, E, R, B, E2, R2>(self: Effect<A, E, R>, f: (a: A) => Effect<B, E2, R2>): Effect<B, E | E2, R | R2>; // overload 3
export declare const andThen: <A, E, R, B, E2, R2>(self: Effect<A, E, R>, f: Effect<B, E2, R2>): Effect<B, E | E2, R | R2>; // overload 4
export declare const annotateCurrentSpan: (key: string, value: unknown): Effect<void>; // overload 1
export declare const annotateCurrentSpan: (values: Record<string, unknown>): Effect<void>; // overload 2
export declare const annotateLogs: (key: string, value: unknown): <A, E, R>(effect: Effect<A, E, R>) => Effect<A, E, R>; // overload 1
export declare const annotateLogs: (values: Record<string, unknown>): <A, E, R>(effect: Effect<A, E, R>) => Effect<A, E, R>; // overload 2
export declare const annotateLogs: <A, E, R>(effect: Effect<A, E, R>, key: string, value: unknown): Effect<A, E, R>; // overload 3
export declare const annotateLogs: <A, E, R>(effect: Effect<A, E, R>, values: Record<string, unknown>): Effect<A, E, R>; // overload 4
export declare const annotateSpans: (key: string, value: unknown): <A, E, R>(effect: Effect<A, E, R>) => Effect<A, E, R>; // overload 1
export declare const annotateSpans: (values: Record<string, unknown>): <A, E, R>(effect: Effect<A, E, R>) => Effect<A, E, R>; // overload 2
export declare const annotateSpans: <A, E, R>(effect: Effect<A, E, R>, key: string, value: unknown): Effect<A, E, R>; // overload 3
export declare const annotateSpans: <A, E, R>(effect: Effect<A, E, R>, values: Record<string, unknown>): Effect<A, E, R>; // overload 4
export declare const as: <B>(value: B): <A, E, R>(self: Effect<A, E, R>) => Effect<B, E, R>; // overload 1
export declare const as: <A, E, R, B>(self: Effect<A, E, R>, value: B): Effect<B, E, R>; // overload 2
export declare const asSome: <A, E, R>(self: Effect<A, E, R>): Effect<Option<A>, E, R>;
export declare const asVoid: <A, E, R>(self: Effect<A, E, R>): Effect<void, E, R>;
export declare const atomic: <A, E, R>(effect: Effect<A, E, R>): Effect<A, E, Exclude<R, Transaction>>;
export declare const atomicWith: <A, E, R>(f: (state: Transaction["Service"]) => Effect<A, E, R>): Effect<A, E, Exclude<R, Transaction>>;
export declare const awaitAllChildren: <A, E, R>(self: Effect<A, E, R>): Effect<A, E, R>;
export declare const cached: <A, E, R>(self: Effect<A, E, R>): Effect<Effect<A, E, R>>;
export declare const cachedInvalidateWithTTL: (timeToLive: Duration.Input): <A, E, R>(self: Effect<A, E, R>) => Effect<[Effect<A, E, R>, Effect<void>]>; // overload 1
export declare const cachedInvalidateWithTTL: <A, E, R>(self: Effect<A, E, R>, timeToLive: Duration.Input): Effect<[Effect<A, E, R>, Effect<void>]>; // overload 2
export declare const cachedWithTTL: (timeToLive: Duration.Input): <A, E, R>(self: Effect<A, E, R>) => Effect<Effect<A, E, R>>; // overload 1
export declare const cachedWithTTL: <A, E, R>(self: Effect<A, E, R>, timeToLive: Duration.Input): Effect<Effect<A, E, R>>; // overload 2
export declare const callback: <A, E = never, R = never>(register: (this: Scheduler, resume: (effect: Effect<A, E, R>) => void, signal: AbortSignal) => void | Effect<void, never, R>): Effect<A, E, R>;
export declare const catch: <E, A2, E2, R2>(f: (e: E) => Effect<A2, E2, R2>): <A, R>(self: Effect<A, E, R>) => Effect<A2 | A, E2, R2 | R>; // overload 1
export declare const catch: <A, E, R, A2, E2, R2>(self: Effect<A, E, R>, f: (e: E) => Effect<A2, E2, R2>): Effect<A2 | A, E2, R2 | R>; // overload 2
export declare const catchCause: <E, A2, E2, R2>(f: (cause: Cause.Cause<E>) => Effect<A2, E2, R2>): <A, R>(self: Effect<A, E, R>) => Effect<A2 | A, E2, R2 | R>; // overload 1
export declare const catchCause: <A, E, R, A2, E2, R2>(self: Effect<A, E, R>, f: (cause: Cause.Cause<E>) => Effect<A2, E2, R2>): Effect<A | A2, E2, R | R2>; // overload 2
export declare const catchCauseIf: <E, Result extends Filter.ResultOrBool<Cause.Cause<any>>, B, E2, R2>(filter: Filter.OrPredicate<Cause.Cause<E>, Result>, f: (failure: Filter.Pass<Cause.Cause<E>, Result>, cause: Cause.Cause<E>) => Effect<B, E2, R2>): <A, R>(self: Effect<A, E, R>) => Effect<A | B, Cause.Cause.Error<Filter.Fail<Cause.Cause<E>, Result>> | E2, R | R2>; // overload 1
export declare const catchCauseIf: <A, E, R, B, E2, R2, Result extends Filter.ResultOrBool<Cause.Cause<any>>>(self: Effect<A, E, R>, filter: Filter.OrPredicate<Cause.Cause<E>, Result>, f: (failure: Filter.Pass<Cause.Cause<E>, Result>, cause: Cause.Cause<E>) => Effect<B, E2, R2>): Effect<A | B, Cause.Cause.Error<Filter.Fail<Cause.Cause<E>, Result>> | E2, R | R2>; // overload 2
export declare const catchDefect: <A2, E2, R2>(f: (defect: unknown) => Effect<A2, E2, R2>): <A, E, R>(self: Effect<A, E, R>) => Effect<A2 | A, E2 | E, R2 | R>; // overload 1
export declare const catchDefect: <A, E, R, A2, E2, R2>(self: Effect<A, E, R>, f: (defect: unknown) => Effect<A2, E2, R2>): Effect<A | A2, E | E2, R | R2>; // overload 2
export declare const catchEager: <E, B, E2, R2>(f: (e: NoInfer<E>) => Effect<B, E2, R2>): <A, R>(self: Effect<A, E, R>) => Effect<A | B, E2, R | R2>; // overload 1
export declare const catchEager: <A, E, R, B, E2, R2>(self: Effect<A, E, R>, f: (e: NoInfer<E>) => Effect<B, E2, R2>): Effect<A | B, E2, R | R2>; // overload 2
export declare const catchIf: <E, EB extends E, A2, E2, R2, A3 = never, E3 = Exclude<E, EB>, R3 = never>(refinement: Predicate.Refinement<NoInfer<E>, EB>, f: (e: EB) => Effect<A2, E2, R2>, orElse?: ((e: Exclude<E, EB>) => Effect<A3, E3, R3>) | undefined): <A, R>(self: Effect<A, E, R>) => Effect<A | A2 | A3, E2 | E3, R | R2 | R3>; // overload 1
export declare const catchIf: <E, Result extends Filter.ResultOrBool, A2, E2, R2, A3 = never, E3 = Filter.Fail<E, Result>, R3 = never>(filter: Filter.OrPredicate<NoInfer<E>, Result>, f: (e: Filter.Pass<E, Result>) => Effect<A2, E2, R2>, orElse?: ((e: Filter.Fail<E, Result>) => Effect<A3, E3, R3>) | undefined): <A, R>(self: Effect<A, E, R>) => Effect<A | A2 | A3, E2 | E3, R | R2 | R3>; // overload 2
export declare const catchIf: <A, E, R, EB extends E, A2, E2, R2, A3 = never, E3 = Exclude<E, EB>, R3 = never>(self: Effect<A, E, R>, refinement: Predicate.Refinement<E, EB>, f: (e: EB) => Effect<A2, E2, R2>, orElse?: ((e: Exclude<E, EB>) => Effect<A3, E3, R3>) | undefined): Effect<A | A2 | A3, E2 | E3, R | R2 | R3>; // overload 3
export declare const catchIf: <A, E, R, Result extends Filter.ResultOrBool, A2, E2, R2, A3 = never, E3 = Filter.Fail<E, Result>, R3 = never>(self: Effect<A, E, R>, filter: Filter.OrPredicate<NoInfer<E>, Result>, f: (e: Filter.Pass<E, Result>) => Effect<A2, E2, R2>, orElse?: ((e: Filter.Fail<E, Result>) => Effect<A3, E3, R3>) | undefined): Effect<A | A2 | A3, E2 | E3, R | R2 | R3>; // overload 4
export declare const catchNoSuchElement: <A, E, R>(self: Effect<A, E, R>): Effect<Option<A>, Exclude<E, Cause.NoSuchElementError>, R>;
export declare const catchReason: <K extends Tags<E>, E, RK extends ReasonTags<ExtractTag<NoInfer<E>, K>>, A2, E2, R2, A3 = unassigned, E3 = never, R3 = never>(errorTag: K, reasonTag: RK, f: (reason: ExtractReason<ExtractTag<NoInfer<E>, K>, RK>) => Effect<A2, E2, R2>, orElse?: ((reasons: ExcludeReason<ExtractTag<NoInfer<E>, K>, RK>) => Effect<A3, E3, R3>) | undefined): <A, R>(self: Effect<A, E, R>) => Effect<A | A2 | Exclude<A3, unassigned>, (A3 extends unassigned ? E : ExcludeTag<E, K>) | E2 | E3, R | R2 | R3>; // overload 1
export declare const catchReason: <A, E, R, K extends Tags<E>, RK extends ReasonTags<ExtractTag<E, K>>, A2, E2, R2, A3 = unassigned, E3 = never, R3 = never>(self: Effect<A, E, R>, errorTag: K, reasonTag: RK, f: (reason: ExtractReason<ExtractTag<E, K>, RK>) => Effect<A2, E2, R2>, orElse?: ((reasons: ExcludeReason<ExtractTag<E, K>, RK>) => Effect<A3, E3, R3>) | undefined): Effect<A | A2 | Exclude<A3, unassigned>, (A3 extends unassigned ? E : ExcludeTag<E, K>) | E2 | E3, R | R2 | R3>; // overload 2
export declare const catchReasons: <K extends Tags<E>, E, Cases extends { [RK in ReasonTags<ExtractTag<NoInfer<E>, K>>]+?: (reason: ExtractReason<ExtractTag<NoInfer<E>, K>, RK>) => Effect<any, any, any>; }, A2 = unassigned, E2 = never, R2 = never>(errorTag: K, cases: Cases, orElse?: ((reason: ExcludeReason<ExtractTag<NoInfer<E>, K>, Extract<keyof Cases, string>>) => Effect<A2, E2, R2>) | undefined): <A, R>(self: Effect<A, E, R>) => Effect<A | Exclude<A2, unassigned> | { [RK in keyof Cases]: Cases[RK] extends (...args: Array<any>) => Effect<infer A, any, any> ? A : never; }[keyof Cases], (A2 extends unassigned ? E : ExcludeTag<E, K>) | E2 | { [RK in keyof Cases]: Cases[RK] extends (...args: Array<any>) => Effect<any, infer E, any> ? E : never; }[keyof Cases], R | R2 | { [RK in keyof Cases]: Cases[RK] extends (...args: Array<any>) => Effect<any, any, infer R> ? R : never; }[keyof Cases]>; // overload 1
export declare const catchReasons: <A, E, R, K extends Tags<E>, Cases extends { [RK in ReasonTags<ExtractTag<E, K>>]+?: (reason: ExtractReason<ExtractTag<E, K>, RK>) => Effect<any, any, any>; }, A2 = unassigned, E2 = never, R2 = never>(self: Effect<A, E, R>, errorTag: K, cases: Cases, orElse?: ((reason: ExcludeReason<ExtractTag<NoInfer<E>, K>, Extract<keyof Cases, string>>) => Effect<A2, E2, R2>) | undefined): Effect<A | Exclude<A2, unassigned> | { [RK in keyof Cases]: Cases[RK] extends (...args: Array<any>) => Effect<infer A, any, any> ? A : never; }[keyof Cases], (A2 extends unassigned ? E : ExcludeTag<E, K>) | E2 | { [RK in keyof Cases]: Cases[RK] extends (...args: Array<any>) => Effect<any, infer E, any> ? E : never; }[keyof Cases], R | R2 | { [RK in keyof Cases]: Cases[RK] extends (...args: Array<any>) => Effect<any, any, infer R> ? R : never; }[keyof Cases]>; // overload 2
export declare const catchTag: <const K extends Tags<E> | Arr.NonEmptyReadonlyArray<Tags<E>>, E, A1, E1, R1, A2 = never, E2 = ExcludeTag<E, K extends readonly [string, ...string[]] ? K[number] : K>, R2 = never>(k: K, f: (e: ExtractTag<NoInfer<E>, K extends Arr.NonEmptyReadonlyArray<string> ? K[number] : K>) => Effect<A1, E1, R1>, orElse?: ((e: ExcludeTag<E, K extends Arr.NonEmptyReadonlyArray<string> ? K[number] : K>) => Effect<A2, E2, R2>) | undefined): <A, R>(self: Effect<A, E, R>) => Effect<A | A1 | A2, E1 | E2, R | R1 | R2>; // overload 1
export declare const catchTag: <A, E, R, const K extends Tags<E> | Arr.NonEmptyReadonlyArray<Tags<E>>, R1, E1, A1, A2 = never, E2 = ExcludeTag<E, K extends readonly [string, ...string[]] ? K[number] : K>, R2 = never>(self: Effect<A, E, R>, k: K, f: (e: ExtractTag<E, K extends Arr.NonEmptyReadonlyArray<string> ? K[number] : K>) => Effect<A1, E1, R1>, orElse?: ((e: ExcludeTag<E, K extends Arr.NonEmptyReadonlyArray<string> ? K[number] : K>) => Effect<A2, E2, R2>) | undefined): Effect<A | A1 | A2, E1 | E2, R | R1 | R2>; // overload 2
export declare const catchTags: <E, Cases extends { [K in Extract<E, { _tag: string; }>["_tag"]]+?: ((error: Extract<E, { _tag: K; }>) => Effect<any, any, any>); } & (unknown extends E ? {} : { [K in Exclude<keyof Cases, Extract<E, { _tag: string; }>["_tag"]>]: never; })>(cases: Cases): <A, R>(self: Effect<A, E, R>) => Effect<A | { [K in keyof Cases]: Cases[K] extends (...args: Array<any>) => Effect<infer A, any, any> ? A : never; }[keyof Cases], Exclude<E, { _tag: keyof Cases; }> | { [K in keyof Cases]: Cases[K] extends (...args: Array<any>) => Effect<any, infer E, any> ? E : never; }[keyof Cases], R | { [K in keyof Cases]: Cases[K] extends (...args: Array<any>) => Effect<any, any, infer R> ? R : never; }[keyof Cases]>; // overload 1
export declare const catchTags: <R, E, A, Cases extends { [K in Extract<E, { _tag: string; }>["_tag"]]+?: ((error: Extract<E, { _tag: K; }>) => Effect<any, any, any>); } & (unknown extends E ? {} : { [K in Exclude<keyof Cases, Extract<E, { _tag: string; }>["_tag"]>]: never; })>(self: Effect<A, E, R>, cases: Cases): Effect<A | { [K in keyof Cases]: Cases[K] extends (...args: Array<any>) => Effect<infer A, any, any> ? A : never; }[keyof Cases], Exclude<E, { _tag: keyof Cases; }> | { [K in keyof Cases]: Cases[K] extends (...args: Array<any>) => Effect<any, infer E, any> ? E : never; }[keyof Cases], R | { [K in keyof Cases]: Cases[K] extends (...args: Array<any>) => Effect<any, any, infer R> ? R : never; }[keyof Cases]>; // overload 2
export declare const clockWith: <A, E, R>(f: (clock: Clock) => Effect<A, E, R>): Effect<A, E, R>;
export declare const delay: (duration: Duration.Input): <A, E, R>(self: Effect<A, E, R>) => Effect<A, E, R>; // overload 1
export declare const delay: <A, E, R>(self: Effect<A, E, R>, duration: Duration.Input): Effect<A, E, R>; // overload 2
export declare const die: (defect: unknown): Effect<never>;
export declare const effectify: <F extends (...args: Array<any>) => any>(fn: F): Effectify.Effectify<F, Effectify.EffectifyError<F>>; // overload 1
export declare const effectify: <F extends (...args: Array<any>) => any, E>(fn: F, onError: (error: Effectify.EffectifyError<F>, args: Parameters<F>) => E): Effectify.Effectify<F, E>; // overload 2
export declare const effectify: <F extends (...args: Array<any>) => any, E, E2>(fn: F, onError: (error: Effectify.EffectifyError<F>, args: Parameters<F>) => E, onSyncError: (error: unknown, args: Parameters<F>) => E2): Effectify.Effectify<F, E | E2>; // overload 3
export declare const ensuring: <X, R1>(finalizer: Effect<X, never, R1>): <A, E, R>(self: Effect<A, E, R>) => Effect<A, E, R1 | R>; // overload 1
export declare const ensuring: <A, E, R, X, R1>(self: Effect<A, E, R>, finalizer: Effect<X, never, R1>): Effect<A, E, R1 | R>; // overload 2
export declare const eventually: <A, E, R>(self: Effect<A, E, R>): Effect<A, never, R>;
export declare const exit: <A, E, R>(self: Effect<A, E, R>): Effect<Exit.Exit<A, E>, never, R>;
export declare const fail: <E>(error: E): Effect<never, E>;
export declare const failCause: <E>(cause: Cause.Cause<E>): Effect<never, E>;
export declare const failCauseSync: <E>(evaluate: LazyArg<Cause.Cause<E>>): Effect<never, E>;
export declare const failSync: <E>(evaluate: LazyArg<E>): Effect<never, E>;
export declare const filter: <A, B extends A>(refinement: Predicate.Refinement<NoInfer<A>, B>): (elements: Iterable<A>) => Effect<Array<B>>; // overload 1
export declare const filter: <A>(predicate: Predicate.Predicate<NoInfer<A>>): (elements: Iterable<A>) => Effect<Array<A>>; // overload 2
export declare const filter: <A, B, X>(filter: Filter.Filter<NoInfer<A>, B, X>, options?: { readonly concurrency?: Concurrency | undefined; }): (elements: Iterable<A>) => Effect<Array<B>>; // overload 3
export declare const filter: <A, B, X, E, R>(filter: Filter.FilterEffect<NoInfer<A>, B, X, E, R>, options?: { readonly concurrency?: Concurrency | undefined; }): (elements: Iterable<A>) => Effect<Array<B>, E, R>; // overload 4
export declare const filter: <A, E, R>(predicate: (a: NoInfer<A>, i: number) => Effect<boolean, E, R>, options?: { readonly concurrency?: Concurrency | undefined; }): (iterable: Iterable<A>) => Effect<Array<A>, E, R>; // overload 5
export declare const filter: <A, B extends A>(elements: Iterable<A>, refinement: Predicate.Refinement<A, B>): Effect<Array<B>>; // overload 6
export declare const filter: <A>(elements: Iterable<A>, predicate: Predicate.Predicate<A>): Effect<Array<A>>; // overload 7
export declare const filter: <A, B, X>(elements: Iterable<A>, filter: Filter.Filter<NoInfer<A>, B, X>): Effect<Array<B>>; // overload 8
export declare const filter: <A, B, X, E, R>(elements: Iterable<A>, filter: Filter.FilterEffect<NoInfer<A>, B, X, E, R>, options?: { readonly concurrency?: Concurrency | undefined; }): Effect<Array<B>, E, R>; // overload 9
export declare const filter: <A, E, R>(iterable: Iterable<A>, predicate: (a: NoInfer<A>, i: number) => Effect<boolean, E, R>, options?: { readonly concurrency?: Concurrency | undefined; }): Effect<Array<A>, E, R>; // overload 10
export declare const filterOrElse: <A, C, E2, R2, B extends A>(refinement: Predicate.Refinement<NoInfer<A>, B>, orElse: (a: EqualsWith<A, B, NoInfer<A>, Exclude<NoInfer<A>, B>>) => Effect<C, E2, R2>): <E, R>(self: Effect<A, E, R>) => Effect<B | C, E2 | E, R2 | R>; // overload 1
export declare const filterOrElse: <A, Result extends Filter.ResultOrBool, C, E2, R2>(filter: Filter.OrPredicate<NoInfer<A>, Result>, orElse: (a: Filter.Fail<A, Result>) => Effect<C, E2, R2>): <E, R>(self: Effect<A, E, R>) => Effect<Filter.Pass<A, Result> | C, E2 | E, R2 | R>; // overload 2
export declare const filterOrElse: <A, E, R, C, E2, R2, B extends A>(self: Effect<A, E, R>, refinement: Predicate.Refinement<A, B>, orElse: (a: EqualsWith<A, B, A, Exclude<A, B>>) => Effect<C, E2, R2>): Effect<B | C, E | E2, R | R2>; // overload 3
export declare const filterOrElse: <A, E, R, Result extends Filter.ResultOrBool, C, E2, R2>(self: Effect<A, E, R>, filter: Filter.OrPredicate<NoInfer<A>, Result>, orElse: (a: Filter.Fail<A, Result>) => Effect<C, E2, R2>): Effect<Filter.Pass<A, Result> | C, E | E2, R | R2>; // overload 4
export declare const filterOrFail: <A, E2, B extends A>(refinement: Predicate.Refinement<NoInfer<A>, B>, orFailWith: (a: NoInfer<A>) => E2): <E, R>(self: Effect<A, E, R>) => Effect<B, E2 | E, R>; // overload 1
export declare const filterOrFail: <A, E2>(predicate: Predicate.Predicate<NoInfer<A>>, orFailWith: (a: NoInfer<A>) => E2): <E, R>(self: Effect<A, E, R>) => Effect<A, E2 | E, R>; // overload 2
export declare const filterOrFail: <A, B, X, E2>(filter: Filter.Filter<NoInfer<A>, B, X>, orFailWith: (x: X) => E2): <E, R>(self: Effect<A, E, R>) => Effect<B, E2 | E, R>; // overload 3
export declare const filterOrFail: <A, B extends A>(refinement: Predicate.Refinement<NoInfer<A>, B>): <E, R>(self: Effect<A, E, R>) => Effect<B, Cause.NoSuchElementError | E, R>; // overload 4
export declare const filterOrFail: <A>(predicate: Predicate.Predicate<NoInfer<A>>): <E, R>(self: Effect<A, E, R>) => Effect<A, Cause.NoSuchElementError | E, R>; // overload 5
export declare const filterOrFail: <A, B, X>(filter: Filter.Filter<NoInfer<A>, B, X>): <E, R>(self: Effect<A, E, R>) => Effect<B, Cause.NoSuchElementError | E, R>; // overload 6
export declare const filterOrFail: <A, E, R, E2, B extends A>(self: Effect<A, E, R>, refinement: Predicate.Refinement<NoInfer<A>, B>, orFailWith: (a: NoInfer<A>) => E2): Effect<B, E2 | E, R>; // overload 7
export declare const filterOrFail: <A, E, R, E2>(self: Effect<A, E, R>, predicate: Predicate.Predicate<NoInfer<A>>, orFailWith: (a: NoInfer<A>) => E2): Effect<A, E2 | E, R>; // overload 8
export declare const filterOrFail: <A, E, R, B, X, E2>(self: Effect<A, E, R>, filter: Filter.Filter<A, B, X>, orFailWith: (x: X) => E2): Effect<B, E2 | E, R>; // overload 9
export declare const filterOrFail: <A, E, R, B extends A>(self: Effect<A, E, R>, refinement: Predicate.Refinement<NoInfer<A>, B>): Effect<B, E | Cause.NoSuchElementError, R>; // overload 10
export declare const filterOrFail: <A, E, R>(self: Effect<A, E, R>, predicate: Predicate.Predicate<NoInfer<A>>): Effect<A, E | Cause.NoSuchElementError, R>; // overload 11
export declare const filterOrFail: <A, E, R, B, X>(self: Effect<A, E, R>, filter: Filter.Filter<A, B, X>): Effect<B, E | Cause.NoSuchElementError, R>; // overload 12
export declare const flatMap: <A, B, E1, R1>(f: (a: A) => Effect<B, E1, R1>): <E, R>(self: Effect<A, E, R>) => Effect<B, E1 | E, R1 | R>; // overload 1
export declare const flatMap: <A, E, R, B, E1, R1>(self: Effect<A, E, R>, f: (a: A) => Effect<B, E1, R1>): Effect<B, E | E1, R | R1>; // overload 2
export declare const flatMapEager: <A, B, E2, R2>(f: (a: A) => Effect<B, E2, R2>): <E, R>(self: Effect<A, E, R>) => Effect<B, E | E2, R | R2>; // overload 1
export declare const flatMapEager: <A, E, R, B, E2, R2>(self: Effect<A, E, R>, f: (a: A) => Effect<B, E2, R2>): Effect<B, E | E2, R | R2>; // overload 2
export declare const flatten: <A, E, R, E2, R2>(self: Effect<Effect<A, E, R>, E2, R2>): Effect<A, E | E2, R | R2>;
export declare const flip: <A, E, R>(self: Effect<A, E, R>): Effect<E, A, R>;
export declare const fn: <Eff extends Yieldable<any, any, any, any>, AEff, Args extends Array<any>>(body: (this: unassigned, ...args: Args) => Generator<Eff, AEff, never> | (Eff & Effect<AEff, any, any>)): (...args: Args) => Effect<AEff, [Eff] extends [never] ? never : [Eff] extends [Yieldable<infer _S, infer _A, infer E, infer _R>] ? E : never, [Eff] extends [never] ? never : [Eff] extends [Yieldable<infer _S, infer _A, infer _E, infer R>] ? R : never>; // overload 1
export declare const fn: <Self, Eff extends Yieldable<any, any, any, any>, AEff, Args extends Array<any>>(body: (this: Self, ...args: Args) => Generator<Eff, AEff, never> | (Eff & Effect<AEff, any, any>)): (this: Self, ...args: Args) => Effect<AEff, [Eff] extends [never] ? never : [Eff] extends [Yieldable<infer _S, infer _A, infer E, infer _R>] ? E : never, [Eff] extends [never] ? never : [Eff] extends [Yieldable<infer _S, infer _A, infer _E, infer R>] ? R : never>; // overload 2
export declare const fn: <Self, Eff extends Yieldable<any, any, any, any>, AEff, Args extends Array<any>>(options: { readonly self: Self; }, body: (this: Self, ...args: Args) => Generator<Eff, AEff, never> | (Eff & Effect<AEff, any, any>)): (...args: Args) => Effect<AEff, [Eff] extends [never] ? never : [Eff] extends [Yieldable<infer _S, infer _A, infer E, infer _R>] ? E : never, [Eff] extends [never] ? never : [Eff] extends [Yieldable<infer _S, infer _A, infer _E, infer R>] ? R : never>; // overload 3
export declare const fn: <Eff extends Yieldable<any, any, any, any>, AEff, Args extends Array<any>, A>(body: (this: unassigned, ...args: Args) => Generator<Eff, AEff, never> | (Eff & Effect<AEff, any, any>), a: (_: Effect<AEff, [Eff] extends [never] ? never : [Eff] extends [Yieldable<infer _S, infer _A, infer E, infer _R>] ? E : never, [Eff] extends [never] ? never : [Eff] extends [Yieldable<infer _S, infer _A, infer _E, infer R>] ? R : never>, ...args: Args) => A): (...args: Args) => A; // overload 4
export declare const fn: <Self, Eff extends Yieldable<any, any, any, any>, AEff, Args extends Array<any>, A>(body: (this: Self, ...args: Args) => Generator<Eff, AEff, never> | (Eff & Effect<AEff, any, any>), a: (_: Effect<AEff, [Eff] extends [never] ? never : [Eff] extends [Yieldable<infer _S, infer _A, infer E, infer _R>] ? E : never, [Eff] extends [never] ? never : [Eff] extends [Yieldable<infer _S, infer _A, infer _E, infer R>] ? R : never>, ...args: Args) => A): (this: Self, ...args: Args) => A; // overload 5
export declare const fn: <Self, Eff extends Yieldable<any, any, any, any>, AEff, Args extends Array<any>, A>(options: { readonly self: Self; }, body: (this: Self, ...args: Args) => Generator<Eff, AEff, never> | (Eff & Effect<AEff, any, any>), a: (_: Effect<AEff, [Eff] extends [never] ? never : [Eff] extends [Yieldable<infer _S, infer _A, infer E, infer _R>] ? E : never, [Eff] extends [never] ? never : [Eff] extends [Yieldable<infer _S, infer _A, infer _E, infer R>] ? R : never>, ...args: Args) => A): (...args: Args) => A; // overload 6
export declare const fn: <Eff extends Yieldable<any, any, any, any>, AEff, Args extends Array<any>, A, B>(body: (this: unassigned, ...args: Args) => Generator<Eff, AEff, never> | (Eff & Effect<AEff, any, any>), a: (_: Effect<AEff, [Eff] extends [never] ? never : [Eff] extends [Yieldable<infer _S, infer _A, infer E, infer _R>] ? E : never, [Eff] extends [never] ? never : [Eff] extends [Yieldable<infer _S, infer _A, infer _E, infer R>] ? R : never>, ...args: Args) => A, b: (_: A, ...args: Args) => B): (...args: Args) => B; // overload 7
export declare const fn: <Self, Eff extends Yieldable<any, any, any, any>, AEff, Args extends Array<any>, A, B>(body: (this: Self, ...args: Args) => Generator<Eff, AEff, never> | (Eff & Effect<AEff, any, any>), a: (_: Effect<AEff, [Eff] extends [never] ? never : [Eff] extends [Yieldable<infer _S, infer _A, infer E, infer _R>] ? E : never, [Eff] extends [never] ? never : [Eff] extends [Yieldable<infer _S, infer _A, infer _E, infer R>] ? R : never>, ...args: Args) => A, b: (_: A, ...args: Args) => B): (this: Self, ...args: Args) => B; // overload 8
export declare const fn: <Self, Eff extends Yieldable<any, any, any, any>, AEff, Args extends Array<any>, A, B>(options: { readonly self: Self; }, body: (this: Self, ...args: Args) => Generator<Eff, AEff, never> | (Eff & Effect<AEff, any, any>), a: (_: Effect<AEff, [Eff] extends [never] ? never : [Eff] extends [Yieldable<infer _S, infer _A, infer E, infer _R>] ? E : never, [Eff] extends [never] ? never : [Eff] extends [Yieldable<infer _S, infer _A, infer _E, infer R>] ? R : never>, ...args: Args) => A, b: (_: A, ...args: Args) => B): (...args: Args) => B; // overload 9
export declare const fn: <Eff extends Yieldable<any, any, any, any>, AEff, Args extends Array<any>, A, B, C>(body: (this: unassigned, ...args: Args) => Generator<Eff, AEff, never> | (Eff & Effect<AEff, any, any>), a: (_: Effect<AEff, [Eff] extends [never] ? never : [Eff] extends [Yieldable<infer _S, infer _A, infer E, infer _R>] ? E : never, [Eff] extends [never] ? never : [Eff] extends [Yieldable<infer _S, infer _A, infer _E, infer R>] ? R : never>, ...args: Args) => A, b: (_: A, ...args: Args) => B, c: (_: B, ...args: Args) => C): (...args: Args) => C; // overload 10
export declare const fn: <Self, Eff extends Yieldable<any, any, any, any>, AEff, Args extends Array<any>, A, B, C>(body: (this: Self, ...args: Args) => Generator<Eff, AEff, never> | (Eff & Effect<AEff, any, any>), a: (_: Effect<AEff, [Eff] extends [never] ? never : [Eff] extends [Yieldable<infer _S, infer _A, infer E, infer _R>] ? E : never, [Eff] extends [never] ? never : [Eff] extends [Yieldable<infer _S, infer _A, infer _E, infer R>] ? R : never>, ...args: Args) => A, b: (_: A, ...args: Args) => B, c: (_: B, ...args: Args) => C): (this: Self, ...args: Args) => C; // overload 11
export declare const fn: <Self, Eff extends Yieldable<any, any, any, any>, AEff, Args extends Array<any>, A, B, C>(options: { readonly self: Self; }, body: (this: Self, ...args: Args) => Generator<Eff, AEff, never> | (Eff & Effect<AEff, any, any>), a: (_: Effect<AEff, [Eff] extends [never] ? never : [Eff] extends [Yieldable<infer _S, infer _A, infer E, infer _R>] ? E : never, [Eff] extends [never] ? never : [Eff] extends [Yieldable<infer _S, infer _A, infer _E, infer R>] ? R : never>, ...args: Args) => A, b: (_: A, ...args: Args) => B, c: (_: B, ...args: Args) => C): (...args: Args) => C; // overload 12
export declare const fn: <Eff extends Yieldable<any, any, any, any>, AEff, Args extends Array<any>, A, B, C, D>(body: (this: unassigned, ...args: Args) => Generator<Eff, AEff, never> | (Eff & Effect<AEff, any, any>), a: (_: Effect<AEff, [Eff] extends [never] ? never : [Eff] extends [Yieldable<infer _S, infer _A, infer E, infer _R>] ? E : never, [Eff] extends [never] ? never : [Eff] extends [Yieldable<infer _S, infer _A, infer _E, infer R>] ? R : never>, ...args: Args) => A, b: (_: A, ...args: Args) => B, c: (_: B, ...args: Args) => C, d: (_: C, ...args: Args) => D): (...args: Args) => D; // overload 13
export declare const fn: <Self, Eff extends Yieldable<any, any, any, any>, AEff, Args extends Array<any>, A, B, C, D>(body: (this: Self, ...args: Args) => Generator<Eff, AEff, never> | (Eff & Effect<AEff, any, any>), a: (_: Effect<AEff, [Eff] extends [never] ? never : [Eff] extends [Yieldable<infer _S, infer _A, infer E, infer _R>] ? E : never, [Eff] extends [never] ? never : [Eff] extends [Yieldable<infer _S, infer _A, infer _E, infer R>] ? R : never>, ...args: Args) => A, b: (_: A, ...args: Args) => B, c: (_: B, ...args: Args) => C, d: (_: C, ...args: Args) => D): (this: Self, ...args: Args) => D; // overload 14
export declare const fn: <Self, Eff extends Yieldable<any, any, any, any>, AEff, Args extends Array<any>, A, B, C, D>(options: { readonly self: Self; }, body: (this: Self, ...args: Args) => Generator<Eff, AEff, never> | (Eff & Effect<AEff, any, any>), a: (_: Effect<AEff, [Eff] extends [never] ? never : [Eff] extends [Yieldable<infer _S, infer _A, infer E, infer _R>] ? E : never, [Eff] extends [never] ? never : [Eff] extends [Yieldable<infer _S, infer _A, infer _E, infer R>] ? R : never>, ...args: Args) => A, b: (_: A, ...args: Args) => B, c: (_: B, ...args: Args) => C, d: (_: C, ...args: Args) => D): (...args: Args) => D; // overload 15
export declare const fn: <Eff extends Yieldable<any, any, any, any>, AEff, Args extends Array<any>, A, B, C, D, E>(body: (this: unassigned, ...args: Args) => Generator<Eff, AEff, never> | (Eff & Effect<AEff, any, any>), a: (_: Effect<AEff, [Eff] extends [never] ? never : [Eff] extends [Yieldable<infer _S, infer _A, infer E, infer _R>] ? E : never, [Eff] extends [never] ? never : [Eff] extends [Yieldable<infer _S, infer _A, infer _E, infer R>] ? R : never>, ...args: Args) => A, b: (_: A, ...args: Args) => B, c: (_: B, ...args: Args) => C, d: (_: C, ...args: Args) => D, e: (_: D, ...args: Args) => E): (...args: Args) => E; // overload 16
export declare const fn: <Self, Eff extends Yieldable<any, any, any, any>, AEff, Args extends Array<any>, A, B, C, D, E>(body: (this: Self, ...args: Args) => Generator<Eff, AEff, never> | (Eff & Effect<AEff, any, any>), a: (_: Effect<AEff, [Eff] extends [never] ? never : [Eff] extends [Yieldable<infer _S, infer _A, infer E, infer _R>] ? E : never, [Eff] extends [never] ? never : [Eff] extends [Yieldable<infer _S, infer _A, infer _E, infer R>] ? R : never>, ...args: Args) => A, b: (_: A, ...args: Args) => B, c: (_: B, ...args: Args) => C, d: (_: C, ...args: Args) => D, e: (_: D, ...args: Args) => E): (this: Self, ...args: Args) => E; // overload 17
export declare const fn: <Self, Eff extends Yieldable<any, any, any, any>, AEff, Args extends Array<any>, A, B, C, D, E>(options: { readonly self: Self; }, body: (this: Self, ...args: Args) => Generator<Eff, AEff, never> | (Eff & Effect<AEff, any, any>), a: (_: Effect<AEff, [Eff] extends [never] ? never : [Eff] extends [Yieldable<infer _S, infer _A, infer E, infer _R>] ? E : never, [Eff] extends [never] ? never : [Eff] extends [Yieldable<infer _S, infer _A, infer _E, infer R>] ? R : never>, ...args: Args) => A, b: (_: A, ...args: Args) => B, c: (_: B, ...args: Args) => C, d: (_: C, ...args: Args) => D, e: (_: D, ...args: Args) => E): (...args: Args) => E; // overload 18
export declare const fn: <Eff extends Yieldable<any, any, any, any>, AEff, Args extends Array<any>, A, B, C, D, E, F>(body: (this: unassigned, ...args: Args) => Generator<Eff, AEff, never> | (Eff & Effect<AEff, any, any>), a: (_: Effect<AEff, [Eff] extends [never] ? never : [Eff] extends [Yieldable<infer _S, infer _A, infer E, infer _R>] ? E : never, [Eff] extends [never] ? never : [Eff] extends [Yieldable<infer _S, infer _A, infer _E, infer R>] ? R : never>, ...args: Args) => A, b: (_: A, ...args: Args) => B, c: (_: B, ...args: Args) => C, d: (_: C, ...args: Args) => D, e: (_: D, ...args: Args) => E, f: (_: E, ...args: Args) => F): (...args: Args) => F; // overload 19
export declare const fn: <Self, Eff extends Yieldable<any, any, any, any>, AEff, Args extends Array<any>, A, B, C, D, E, F>(body: (this: Self, ...args: Args) => Generator<Eff, AEff, never> | (Eff & Effect<AEff, any, any>), a: (_: Effect<AEff, [Eff] extends [never] ? never : [Eff] extends [Yieldable<infer _S, infer _A, infer E, infer _R>] ? E : never, [Eff] extends [never] ? never : [Eff] extends [Yieldable<infer _S, infer _A, infer _E, infer R>] ? R : never>, ...args: Args) => A, b: (_: A, ...args: Args) => B, c: (_: B, ...args: Args) => C, d: (_: C, ...args: Args) => D, e: (_: D, ...args: Args) => E, f: (_: E, ...args: Args) => F): (this: Self, ...args: Args) => F; // overload 20
export declare const fn: <Self, Eff extends Yieldable<any, any, any, any>, AEff, Args extends Array<any>, A, B, C, D, E, F>(options: { readonly self: Self; }, body: (this: Self, ...args: Args) => Generator<Eff, AEff, never> | (Eff & Effect<AEff, any, any>), a: (_: Effect<AEff, [Eff] extends [never] ? never : [Eff] extends [Yieldable<infer _S, infer _A, infer E, infer _R>] ? E : never, [Eff] extends [never] ? never : [Eff] extends [Yieldable<infer _S, infer _A, infer _E, infer R>] ? R : never>, ...args: Args) => A, b: (_: A, ...args: Args) => B, c: (_: B, ...args: Args) => C, d: (_: C, ...args: Args) => D, e: (_: D, ...args: Args) => E, f: (_: E, ...args: Args) => F): (...args: Args) => F; // overload 21
export declare const fn: <Eff extends Yieldable<any, any, any, any>, AEff, Args extends Array<any>, A, B, C, D, E, F, G>(body: (this: unassigned, ...args: Args) => Generator<Eff, AEff, never> | (Eff & Effect<AEff, any, any>), a: (_: Effect<AEff, [Eff] extends [never] ? never : [Eff] extends [Yieldable<infer _S, infer _A, infer E, infer _R>] ? E : never, [Eff] extends [never] ? never : [Eff] extends [Yieldable<infer _S, infer _A, infer _E, infer R>] ? R : never>, ...args: Args) => A, b: (_: A, ...args: Args) => B, c: (_: B, ...args: Args) => C, d: (_: C, ...args: Args) => D, e: (_: D, ...args: Args) => E, f: (_: E, ...args: Args) => F, g: (_: F, ...args: Args) => G): (...args: Args) => G; // overload 22
export declare const fn: <Self, Eff extends Yieldable<any, any, any, any>, AEff, Args extends Array<any>, A, B, C, D, E, F, G>(body: (this: Self, ...args: Args) => Generator<Eff, AEff, never> | (Eff & Effect<AEff, any, any>), a: (_: Effect<AEff, [Eff] extends [never] ? never : [Eff] extends [Yieldable<infer _S, infer _A, infer E, infer _R>] ? E : never, [Eff] extends [never] ? never : [Eff] extends [Yieldable<infer _S, infer _A, infer _E, infer R>] ? R : never>, ...args: Args) => A, b: (_: A, ...args: Args) => B, c: (_: B, ...args: Args) => C, d: (_: C, ...args: Args) => D, e: (_: D, ...args: Args) => E, f: (_: E, ...args: Args) => F, g: (_: F, ...args: Args) => G): (this: Self, ...args: Args) => G; // overload 23
export declare const fn: <Self, Eff extends Yieldable<any, any, any, any>, AEff, Args extends Array<any>, A, B, C, D, E, F, G>(options: { readonly self: Self; }, body: (this: Self, ...args: Args) => Generator<Eff, AEff, never> | (Eff & Effect<AEff, any, any>), a: (_: Effect<AEff, [Eff] extends [never] ? never : [Eff] extends [Yieldable<infer _S, infer _A, infer E, infer _R>] ? E : never, [Eff] extends [never] ? never : [Eff] extends [Yieldable<infer _S, infer _A, infer _E, infer R>] ? R : never>, ...args: Args) => A, b: (_: A, ...args: Args) => B, c: (_: B, ...args: Args) => C, d: (_: C, ...args: Args) => D, e: (_: D, ...args: Args) => E, f: (_: E, ...args: Args) => F, g: (_: F, ...args: Args) => G): (...args: Args) => G; // overload 24
export declare const fn: <Eff extends Yieldable<any, any, any, any>, AEff, Args extends Array<any>, A, B, C, D, E, F, G, H>(body: (this: unassigned, ...args: Args) => Generator<Eff, AEff, never> | (Eff & Effect<AEff, any, any>), a: (_: Effect<AEff, [Eff] extends [never] ? never : [Eff] extends [Yieldable<infer _S, infer _A, infer E, infer _R>] ? E : never, [Eff] extends [never] ? never : [Eff] extends [Yieldable<infer _S, infer _A, infer _E, infer R>] ? R : never>, ...args: Args) => A, b: (_: A, ...args: Args) => B, c: (_: B, ...args: Args) => C, d: (_: C, ...args: Args) => D, e: (_: D, ...args: Args) => E, f: (_: E, ...args: Args) => F, g: (_: F, ...args: Args) => G, h: (_: G, ...args: Args) => H): (...args: Args) => H; // overload 25
export declare const fn: <Self, Eff extends Yieldable<any, any, any, any>, AEff, Args extends Array<any>, A, B, C, D, E, F, G, H>(body: (this: Self, ...args: Args) => Generator<Eff, AEff, never> | (Eff & Effect<AEff, any, any>), a: (_: Effect<AEff, [Eff] extends [never] ? never : [Eff] extends [Yieldable<infer _S, infer _A, infer E, infer _R>] ? E : never, [Eff] extends [never] ? never : [Eff] extends [Yieldable<infer _S, infer _A, infer _E, infer R>] ? R : never>, ...args: Args) => A, b: (_: A, ...args: Args) => B, c: (_: B, ...args: Args) => C, d: (_: C, ...args: Args) => D, e: (_: D, ...args: Args) => E, f: (_: E, ...args: Args) => F, g: (_: F, ...args: Args) => G, h: (_: G, ...args: Args) => H): (this: Self, ...args: Args) => H; // overload 26
export declare const fn: <Self, Eff extends Yieldable<any, any, any, any>, AEff, Args extends Array<any>, A, B, C, D, E, F, G, H>(options: { readonly self: Self; }, body: (this: Self, ...args: Args) => Generator<Eff, AEff, never> | (Eff & Effect<AEff, any, any>), a: (_: Effect<AEff, [Eff] extends [never] ? never : [Eff] extends [Yieldable<infer _S, infer _A, infer E, infer _R>] ? E : never, [Eff] extends [never] ? never : [Eff] extends [Yieldable<infer _S, infer _A, infer _E, infer R>] ? R : never>, ...args: Args) => A, b: (_: A, ...args: Args) => B, c: (_: B, ...args: Args) => C, d: (_: C, ...args: Args) => D, e: (_: D, ...args: Args) => E, f: (_: E, ...args: Args) => F, g: (_: F, ...args: Args) => G, h: (_: G, ...args: Args) => H): (...args: Args) => H; // overload 27
export declare const fn: <Eff extends Yieldable<any, any, any, any>, AEff, Args extends Array<any>, A, B, C, D, E, F, G, H, I>(body: (this: unassigned, ...args: Args) => Generator<Eff, AEff, never> | (Eff & Effect<AEff, any, any>), a: (_: Effect<AEff, [Eff] extends [never] ? never : [Eff] extends [Yieldable<infer _S, infer _A, infer E, infer _R>] ? E : never, [Eff] extends [never] ? never : [Eff] extends [Yieldable<infer _S, infer _A, infer _E, infer R>] ? R : never>, ...args: Args) => A, b: (_: A, ...args: Args) => B, c: (_: B, ...args: Args) => C, d: (_: C, ...args: Args) => D, e: (_: D, ...args: Args) => E, f: (_: E, ...args: Args) => F, g: (_: F, ...args: Args) => G, h: (_: G, ...args: Args) => H, i: (_: H, ...args: Args) => I): (...args: Args) => I; // overload 28
export declare const fn: <Self, Eff extends Yieldable<any, any, any, any>, AEff, Args extends Array<any>, A, B, C, D, E, F, G, H, I>(body: (this: Self, ...args: Args) => Generator<Eff, AEff, never> | (Eff & Effect<AEff, any, any>), a: (_: Effect<AEff, [Eff] extends [never] ? never : [Eff] extends [Yieldable<infer _S, infer _A, infer E, infer _R>] ? E : never, [Eff] extends [never] ? never : [Eff] extends [Yieldable<infer _S, infer _A, infer _E, infer R>] ? R : never>, ...args: Args) => A, b: (_: A, ...args: Args) => B, c: (_: B, ...args: Args) => C, d: (_: C, ...args: Args) => D, e: (_: D, ...args: Args) => E, f: (_: E, ...args: Args) => F, g: (_: F, ...args: Args) => G, h: (_: G, ...args: Args) => H, i: (_: H, ...args: Args) => I): (this: Self, ...args: Args) => I; // overload 29
export declare const fn: <Self, Eff extends Yieldable<any, any, any, any>, AEff, Args extends Array<any>, A, B, C, D, E, F, G, H, I>(options: { readonly self: Self; }, body: (this: Self, ...args: Args) => Generator<Eff, AEff, never> | (Eff & Effect<AEff, any, any>), a: (_: Effect<AEff, [Eff] extends [never] ? never : [Eff] extends [Yieldable<infer _S, infer _A, infer E, infer _R>] ? E : never, [Eff] extends [never] ? never : [Eff] extends [Yieldable<infer _S, infer _A, infer _E, infer R>] ? R : never>, ...args: Args) => A, b: (_: A, ...args: Args) => B, c: (_: B, ...args: Args) => C, d: (_: C, ...args: Args) => D, e: (_: D, ...args: Args) => E, f: (_: E, ...args: Args) => F, g: (_: F, ...args: Args) => G, h: (_: G, ...args: Args) => H, i: (_: H, ...args: Args) => I): (...args: Args) => I; // overload 30
export declare const fn: <Eff extends Yieldable<any, any, any, any>, AEff, Args extends Array<any>, A, B, C, D, E, F, G, H, I, J>(body: (this: unassigned, ...args: Args) => Generator<Eff, AEff, never> | (Eff & Effect<AEff, any, any>), a: (_: Effect<AEff, [Eff] extends [never] ? never : [Eff] extends [Yieldable<infer _S, infer _A, infer E, infer _R>] ? E : never, [Eff] extends [never] ? never : [Eff] extends [Yieldable<infer _S, infer _A, infer _E, infer R>] ? R : never>, ...args: Args) => A, b: (_: A, ...args: Args) => B, c: (_: B, ...args: Args) => C, d: (_: C, ...args: Args) => D, e: (_: D, ...args: Args) => E, f: (_: E, ...args: Args) => F, g: (_: F, ...args: Args) => G, h: (_: G, ...args: Args) => H, i: (_: H, ...args: Args) => I, j: (_: I, ...args: Args) => J): (...args: Args) => J; // overload 31
export declare const fn: <Self, Eff extends Yieldable<any, any, any, any>, AEff, Args extends Array<any>, A, B, C, D, E, F, G, H, I, J>(body: (this: Self, ...args: Args) => Generator<Eff, AEff, never> | (Eff & Effect<AEff, any, any>), a: (_: Effect<AEff, [Eff] extends [never] ? never : [Eff] extends [Yieldable<infer _S, infer _A, infer E, infer _R>] ? E : never, [Eff] extends [never] ? never : [Eff] extends [Yieldable<infer _S, infer _A, infer _E, infer R>] ? R : never>, ...args: Args) => A, b: (_: A, ...args: Args) => B, c: (_: B, ...args: Args) => C, d: (_: C, ...args: Args) => D, e: (_: D, ...args: Args) => E, f: (_: E, ...args: Args) => F, g: (_: F, ...args: Args) => G, h: (_: G, ...args: Args) => H, i: (_: H, ...args: Args) => I, j: (_: I, ...args: Args) => J): (this: Self, ...args: Args) => J; // overload 32
export declare const fn: <Self, Eff extends Yieldable<any, any, any, any>, AEff, Args extends Array<any>, A, B, C, D, E, F, G, H, I, J>(options: { readonly self: Self; }, body: (this: Self, ...args: Args) => Generator<Eff, AEff, never> | (Eff & Effect<AEff, any, any>), a: (_: Effect<AEff, [Eff] extends [never] ? never : [Eff] extends [Yieldable<infer _S, infer _A, infer E, infer _R>] ? E : never, [Eff] extends [never] ? never : [Eff] extends [Yieldable<infer _S, infer _A, infer _E, infer R>] ? R : never>, ...args: Args) => A, b: (_: A, ...args: Args) => B, c: (_: B, ...args: Args) => C, d: (_: C, ...args: Args) => D, e: (_: D, ...args: Args) => E, f: (_: E, ...args: Args) => F, g: (_: F, ...args: Args) => G, h: (_: G, ...args: Args) => H, i: (_: H, ...args: Args) => I, j: (_: I, ...args: Args) => J): (...args: Args) => J; // overload 33
export declare const fn: <Eff extends Yieldable<any, any, any, any>, AEff, Args extends Array<any>, A, B, C, D, E, F, G, H, I, J, K>(body: (this: unassigned, ...args: Args) => Generator<Eff, AEff, never> | (Eff & Effect<AEff, any, any>), a: (_: Effect<AEff, [Eff] extends [never] ? never : [Eff] extends [Yieldable<infer _S, infer _A, infer E, infer _R>] ? E : never, [Eff] extends [never] ? never : [Eff] extends [Yieldable<infer _S, infer _A, infer _E, infer R>] ? R : never>, ...args: Args) => A, b: (_: A, ...args: Args) => B, c: (_: B, ...args: Args) => C, d: (_: C, ...args: Args) => D, e: (_: D, ...args: Args) => E, f: (_: E, ...args: Args) => F, g: (_: F, ...args: Args) => G, h: (_: G, ...args: Args) => H, i: (_: H, ...args: Args) => I, j: (_: I, ...args: Args) => J, k: (_: J, ...args: Args) => K): (...args: Args) => K; // overload 34
export declare const fn: <Self, Eff extends Yieldable<any, any, any, any>, AEff, Args extends Array<any>, A, B, C, D, E, F, G, H, I, J, K>(body: (this: Self, ...args: Args) => Generator<Eff, AEff, never> | (Eff & Effect<AEff, any, any>), a: (_: Effect<AEff, [Eff] extends [never] ? never : [Eff] extends [Yieldable<infer _S, infer _A, infer E, infer _R>] ? E : never, [Eff] extends [never] ? never : [Eff] extends [Yieldable<infer _S, infer _A, infer _E, infer R>] ? R : never>, ...args: Args) => A, b: (_: A, ...args: Args) => B, c: (_: B, ...args: Args) => C, d: (_: C, ...args: Args) => D, e: (_: D, ...args: Args) => E, f: (_: E, ...args: Args) => F, g: (_: F, ...args: Args) => G, h: (_: G, ...args: Args) => H, i: (_: H, ...args: Args) => I, j: (_: I, ...args: Args) => J, k: (_: J, ...args: Args) => K): (this: Self, ...args: Args) => K; // overload 35
export declare const fn: <Self, Eff extends Yieldable<any, any, any, any>, AEff, Args extends Array<any>, A, B, C, D, E, F, G, H, I, J, K>(options: { readonly self: Self; }, body: (this: Self, ...args: Args) => Generator<Eff, AEff, never> | (Eff & Effect<AEff, any, any>), a: (_: Effect<AEff, [Eff] extends [never] ? never : [Eff] extends [Yieldable<infer _S, infer _A, infer E, infer _R>] ? E : never, [Eff] extends [never] ? never : [Eff] extends [Yieldable<infer _S, infer _A, infer _E, infer R>] ? R : never>, ...args: Args) => A, b: (_: A, ...args: Args) => B, c: (_: B, ...args: Args) => C, d: (_: C, ...args: Args) => D, e: (_: D, ...args: Args) => E, f: (_: E, ...args: Args) => F, g: (_: F, ...args: Args) => G, h: (_: G, ...args: Args) => H, i: (_: H, ...args: Args) => I, j: (_: I, ...args: Args) => J, k: (_: J, ...args: Args) => K): (...args: Args) => K; // overload 36
export declare const fn: <Eff extends Yieldable<any, any, any, any>, AEff, Args extends Array<any>, A, B, C, D, E, F, G, H, I, J, K, L>(body: (this: unassigned, ...args: Args) => Generator<Eff, AEff, never> | (Eff & Effect<AEff, any, any>), a: (_: Effect<AEff, [Eff] extends [never] ? never : [Eff] extends [Yieldable<infer _S, infer _A, infer E, infer _R>] ? E : never, [Eff] extends [never] ? never : [Eff] extends [Yieldable<infer _S, infer _A, infer _E, infer R>] ? R : never>, ...args: Args) => A, b: (_: A, ...args: Args) => B, c: (_: B, ...args: Args) => C, d: (_: C, ...args: Args) => D, e: (_: D, ...args: Args) => E, f: (_: E, ...args: Args) => F, g: (_: F, ...args: Args) => G, h: (_: G, ...args: Args) => H, i: (_: H, ...args: Args) => I, j: (_: I, ...args: Args) => J, k: (_: J, ...args: Args) => K, l: (_: K, ...args: Args) => L): (...args: Args) => L; // overload 37
export declare const fn: <Self, Eff extends Yieldable<any, any, any, any>, AEff, Args extends Array<any>, A, B, C, D, E, F, G, H, I, J, K, L>(body: (this: Self, ...args: Args) => Generator<Eff, AEff, never> | (Eff & Effect<AEff, any, any>), a: (_: Effect<AEff, [Eff] extends [never] ? never : [Eff] extends [Yieldable<infer _S, infer _A, infer E, infer _R>] ? E : never, [Eff] extends [never] ? never : [Eff] extends [Yieldable<infer _S, infer _A, infer _E, infer R>] ? R : never>, ...args: Args) => A, b: (_: A, ...args: Args) => B, c: (_: B, ...args: Args) => C, d: (_: C, ...args: Args) => D, e: (_: D, ...args: Args) => E, f: (_: E, ...args: Args) => F, g: (_: F, ...args: Args) => G, h: (_: G, ...args: Args) => H, i: (_: H, ...args: Args) => I, j: (_: I, ...args: Args) => J, k: (_: J, ...args: Args) => K, l: (_: K, ...args: Args) => L): (this: Self, ...args: Args) => L; // overload 38
export declare const fn: <Self, Eff extends Yieldable<any, any, any, any>, AEff, Args extends Array<any>, A, B, C, D, E, F, G, H, I, J, K, L>(options: { readonly self: Self; }, body: (this: Self, ...args: Args) => Generator<Eff, AEff, never> | (Eff & Effect<AEff, any, any>), a: (_: Effect<AEff, [Eff] extends [never] ? never : [Eff] extends [Yieldable<infer _S, infer _A, infer E, infer _R>] ? E : never, [Eff] extends [never] ? never : [Eff] extends [Yieldable<infer _S, infer _A, infer _E, infer R>] ? R : never>, ...args: Args) => A, b: (_: A, ...args: Args) => B, c: (_: B, ...args: Args) => C, d: (_: C, ...args: Args) => D, e: (_: D, ...args: Args) => E, f: (_: E, ...args: Args) => F, g: (_: F, ...args: Args) => G, h: (_: G, ...args: Args) => H, i: (_: H, ...args: Args) => I, j: (_: I, ...args: Args) => J, k: (_: J, ...args: Args) => K, l: (_: K, ...args: Args) => L): (...args: Args) => L; // overload 39
export declare const fn: <Eff extends Yieldable<any, any, any, any>, AEff, Args extends Array<any>, A, B, C, D, E, F, G, H, I, J, K, L, M>(body: (this: unassigned, ...args: Args) => Generator<Eff, AEff, never> | (Eff & Effect<AEff, any, any>), a: (_: Effect<AEff, [Eff] extends [never] ? never : [Eff] extends [Yieldable<infer _S, infer _A, infer E, infer _R>] ? E : never, [Eff] extends [never] ? never : [Eff] extends [Yieldable<infer _S, infer _A, infer _E, infer R>] ? R : never>, ...args: Args) => A, b: (_: A, ...args: Args) => B, c: (_: B, ...args: Args) => C, d: (_: C, ...args: Args) => D, e: (_: D, ...args: Args) => E, f: (_: E, ...args: Args) => F, g: (_: F, ...args: Args) => G, h: (_: G, ...args: Args) => H, i: (_: H, ...args: Args) => I, j: (_: I, ...args: Args) => J, k: (_: J, ...args: Args) => K, l: (_: K, ...args: Args) => L, m: (_: L, ...args: Args) => M): (...args: Args) => M; // overload 40
export declare const fn: <Self, Eff extends Yieldable<any, any, any, any>, AEff, Args extends Array<any>, A, B, C, D, E, F, G, H, I, J, K, L, M>(body: (this: Self, ...args: Args) => Generator<Eff, AEff, never> | (Eff & Effect<AEff, any, any>), a: (_: Effect<AEff, [Eff] extends [never] ? never : [Eff] extends [Yieldable<infer _S, infer _A, infer E, infer _R>] ? E : never, [Eff] extends [never] ? never : [Eff] extends [Yieldable<infer _S, infer _A, infer _E, infer R>] ? R : never>, ...args: Args) => A, b: (_: A, ...args: Args) => B, c: (_: B, ...args: Args) => C, d: (_: C, ...args: Args) => D, e: (_: D, ...args: Args) => E, f: (_: E, ...args: Args) => F, g: (_: F, ...args: Args) => G, h: (_: G, ...args: Args) => H, i: (_: H, ...args: Args) => I, j: (_: I, ...args: Args) => J, k: (_: J, ...args: Args) => K, l: (_: K, ...args: Args) => L, m: (_: L, ...args: Args) => M): (this: Self, ...args: Args) => M; // overload 41
export declare const fn: <Self, Eff extends Yieldable<any, any, any, any>, AEff, Args extends Array<any>, A, B, C, D, E, F, G, H, I, J, K, L, M>(options: { readonly self: Self; }, body: (this: Self, ...args: Args) => Generator<Eff, AEff, never> | (Eff & Effect<AEff, any, any>), a: (_: Effect<AEff, [Eff] extends [never] ? never : [Eff] extends [Yieldable<infer _S, infer _A, infer E, infer _R>] ? E : never, [Eff] extends [never] ? never : [Eff] extends [Yieldable<infer _S, infer _A, infer _E, infer R>] ? R : never>, ...args: Args) => A, b: (_: A, ...args: Args) => B, c: (_: B, ...args: Args) => C, d: (_: C, ...args: Args) => D, e: (_: D, ...args: Args) => E, f: (_: E, ...args: Args) => F, g: (_: F, ...args: Args) => G, h: (_: G, ...args: Args) => H, i: (_: H, ...args: Args) => I, j: (_: I, ...args: Args) => J, k: (_: J, ...args: Args) => K, l: (_: K, ...args: Args) => L, m: (_: L, ...args: Args) => M): (...args: Args) => M; // overload 42
export declare const fn: <Eff extends Yieldable<any, any, any, any>, AEff, Args extends Array<any>, A, B, C, D, E, F, G, H, I, J, K, L, M, N>(body: (this: unassigned, ...args: Args) => Generator<Eff, AEff, never> | (Eff & Effect<AEff, any, any>), a: (_: Effect<AEff, [Eff] extends [never] ? never : [Eff] extends [Yieldable<infer _S, infer _A, infer E, infer _R>] ? E : never, [Eff] extends [never] ? never : [Eff] extends [Yieldable<infer _S, infer _A, infer _E, infer R>] ? R : never>, ...args: Args) => A, b: (_: A, ...args: Args) => B, c: (_: B, ...args: Args) => C, d: (_: C, ...args: Args) => D, e: (_: D, ...args: Args) => E, f: (_: E, ...args: Args) => F, g: (_: F, ...args: Args) => G, h: (_: G, ...args: Args) => H, i: (_: H, ...args: Args) => I, j: (_: I, ...args: Args) => J, k: (_: J, ...args: Args) => K, l: (_: K, ...args: Args) => L, m: (_: L, ...args: Args) => M, n: (_: M, ...args: Args) => N): (...args: Args) => N; // overload 43
export declare const fn: <Self, Eff extends Yieldable<any, any, any, any>, AEff, Args extends Array<any>, A, B, C, D, E, F, G, H, I, J, K, L, M, N>(body: (this: Self, ...args: Args) => Generator<Eff, AEff, never> | (Eff & Effect<AEff, any, any>), a: (_: Effect<AEff, [Eff] extends [never] ? never : [Eff] extends [Yieldable<infer _S, infer _A, infer E, infer _R>] ? E : never, [Eff] extends [never] ? never : [Eff] extends [Yieldable<infer _S, infer _A, infer _E, infer R>] ? R : never>, ...args: Args) => A, b: (_: A, ...args: Args) => B, c: (_: B, ...args: Args) => C, d: (_: C, ...args: Args) => D, e: (_: D, ...args: Args) => E, f: (_: E, ...args: Args) => F, g: (_: F, ...args: Args) => G, h: (_: G, ...args: Args) => H, i: (_: H, ...args: Args) => I, j: (_: I, ...args: Args) => J, k: (_: J, ...args: Args) => K, l: (_: K, ...args: Args) => L, m: (_: L, ...args: Args) => M, n: (_: M, ...args: Args) => N): (this: Self, ...args: Args) => N; // overload 44
export declare const fn: <Self, Eff extends Yieldable<any, any, any, any>, AEff, Args extends Array<any>, A, B, C, D, E, F, G, H, I, J, K, L, M, N>(options: { readonly self: Self; }, body: (this: Self, ...args: Args) => Generator<Eff, AEff, never> | (Eff & Effect<AEff, any, any>), a: (_: Effect<AEff, [Eff] extends [never] ? never : [Eff] extends [Yieldable<infer _S, infer _A, infer E, infer _R>] ? E : never, [Eff] extends [never] ? never : [Eff] extends [Yieldable<infer _S, infer _A, infer _E, infer R>] ? R : never>, ...args: Args) => A, b: (_: A, ...args: Args) => B, c: (_: B, ...args: Args) => C, d: (_: C, ...args: Args) => D, e: (_: D, ...args: Args) => E, f: (_: E, ...args: Args) => F, g: (_: F, ...args: Args) => G, h: (_: G, ...args: Args) => H, i: (_: H, ...args: Args) => I, j: (_: I, ...args: Args) => J, k: (_: J, ...args: Args) => K, l: (_: K, ...args: Args) => L, m: (_: L, ...args: Args) => M, n: (_: M, ...args: Args) => N): (...args: Args) => N; // overload 45
export declare const fn: <Eff extends Yieldable<any, any, any, any>, AEff, Args extends Array<any>, A, B, C, D, E, F, G, H, I, J, K, L, M, N, O>(body: (this: unassigned, ...args: Args) => Generator<Eff, AEff, never> | (Eff & Effect<AEff, any, any>), a: (_: Effect<AEff, [Eff] extends [never] ? never : [Eff] extends [Yieldable<infer _S, infer _A, infer E, infer _R>] ? E : never, [Eff] extends [never] ? never : [Eff] extends [Yieldable<infer _S, infer _A, infer _E, infer R>] ? R : never>, ...args: Args) => A, b: (_: A, ...args: Args) => B, c: (_: B, ...args: Args) => C, d: (_: C, ...args: Args) => D, e: (_: D, ...args: Args) => E, f: (_: E, ...args: Args) => F, g: (_: F, ...args: Args) => G, h: (_: G, ...args: Args) => H, i: (_: H, ...args: Args) => I, j: (_: I, ...args: Args) => J, k: (_: J, ...args: Args) => K, l: (_: K, ...args: Args) => L, m: (_: L, ...args: Args) => M, n: (_: M, ...args: Args) => N, o: (_: N, ...args: Args) => O): (...args: Args) => O; // overload 46
export declare const fn: <Self, Eff extends Yieldable<any, any, any, any>, AEff, Args extends Array<any>, A, B, C, D, E, F, G, H, I, J, K, L, M, N, O>(body: (this: Self, ...args: Args) => Generator<Eff, AEff, never> | (Eff & Effect<AEff, any, any>), a: (_: Effect<AEff, [Eff] extends [never] ? never : [Eff] extends [Yieldable<infer _S, infer _A, infer E, infer _R>] ? E : never, [Eff] extends [never] ? never : [Eff] extends [Yieldable<infer _S, infer _A, infer _E, infer R>] ? R : never>, ...args: Args) => A, b: (_: A, ...args: Args) => B, c: (_: B, ...args: Args) => C, d: (_: C, ...args: Args) => D, e: (_: D, ...args: Args) => E, f: (_: E, ...args: Args) => F, g: (_: F, ...args: Args) => G, h: (_: G, ...args: Args) => H, i: (_: H, ...args: Args) => I, j: (_: I, ...args: Args) => J, k: (_: J, ...args: Args) => K, l: (_: K, ...args: Args) => L, m: (_: L, ...args: Args) => M, n: (_: M, ...args: Args) => N, o: (_: N, ...args: Args) => O): (this: Self, ...args: Args) => O; // overload 47
export declare const fn: <Self, Eff extends Yieldable<any, any, any, any>, AEff, Args extends Array<any>, A, B, C, D, E, F, G, H, I, J, K, L, M, N, O>(options: { readonly self: Self; }, body: (this: Self, ...args: Args) => Generator<Eff, AEff, never> | (Eff & Effect<AEff, any, any>), a: (_: Effect<AEff, [Eff] extends [never] ? never : [Eff] extends [Yieldable<infer _S, infer _A, infer E, infer _R>] ? E : never, [Eff] extends [never] ? never : [Eff] extends [Yieldable<infer _S, infer _A, infer _E, infer R>] ? R : never>, ...args: Args) => A, b: (_: A, ...args: Args) => B, c: (_: B, ...args: Args) => C, d: (_: C, ...args: Args) => D, e: (_: D, ...args: Args) => E, f: (_: E, ...args: Args) => F, g: (_: F, ...args: Args) => G, h: (_: G, ...args: Args) => H, i: (_: H, ...args: Args) => I, j: (_: I, ...args: Args) => J, k: (_: J, ...args: Args) => K, l: (_: K, ...args: Args) => L, m: (_: L, ...args: Args) => M, n: (_: M, ...args: Args) => N, o: (_: N, ...args: Args) => O): (...args: Args) => O; // overload 48
export declare const fn: <Eff extends Yieldable<any, any, any, any>, AEff, Args extends Array<any>, A, B, C, D, E, F, G, H, I, J, K, L, M, N, O, P>(body: (this: unassigned, ...args: Args) => Generator<Eff, AEff, never> | (Eff & Effect<AEff, any, any>), a: (_: Effect<AEff, [Eff] extends [never] ? never : [Eff] extends [Yieldable<infer _S, infer _A, infer E, infer _R>] ? E : never, [Eff] extends [never] ? never : [Eff] extends [Yieldable<infer _S, infer _A, infer _E, infer R>] ? R : never>, ...args: Args) => A, b: (_: A, ...args: Args) => B, c: (_: B, ...args: Args) => C, d: (_: C, ...args: Args) => D, e: (_: D, ...args: Args) => E, f: (_: E, ...args: Args) => F, g: (_: F, ...args: Args) => G, h: (_: G, ...args: Args) => H, i: (_: H, ...args: Args) => I, j: (_: I, ...args: Args) => J, k: (_: J, ...args: Args) => K, l: (_: K, ...args: Args) => L, m: (_: L, ...args: Args) => M, n: (_: M, ...args: Args) => N, o: (_: N, ...args: Args) => O, p: (_: O, ...args: Args) => P): (...args: Args) => P; // overload 49
export declare const fn: <Self, Eff extends Yieldable<any, any, any, any>, AEff, Args extends Array<any>, A, B, C, D, E, F, G, H, I, J, K, L, M, N, O, P>(body: (this: Self, ...args: Args) => Generator<Eff, AEff, never> | (Eff & Effect<AEff, any, any>), a: (_: Effect<AEff, [Eff] extends [never] ? never : [Eff] extends [Yieldable<infer _S, infer _A, infer E, infer _R>] ? E : never, [Eff] extends [never] ? never : [Eff] extends [Yieldable<infer _S, infer _A, infer _E, infer R>] ? R : never>, ...args: Args) => A, b: (_: A, ...args: Args) => B, c: (_: B, ...args: Args) => C, d: (_: C, ...args: Args) => D, e: (_: D, ...args: Args) => E, f: (_: E, ...args: Args) => F, g: (_: F, ...args: Args) => G, h: (_: G, ...args: Args) => H, i: (_: H, ...args: Args) => I, j: (_: I, ...args: Args) => J, k: (_: J, ...args: Args) => K, l: (_: K, ...args: Args) => L, m: (_: L, ...args: Args) => M, n: (_: M, ...args: Args) => N, o: (_: N, ...args: Args) => O, p: (_: O, ...args: Args) => P): (this: Self, ...args: Args) => P; // overload 50
export declare const fn: <Self, Eff extends Yieldable<any, any, any, any>, AEff, Args extends Array<any>, A, B, C, D, E, F, G, H, I, J, K, L, M, N, O, P>(options: { readonly self: Self; }, body: (this: Self, ...args: Args) => Generator<Eff, AEff, never> | (Eff & Effect<AEff, any, any>), a: (_: Effect<AEff, [Eff] extends [never] ? never : [Eff] extends [Yieldable<infer _S, infer _A, infer E, infer _R>] ? E : never, [Eff] extends [never] ? never : [Eff] extends [Yieldable<infer _S, infer _A, infer _E, infer R>] ? R : never>, ...args: Args) => A, b: (_: A, ...args: Args) => B, c: (_: B, ...args: Args) => C, d: (_: C, ...args: Args) => D, e: (_: D, ...args: Args) => E, f: (_: E, ...args: Args) => F, g: (_: F, ...args: Args) => G, h: (_: G, ...args: Args) => H, i: (_: H, ...args: Args) => I, j: (_: I, ...args: Args) => J, k: (_: J, ...args: Args) => K, l: (_: K, ...args: Args) => L, m: (_: L, ...args: Args) => M, n: (_: M, ...args: Args) => N, o: (_: N, ...args: Args) => O, p: (_: O, ...args: Args) => P): (...args: Args) => P; // overload 51
export declare const fn: <Eff extends Yieldable<any, any, any, any>, AEff, Args extends Array<any>, A, B, C, D, E, F, G, H, I, J, K, L, M, N, O, P, Q>(body: (this: unassigned, ...args: Args) => Generator<Eff, AEff, never> | (Eff & Effect<AEff, any, any>), a: (_: Effect<AEff, [Eff] extends [never] ? never : [Eff] extends [Yieldable<infer _S, infer _A, infer E, infer _R>] ? E : never, [Eff] extends [never] ? never : [Eff] extends [Yieldable<infer _S, infer _A, infer _E, infer R>] ? R : never>, ...args: Args) => A, b: (_: A, ...args: Args) => B, c: (_: B, ...args: Args) => C, d: (_: C, ...args: Args) => D, e: (_: D, ...args: Args) => E, f: (_: E, ...args: Args) => F, g: (_: F, ...args: Args) => G, h: (_: G, ...args: Args) => H, i: (_: H, ...args: Args) => I, j: (_: I, ...args: Args) => J, k: (_: J, ...args: Args) => K, l: (_: K, ...args: Args) => L, m: (_: L, ...args: Args) => M, n: (_: M, ...args: Args) => N, o: (_: N, ...args: Args) => O, p: (_: O, ...args: Args) => P, q: (_: P, ...args: Args) => Q): (...args: Args) => Q; // overload 52
export declare const fn: <Self, Eff extends Yieldable<any, any, any, any>, AEff, Args extends Array<any>, A, B, C, D, E, F, G, H, I, J, K, L, M, N, O, P, Q>(body: (this: Self, ...args: Args) => Generator<Eff, AEff, never> | (Eff & Effect<AEff, any, any>), a: (_: Effect<AEff, [Eff] extends [never] ? never : [Eff] extends [Yieldable<infer _S, infer _A, infer E, infer _R>] ? E : never, [Eff] extends [never] ? never : [Eff] extends [Yieldable<infer _S, infer _A, infer _E, infer R>] ? R : never>, ...args: Args) => A, b: (_: A, ...args: Args) => B, c: (_: B, ...args: Args) => C, d: (_: C, ...args: Args) => D, e: (_: D, ...args: Args) => E, f: (_: E, ...args: Args) => F, g: (_: F, ...args: Args) => G, h: (_: G, ...args: Args) => H, i: (_: H, ...args: Args) => I, j: (_: I, ...args: Args) => J, k: (_: J, ...args: Args) => K, l: (_: K, ...args: Args) => L, m: (_: L, ...args: Args) => M, n: (_: M, ...args: Args) => N, o: (_: N, ...args: Args) => O, p: (_: O, ...args: Args) => P, q: (_: P, ...args: Args) => Q): (this: Self, ...args: Args) => Q; // overload 53
export declare const fn: <Self, Eff extends Yieldable<any, any, any, any>, AEff, Args extends Array<any>, A, B, C, D, E, F, G, H, I, J, K, L, M, N, O, P, Q>(options: { readonly self: Self; }, body: (this: Self, ...args: Args) => Generator<Eff, AEff, never> | (Eff & Effect<AEff, any, any>), a: (_: Effect<AEff, [Eff] extends [never] ? never : [Eff] extends [Yieldable<infer _S, infer _A, infer E, infer _R>] ? E : never, [Eff] extends [never] ? never : [Eff] extends [Yieldable<infer _S, infer _A, infer _E, infer R>] ? R : never>, ...args: Args) => A, b: (_: A, ...args: Args) => B, c: (_: B, ...args: Args) => C, d: (_: C, ...args: Args) => D, e: (_: D, ...args: Args) => E, f: (_: E, ...args: Args) => F, g: (_: F, ...args: Args) => G, h: (_: G, ...args: Args) => H, i: (_: H, ...args: Args) => I, j: (_: I, ...args: Args) => J, k: (_: J, ...args: Args) => K, l: (_: K, ...args: Args) => L, m: (_: L, ...args: Args) => M, n: (_: M, ...args: Args) => N, o: (_: N, ...args: Args) => O, p: (_: O, ...args: Args) => P, q: (_: P, ...args: Args) => Q): (...args: Args) => Q; // overload 54
export declare const fn: <Eff extends Yieldable<any, any, any, any>, AEff, Args extends Array<any>, A, B, C, D, E, F, G, H, I, J, K, L, M, N, O, P, Q, R>(body: (this: unassigned, ...args: Args) => Generator<Eff, AEff, never> | (Eff & Effect<AEff, any, any>), a: (_: Effect<AEff, [Eff] extends [never] ? never : [Eff] extends [Yieldable<infer _S, infer _A, infer E, infer _R>] ? E : never, [Eff] extends [never] ? never : [Eff] extends [Yieldable<infer _S, infer _A, infer _E, infer R>] ? R : never>, ...args: Args) => A, b: (_: A, ...args: Args) => B, c: (_: B, ...args: Args) => C, d: (_: C, ...args: Args) => D, e: (_: D, ...args: Args) => E, f: (_: E, ...args: Args) => F, g: (_: F, ...args: Args) => G, h: (_: G, ...args: Args) => H, i: (_: H, ...args: Args) => I, j: (_: I, ...args: Args) => J, k: (_: J, ...args: Args) => K, l: (_: K, ...args: Args) => L, m: (_: L, ...args: Args) => M, n: (_: M, ...args: Args) => N, o: (_: N, ...args: Args) => O, p: (_: O, ...args: Args) => P, q: (_: P, ...args: Args) => Q, r: (_: Q, ...args: Args) => R): (...args: Args) => R; // overload 55
export declare const fn: <Self, Eff extends Yieldable<any, any, any, any>, AEff, Args extends Array<any>, A, B, C, D, E, F, G, H, I, J, K, L, M, N, O, P, Q, R>(body: (this: Self, ...args: Args) => Generator<Eff, AEff, never> | (Eff & Effect<AEff, any, any>), a: (_: Effect<AEff, [Eff] extends [never] ? never : [Eff] extends [Yieldable<infer _S, infer _A, infer E, infer _R>] ? E : never, [Eff] extends [never] ? never : [Eff] extends [Yieldable<infer _S, infer _A, infer _E, infer R>] ? R : never>, ...args: Args) => A, b: (_: A, ...args: Args) => B, c: (_: B, ...args: Args) => C, d: (_: C, ...args: Args) => D, e: (_: D, ...args: Args) => E, f: (_: E, ...args: Args) => F, g: (_: F, ...args: Args) => G, h: (_: G, ...args: Args) => H, i: (_: H, ...args: Args) => I, j: (_: I, ...args: Args) => J, k: (_: J, ...args: Args) => K, l: (_: K, ...args: Args) => L, m: (_: L, ...args: Args) => M, n: (_: M, ...args: Args) => N, o: (_: N, ...args: Args) => O, p: (_: O, ...args: Args) => P, q: (_: P, ...args: Args) => Q, r: (_: Q, ...args: Args) => R): (this: Self, ...args: Args) => R; // overload 56
export declare const fn: <Self, Eff extends Yieldable<any, any, any, any>, AEff, Args extends Array<any>, A, B, C, D, E, F, G, H, I, J, K, L, M, N, O, P, Q, R>(options: { readonly self: Self; }, body: (this: Self, ...args: Args) => Generator<Eff, AEff, never> | (Eff & Effect<AEff, any, any>), a: (_: Effect<AEff, [Eff] extends [never] ? never : [Eff] extends [Yieldable<infer _S, infer _A, infer E, infer _R>] ? E : never, [Eff] extends [never] ? never : [Eff] extends [Yieldable<infer _S, infer _A, infer _E, infer R>] ? R : never>, ...args: Args) => A, b: (_: A, ...args: Args) => B, c: (_: B, ...args: Args) => C, d: (_: C, ...args: Args) => D, e: (_: D, ...args: Args) => E, f: (_: E, ...args: Args) => F, g: (_: F, ...args: Args) => G, h: (_: G, ...args: Args) => H, i: (_: H, ...args: Args) => I, j: (_: I, ...args: Args) => J, k: (_: J, ...args: Args) => K, l: (_: K, ...args: Args) => L, m: (_: L, ...args: Args) => M, n: (_: M, ...args: Args) => N, o: (_: N, ...args: Args) => O, p: (_: O, ...args: Args) => P, q: (_: P, ...args: Args) => Q, r: (_: Q, ...args: Args) => R): (...args: Args) => R; // overload 57
export declare const fn: <Eff extends Yieldable<any, any, any, any>, AEff, Args extends Array<any>, A, B, C, D, E, F, G, H, I, J, K, L, M, N, O, P, Q, R, S>(body: (this: unassigned, ...args: Args) => Generator<Eff, AEff, never> | (Eff & Effect<AEff, any, any>), a: (_: Effect<AEff, [Eff] extends [never] ? never : [Eff] extends [Yieldable<infer _S, infer _A, infer E, infer _R>] ? E : never, [Eff] extends [never] ? never : [Eff] extends [Yieldable<infer _S, infer _A, infer _E, infer R>] ? R : never>, ...args: Args) => A, b: (_: A, ...args: Args) => B, c: (_: B, ...args: Args) => C, d: (_: C, ...args: Args) => D, e: (_: D, ...args: Args) => E, f: (_: E, ...args: Args) => F, g: (_: F, ...args: Args) => G, h: (_: G, ...args: Args) => H, i: (_: H, ...args: Args) => I, j: (_: I, ...args: Args) => J, k: (_: J, ...args: Args) => K, l: (_: K, ...args: Args) => L, m: (_: L, ...args: Args) => M, n: (_: M, ...args: Args) => N, o: (_: N, ...args: Args) => O, p: (_: O, ...args: Args) => P, q: (_: P, ...args: Args) => Q, r: (_: Q, ...args: Args) => R, s: (_: R, ...args: Args) => S): (...args: Args) => S; // overload 58
export declare const fn: <Self, Eff extends Yieldable<any, any, any, any>, AEff, Args extends Array<any>, A, B, C, D, E, F, G, H, I, J, K, L, M, N, O, P, Q, R, S>(body: (this: Self, ...args: Args) => Generator<Eff, AEff, never> | (Eff & Effect<AEff, any, any>), a: (_: Effect<AEff, [Eff] extends [never] ? never : [Eff] extends [Yieldable<infer _S, infer _A, infer E, infer _R>] ? E : never, [Eff] extends [never] ? never : [Eff] extends [Yieldable<infer _S, infer _A, infer _E, infer R>] ? R : never>, ...args: Args) => A, b: (_: A, ...args: Args) => B, c: (_: B, ...args: Args) => C, d: (_: C, ...args: Args) => D, e: (_: D, ...args: Args) => E, f: (_: E, ...args: Args) => F, g: (_: F, ...args: Args) => G, h: (_: G, ...args: Args) => H, i: (_: H, ...args: Args) => I, j: (_: I, ...args: Args) => J, k: (_: J, ...args: Args) => K, l: (_: K, ...args: Args) => L, m: (_: L, ...args: Args) => M, n: (_: M, ...args: Args) => N, o: (_: N, ...args: Args) => O, p: (_: O, ...args: Args) => P, q: (_: P, ...args: Args) => Q, r: (_: Q, ...args: Args) => R, s: (_: R, ...args: Args) => S): (this: Self, ...args: Args) => S; // overload 59
export declare const fn: <Self, Eff extends Yieldable<any, any, any, any>, AEff, Args extends Array<any>, A, B, C, D, E, F, G, H, I, J, K, L, M, N, O, P, Q, R, S>(options: { readonly self: Self; }, body: (this: Self, ...args: Args) => Generator<Eff, AEff, never> | (Eff & Effect<AEff, any, any>), a: (_: Effect<AEff, [Eff] extends [never] ? never : [Eff] extends [Yieldable<infer _S, infer _A, infer E, infer _R>] ? E : never, [Eff] extends [never] ? never : [Eff] extends [Yieldable<infer _S, infer _A, infer _E, infer R>] ? R : never>, ...args: Args) => A, b: (_: A, ...args: Args) => B, c: (_: B, ...args: Args) => C, d: (_: C, ...args: Args) => D, e: (_: D, ...args: Args) => E, f: (_: E, ...args: Args) => F, g: (_: F, ...args: Args) => G, h: (_: G, ...args: Args) => H, i: (_: H, ...args: Args) => I, j: (_: I, ...args: Args) => J, k: (_: J, ...args: Args) => K, l: (_: K, ...args: Args) => L, m: (_: L, ...args: Args) => M, n: (_: M, ...args: Args) => N, o: (_: N, ...args: Args) => O, p: (_: O, ...args: Args) => P, q: (_: P, ...args: Args) => Q, r: (_: Q, ...args: Args) => R, s: (_: R, ...args: Args) => S): (...args: Args) => S; // overload 60
export declare const fn: <Eff extends Yieldable<any, any, any, any>, AEff, Args extends Array<any>, A, B, C, D, E, F, G, H, I, J, K, L, M, N, O, P, Q, R, S, T>(body: (this: unassigned, ...args: Args) => Generator<Eff, AEff, never> | (Eff & Effect<AEff, any, any>), a: (_: Effect<AEff, [Eff] extends [never] ? never : [Eff] extends [Yieldable<infer _S, infer _A, infer E, infer _R>] ? E : never, [Eff] extends [never] ? never : [Eff] extends [Yieldable<infer _S, infer _A, infer _E, infer R>] ? R : never>, ...args: Args) => A, b: (_: A, ...args: Args) => B, c: (_: B, ...args: Args) => C, d: (_: C, ...args: Args) => D, e: (_: D, ...args: Args) => E, f: (_: E, ...args: Args) => F, g: (_: F, ...args: Args) => G, h: (_: G, ...args: Args) => H, i: (_: H, ...args: Args) => I, j: (_: I, ...args: Args) => J, k: (_: J, ...args: Args) => K, l: (_: K, ...args: Args) => L, m: (_: L, ...args: Args) => M, n: (_: M, ...args: Args) => N, o: (_: N, ...args: Args) => O, p: (_: O, ...args: Args) => P, q: (_: P, ...args: Args) => Q, r: (_: Q, ...args: Args) => R, s: (_: R, ...args: Args) => S, t: (_: S, ...args: Args) => T): (...args: Args) => T; // overload 61
export declare const fn: <Self, Eff extends Yieldable<any, any, any, any>, AEff, Args extends Array<any>, A, B, C, D, E, F, G, H, I, J, K, L, M, N, O, P, Q, R, S, T>(body: (this: Self, ...args: Args) => Generator<Eff, AEff, never> | (Eff & Effect<AEff, any, any>), a: (_: Effect<AEff, [Eff] extends [never] ? never : [Eff] extends [Yieldable<infer _S, infer _A, infer E, infer _R>] ? E : never, [Eff] extends [never] ? never : [Eff] extends [Yieldable<infer _S, infer _A, infer _E, infer R>] ? R : never>, ...args: Args) => A, b: (_: A, ...args: Args) => B, c: (_: B, ...args: Args) => C, d: (_: C, ...args: Args) => D, e: (_: D, ...args: Args) => E, f: (_: E, ...args: Args) => F, g: (_: F, ...args: Args) => G, h: (_: G, ...args: Args) => H, i: (_: H, ...args: Args) => I, j: (_: I, ...args: Args) => J, k: (_: J, ...args: Args) => K, l: (_: K, ...args: Args) => L, m: (_: L, ...args: Args) => M, n: (_: M, ...args: Args) => N, o: (_: N, ...args: Args) => O, p: (_: O, ...args: Args) => P, q: (_: P, ...args: Args) => Q, r: (_: Q, ...args: Args) => R, s: (_: R, ...args: Args) => S, t: (_: S, ...args: Args) => T): (this: Self, ...args: Args) => T; // overload 62
export declare const fn: <Self, Eff extends Yieldable<any, any, any, any>, AEff, Args extends Array<any>, A, B, C, D, E, F, G, H, I, J, K, L, M, N, O, P, Q, R, S, T>(options: { readonly self: Self; }, body: (this: Self, ...args: Args) => Generator<Eff, AEff, never> | (Eff & Effect<AEff, any, any>), a: (_: Effect<AEff, [Eff] extends [never] ? never : [Eff] extends [Yieldable<infer _S, infer _A, infer E, infer _R>] ? E : never, [Eff] extends [never] ? never : [Eff] extends [Yieldable<infer _S, infer _A, infer _E, infer R>] ? R : never>, ...args: Args) => A, b: (_: A, ...args: Args) => B, c: (_: B, ...args: Args) => C, d: (_: C, ...args: Args) => D, e: (_: D, ...args: Args) => E, f: (_: E, ...args: Args) => F, g: (_: F, ...args: Args) => G, h: (_: G, ...args: Args) => H, i: (_: H, ...args: Args) => I, j: (_: I, ...args: Args) => J, k: (_: J, ...args: Args) => K, l: (_: K, ...args: Args) => L, m: (_: L, ...args: Args) => M, n: (_: M, ...args: Args) => N, o: (_: N, ...args: Args) => O, p: (_: O, ...args: Args) => P, q: (_: P, ...args: Args) => Q, r: (_: Q, ...args: Args) => R, s: (_: R, ...args: Args) => S, t: (_: S, ...args: Args) => T): (...args: Args) => T; // overload 63
export declare const fn: (name: string, options?: SpanOptionsNoTrace): fn.Traced; // overload 64
export declare const fnUntraced: <Eff extends Yieldable<any, any, any, any>, AEff, Args extends Array<any>>(body: (this: unassigned, ...args: Args) => Generator<Eff, AEff, never>): (...args: Args) => Effect<AEff, [Eff] extends [never] ? never : [Eff] extends [Yieldable<infer _S, infer _A, infer E, infer _R>] ? E : never, [Eff] extends [never] ? never : [Eff] extends [Yieldable<infer _S, infer _A, infer _E, infer R>] ? R : never>; // overload 1
export declare const fnUntraced: <Self, Eff extends Yieldable<any, any, any, any>, AEff, Args extends Array<any>>(body: (this: Self, ...args: Args) => Generator<Eff, AEff, never>): (this: Self, ...args: Args) => Effect<AEff, [Eff] extends [never] ? never : [Eff] extends [Yieldable<infer _S, infer _A, infer E, infer _R>] ? E : never, [Eff] extends [never] ? never : [Eff] extends [Yieldable<infer _S, infer _A, infer _E, infer R>] ? R : never>; // overload 2
export declare const fnUntraced: <Eff extends Yieldable<any, any, any, any>, AEff, Args extends Array<any>, A>(body: (this: unassigned, ...args: Args) => Generator<Eff, AEff, never>, a: (_: Effect<AEff, [Eff] extends [never] ? never : [Eff] extends [Yieldable<infer _S, infer _A, infer E, infer _R>] ? E : never, [Eff] extends [never] ? never : [Eff] extends [Yieldable<infer _S, infer _A, infer _E, infer R>] ? R : never>, ...args: Args) => A): (...args: Args) => A; // overload 3
export declare const fnUntraced: <Self, Eff extends Yieldable<any, any, any, any>, AEff, Args extends Array<any>, A>(body: (this: Self, ...args: Args) => Generator<Eff, AEff, never>, a: (_: Effect<AEff, [Eff] extends [never] ? never : [Eff] extends [Yieldable<infer _S, infer _A, infer E, infer _R>] ? E : never, [Eff] extends [never] ? never : [Eff] extends [Yieldable<infer _S, infer _A, infer _E, infer R>] ? R : never>, ...args: Args) => A): (this: Self, ...args: Args) => A; // overload 4
export declare const fnUntraced: <Eff extends Yieldable<any, any, any, any>, AEff, Args extends Array<any>, A, B>(body: (this: unassigned, ...args: Args) => Generator<Eff, AEff, never>, a: (_: Effect<AEff, [Eff] extends [never] ? never : [Eff] extends [Yieldable<infer _S, infer _A, infer E, infer _R>] ? E : never, [Eff] extends [never] ? never : [Eff] extends [Yieldable<infer _S, infer _A, infer _E, infer R>] ? R : never>, ...args: Args) => A, b: (_: A, ...args: Args) => B): (...args: Args) => B; // overload 5
export declare const fnUntraced: <Self, Eff extends Yieldable<any, any, any, any>, AEff, Args extends Array<any>, A, B>(body: (this: Self, ...args: Args) => Generator<Eff, AEff, never>, a: (_: Effect<AEff, [Eff] extends [never] ? never : [Eff] extends [Yieldable<infer _S, infer _A, infer E, infer _R>] ? E : never, [Eff] extends [never] ? never : [Eff] extends [Yieldable<infer _S, infer _A, infer _E, infer R>] ? R : never>, ...args: Args) => A, b: (_: A, ...args: Args) => B): (this: Self, ...args: Args) => B; // overload 6
export declare const fnUntraced: <Eff extends Yieldable<any, any, any, any>, AEff, Args extends Array<any>, A, B, C>(body: (this: unassigned, ...args: Args) => Generator<Eff, AEff, never>, a: (_: Effect<AEff, [Eff] extends [never] ? never : [Eff] extends [Yieldable<infer _S, infer _A, infer E, infer _R>] ? E : never, [Eff] extends [never] ? never : [Eff] extends [Yieldable<infer _S, infer _A, infer _E, infer R>] ? R : never>, ...args: Args) => A, b: (_: A, ...args: Args) => B, c: (_: B, ...args: Args) => C): (...args: Args) => C; // overload 7
export declare const fnUntraced: <Self, Eff extends Yieldable<any, any, any, any>, AEff, Args extends Array<any>, A, B, C>(body: (this: Self, ...args: Args) => Generator<Eff, AEff, never>, a: (_: Effect<AEff, [Eff] extends [never] ? never : [Eff] extends [Yieldable<infer _S, infer _A, infer E, infer _R>] ? E : never, [Eff] extends [never] ? never : [Eff] extends [Yieldable<infer _S, infer _A, infer _E, infer R>] ? R : never>, ...args: Args) => A, b: (_: A, ...args: Args) => B, c: (_: B, ...args: Args) => C): (this: Self, ...args: Args) => C; // overload 8
export declare const fnUntraced: <Eff extends Yieldable<any, any, any, any>, AEff, Args extends Array<any>, A, B, C, D>(body: (...args: Args) => Generator<Eff, AEff, never>, a: (_: Effect<AEff, [Eff] extends [never] ? never : [Eff] extends [Yieldable<infer _S, infer _A, infer E, infer _R>] ? E : never, [Eff] extends [never] ? never : [Eff] extends [Yieldable<infer _S, infer _A, infer _E, infer R>] ? R : never>, ...args: Args) => A, b: (_: A, ...args: Args) => B, c: (_: B, ...args: Args) => C, d: (_: C, ...args: Args) => D): (...args: Args) => D; // overload 9
export declare const fnUntraced: <Self, Eff extends Yieldable<any, any, any, any>, AEff, Args extends Array<any>, A, B, C, D>(body: (this: Self, ...args: Args) => Generator<Eff, AEff, never>, a: (_: Effect<AEff, [Eff] extends [never] ? never : [Eff] extends [Yieldable<infer _S, infer _A, infer E, infer _R>] ? E : never, [Eff] extends [never] ? never : [Eff] extends [Yieldable<infer _S, infer _A, infer _E, infer R>] ? R : never>, ...args: Args) => A, b: (_: A, ...args: Args) => B, c: (_: B, ...args: Args) => C, d: (_: C, ...args: Args) => D): (this: Self, ...args: Args) => D; // overload 10
export declare const fnUntraced: <Eff extends Yieldable<any, any, any, any>, AEff, Args extends Array<any>, A, B, C, D, E>(body: (this: unassigned, ...args: Args) => Generator<Eff, AEff, never>, a: (_: Effect<AEff, [Eff] extends [never] ? never : [Eff] extends [Yieldable<infer _S, infer _A, infer E, infer _R>] ? E : never, [Eff] extends [never] ? never : [Eff] extends [Yieldable<infer _S, infer _A, infer _E, infer R>] ? R : never>, ...args: Args) => A, b: (_: A, ...args: Args) => B, c: (_: B, ...args: Args) => C, d: (_: C, ...args: Args) => D, e: (_: D, ...args: Args) => E): (...args: Args) => E; // overload 11
export declare const fnUntraced: <Self, Eff extends Yieldable<any, any, any, any>, AEff, Args extends Array<any>, A, B, C, D, E>(body: (this: Self, ...args: Args) => Generator<Eff, AEff, never>, a: (_: Effect<AEff, [Eff] extends [never] ? never : [Eff] extends [Yieldable<infer _S, infer _A, infer E, infer _R>] ? E : never, [Eff] extends [never] ? never : [Eff] extends [Yieldable<infer _S, infer _A, infer _E, infer R>] ? R : never>, ...args: Args) => A, b: (_: A, ...args: Args) => B, c: (_: B, ...args: Args) => C, d: (_: C, ...args: Args) => D, e: (_: D, ...args: Args) => E): (this: Self, ...args: Args) => E; // overload 12
export declare const fnUntraced: <Eff extends Yieldable<any, any, any, any>, AEff, Args extends Array<any>, A, B, C, D, E, F>(body: (this: unassigned, ...args: Args) => Generator<Eff, AEff, never>, a: (_: Effect<AEff, [Eff] extends [never] ? never : [Eff] extends [Yieldable<infer _S, infer _A, infer E, infer _R>] ? E : never, [Eff] extends [never] ? never : [Eff] extends [Yieldable<infer _S, infer _A, infer _E, infer R>] ? R : never>, ...args: Args) => A, b: (_: A, ...args: Args) => B, c: (_: B, ...args: Args) => C, d: (_: C, ...args: Args) => D, e: (_: D, ...args: Args) => E, f: (_: E, ...args: Args) => F): (...args: Args) => F; // overload 13
export declare const fnUntraced: <Self, Eff extends Yieldable<any, any, any, any>, AEff, Args extends Array<any>, A, B, C, D, E, F>(body: (this: Self, ...args: Args) => Generator<Eff, AEff, never>, a: (_: Effect<AEff, [Eff] extends [never] ? never : [Eff] extends [Yieldable<infer _S, infer _A, infer E, infer _R>] ? E : never, [Eff] extends [never] ? never : [Eff] extends [Yieldable<infer _S, infer _A, infer _E, infer R>] ? R : never>, ...args: Args) => A, b: (_: A, ...args: Args) => B, c: (_: B, ...args: Args) => C, d: (_: C, ...args: Args) => D, e: (_: D, ...args: Args) => E, f: (_: E, ...args: Args) => F): (this: Self, ...args: Args) => F; // overload 14
export declare const fnUntraced: <Eff extends Yieldable<any, any, any, any>, AEff, Args extends Array<any>, A, B, C, D, E, F, G>(body: (this: unassigned, ...args: Args) => Generator<Eff, AEff, never>, a: (_: Effect<AEff, [Eff] extends [never] ? never : [Eff] extends [Yieldable<infer _S, infer _A, infer E, infer _R>] ? E : never, [Eff] extends [never] ? never : [Eff] extends [Yieldable<infer _S, infer _A, infer _E, infer R>] ? R : never>, ...args: Args) => A, b: (_: A, ...args: Args) => B, c: (_: B, ...args: Args) => C, d: (_: C, ...args: Args) => D, e: (_: D, ...args: Args) => E, f: (_: E, ...args: Args) => F, g: (_: F, ...args: Args) => G): (...args: Args) => G; // overload 15
export declare const fnUntraced: <Self, Eff extends Yieldable<any, any, any, any>, AEff, Args extends Array<any>, A, B, C, D, E, F, G>(body: (this: Self, ...args: Args) => Generator<Eff, AEff, never>, a: (_: Effect<AEff, [Eff] extends [never] ? never : [Eff] extends [Yieldable<infer _S, infer _A, infer E, infer _R>] ? E : never, [Eff] extends [never] ? never : [Eff] extends [Yieldable<infer _S, infer _A, infer _E, infer R>] ? R : never>, ...args: Args) => A, b: (_: A, ...args: Args) => B, c: (_: B, ...args: Args) => C, d: (_: C, ...args: Args) => D, e: (_: D, ...args: Args) => E, f: (_: E, ...args: Args) => F, g: (_: F, ...args: Args) => G): (this: Self, ...args: Args) => G; // overload 16
export declare const fnUntraced: <Eff extends Yieldable<any, any, any, any>, AEff, Args extends Array<any>, A, B, C, D, E, F, G, H>(body: (this: unassigned, ...args: Args) => Generator<Eff, AEff, never>, a: (_: Effect<AEff, [Eff] extends [never] ? never : [Eff] extends [Yieldable<infer _S, infer _A, infer E, infer _R>] ? E : never, [Eff] extends [never] ? never : [Eff] extends [Yieldable<infer _S, infer _A, infer _E, infer R>] ? R : never>, ...args: Args) => A, b: (_: A, ...args: Args) => B, c: (_: B, ...args: Args) => C, d: (_: C, ...args: Args) => D, e: (_: D, ...args: Args) => E, f: (_: E, ...args: Args) => F, g: (_: F, ...args: Args) => G, h: (_: G, ...args: Args) => H): (...args: Args) => H; // overload 17
export declare const fnUntraced: <Self, Eff extends Yieldable<any, any, any, any>, AEff, Args extends Array<any>, A, B, C, D, E, F, G, H>(body: (this: Self, ...args: Args) => Generator<Eff, AEff, never>, a: (_: Effect<AEff, [Eff] extends [never] ? never : [Eff] extends [Yieldable<infer _S, infer _A, infer E, infer _R>] ? E : never, [Eff] extends [never] ? never : [Eff] extends [Yieldable<infer _S, infer _A, infer _E, infer R>] ? R : never>, ...args: Args) => A, b: (_: A, ...args: Args) => B, c: (_: B, ...args: Args) => C, d: (_: C, ...args: Args) => D, e: (_: D, ...args: Args) => E, f: (_: E, ...args: Args) => F, g: (_: F, ...args: Args) => G, h: (_: G, ...args: Args) => H): (this: Self, ...args: Args) => H; // overload 18
export declare const fnUntraced: <Eff extends Yieldable<any, any, any, any>, AEff, Args extends Array<any>, A, B, C, D, E, F, G, H, I>(body: (this: unassigned, ...args: Args) => Generator<Eff, AEff, never>, a: (_: Effect<AEff, [Eff] extends [never] ? never : [Eff] extends [Yieldable<infer _S, infer _A, infer E, infer _R>] ? E : never, [Eff] extends [never] ? never : [Eff] extends [Yieldable<infer _S, infer _A, infer _E, infer R>] ? R : never>, ...args: Args) => A, b: (_: A, ...args: Args) => B, c: (_: B, ...args: Args) => C, d: (_: C, ...args: Args) => D, e: (_: D, ...args: Args) => E, f: (_: E, ...args: Args) => F, g: (_: F, ...args: Args) => G, h: (_: G, ...args: Args) => H, i: (_: H, ...args: Args) => I): (...args: Args) => I; // overload 19
export declare const fnUntraced: <Self, Eff extends Yieldable<any, any, any, any>, AEff, Args extends Array<any>, A, B, C, D, E, F, G, H, I>(body: (this: Self, ...args: Args) => Generator<Eff, AEff, never>, a: (_: Effect<AEff, [Eff] extends [never] ? never : [Eff] extends [Yieldable<infer _S, infer _A, infer E, infer _R>] ? E : never, [Eff] extends [never] ? never : [Eff] extends [Yieldable<infer _S, infer _A, infer _E, infer R>] ? R : never>, ...args: Args) => A, b: (_: A, ...args: Args) => B, c: (_: B, ...args: Args) => C, d: (_: C, ...args: Args) => D, e: (_: D, ...args: Args) => E, f: (_: E, ...args: Args) => F, g: (_: F, ...args: Args) => G, h: (_: G, ...args: Args) => H, i: (_: H, ...args: Args) => I): (this: Self, ...args: Args) => I; // overload 20
export declare const fnUntraced: <Eff extends Yieldable<any, any, any, any>, AEff, Args extends Array<any>, A, B, C, D, E, F, G, H, I, J>(body: (this: unassigned, ...args: Args) => Generator<Eff, AEff, never>, a: (_: Effect<AEff, [Eff] extends [never] ? never : [Eff] extends [Yieldable<infer _S, infer _A, infer E, infer _R>] ? E : never, [Eff] extends [never] ? never : [Eff] extends [Yieldable<infer _S, infer _A, infer _E, infer R>] ? R : never>, ...args: Args) => A, b: (_: A, ...args: Args) => B, c: (_: B, ...args: Args) => C, d: (_: C, ...args: Args) => D, e: (_: D, ...args: Args) => E, f: (_: E, ...args: Args) => F, g: (_: F, ...args: Args) => G, h: (_: G, ...args: Args) => H, i: (_: H, ...args: Args) => I, j: (_: I, ...args: Args) => J): (...args: Args) => J; // overload 21
export declare const fnUntraced: <Self, Eff extends Yieldable<any, any, any, any>, AEff, Args extends Array<any>, A, B, C, D, E, F, G, H, I, J>(body: (this: Self, ...args: Args) => Generator<Eff, AEff, never>, a: (_: Effect<AEff, [Eff] extends [never] ? never : [Eff] extends [Yieldable<infer _S, infer _A, infer E, infer _R>] ? E : never, [Eff] extends [never] ? never : [Eff] extends [Yieldable<infer _S, infer _A, infer _E, infer R>] ? R : never>, ...args: Args) => A, b: (_: A, ...args: Args) => B, c: (_: B, ...args: Args) => C, d: (_: C, ...args: Args) => D, e: (_: D, ...args: Args) => E, f: (_: E, ...args: Args) => F, g: (_: F, ...args: Args) => G, h: (_: G, ...args: Args) => H, i: (_: H, ...args: Args) => I, j: (_: I, ...args: Args) => J): (this: Self, ...args: Args) => J; // overload 22
export declare const fnUntraced: <Eff extends Yieldable<any, any, any, any>, AEff, Args extends Array<any>, A, B, C, D, E, F, G, H, I, J, K>(body: (this: unassigned, ...args: Args) => Generator<Eff, AEff, never>, a: (_: Effect<AEff, [Eff] extends [never] ? never : [Eff] extends [Yieldable<infer _S, infer _A, infer E, infer _R>] ? E : never, [Eff] extends [never] ? never : [Eff] extends [Yieldable<infer _S, infer _A, infer _E, infer R>] ? R : never>, ...args: Args) => A, b: (_: A, ...args: Args) => B, c: (_: B, ...args: Args) => C, d: (_: C, ...args: Args) => D, e: (_: D, ...args: Args) => E, f: (_: E, ...args: Args) => F, g: (_: F, ...args: Args) => G, h: (_: G, ...args: Args) => H, i: (_: H, ...args: Args) => I, j: (_: I, ...args: Args) => J, k: (_: J, ...args: Args) => K): (...args: Args) => K; // overload 23
export declare const fnUntraced: <Self, Eff extends Yieldable<any, any, any, any>, AEff, Args extends Array<any>, A, B, C, D, E, F, G, H, I, J, K>(body: (this: Self, ...args: Args) => Generator<Eff, AEff, never>, a: (_: Effect<AEff, [Eff] extends [never] ? never : [Eff] extends [Yieldable<infer _S, infer _A, infer E, infer _R>] ? E : never, [Eff] extends [never] ? never : [Eff] extends [Yieldable<infer _S, infer _A, infer _E, infer R>] ? R : never>, ...args: Args) => A, b: (_: A, ...args: Args) => B, c: (_: B, ...args: Args) => C, d: (_: C, ...args: Args) => D, e: (_: D, ...args: Args) => E, f: (_: E, ...args: Args) => F, g: (_: F, ...args: Args) => G, h: (_: G, ...args: Args) => H, i: (_: H, ...args: Args) => I, j: (_: I, ...args: Args) => J, k: (_: J, ...args: Args) => K): (this: Self, ...args: Args) => K; // overload 24
export declare const fnUntraced: <Eff extends Yieldable<any, any, any, any>, AEff, Args extends Array<any>, A, B, C, D, E, F, G, H, I, J, K, L>(body: (this: unassigned, ...args: Args) => Generator<Eff, AEff, never>, a: (_: Effect<AEff, [Eff] extends [never] ? never : [Eff] extends [Yieldable<infer _S, infer _A, infer E, infer _R>] ? E : never, [Eff] extends [never] ? never : [Eff] extends [Yieldable<infer _S, infer _A, infer _E, infer R>] ? R : never>, ...args: Args) => A, b: (_: A, ...args: Args) => B, c: (_: B, ...args: Args) => C, d: (_: C, ...args: Args) => D, e: (_: D, ...args: Args) => E, f: (_: E, ...args: Args) => F, g: (_: F, ...args: Args) => G, h: (_: G, ...args: Args) => H, i: (_: H, ...args: Args) => I, j: (_: I, ...args: Args) => J, k: (_: J, ...args: Args) => K, l: (_: K, ...args: Args) => L): (...args: Args) => L; // overload 25
export declare const fnUntraced: <Self, Eff extends Yieldable<any, any, any, any>, AEff, Args extends Array<any>, A, B, C, D, E, F, G, H, I, J, K, L>(body: (this: Self, ...args: Args) => Generator<Eff, AEff, never>, a: (_: Effect<AEff, [Eff] extends [never] ? never : [Eff] extends [Yieldable<infer _S, infer _A, infer E, infer _R>] ? E : never, [Eff] extends [never] ? never : [Eff] extends [Yieldable<infer _S, infer _A, infer _E, infer R>] ? R : never>, ...args: Args) => A, b: (_: A, ...args: Args) => B, c: (_: B, ...args: Args) => C, d: (_: C, ...args: Args) => D, e: (_: D, ...args: Args) => E, f: (_: E, ...args: Args) => F, g: (_: F, ...args: Args) => G, h: (_: G, ...args: Args) => H, i: (_: H, ...args: Args) => I, j: (_: I, ...args: Args) => J, k: (_: J, ...args: Args) => K, l: (_: K, ...args: Args) => L): (this: Self, ...args: Args) => L; // overload 26
export declare const fnUntraced: <Eff extends Yieldable<any, any, any, any>, AEff, Args extends Array<any>, A, B, C, D, E, F, G, H, I, J, K, L, M>(body: (this: unassigned, ...args: Args) => Generator<Eff, AEff, never>, a: (_: Effect<AEff, [Eff] extends [never] ? never : [Eff] extends [Yieldable<infer _S, infer _A, infer E, infer _R>] ? E : never, [Eff] extends [never] ? never : [Eff] extends [Yieldable<infer _S, infer _A, infer _E, infer R>] ? R : never>, ...args: Args) => A, b: (_: A, ...args: Args) => B, c: (_: B, ...args: Args) => C, d: (_: C, ...args: Args) => D, e: (_: D, ...args: Args) => E, f: (_: E, ...args: Args) => F, g: (_: F, ...args: Args) => G, h: (_: G, ...args: Args) => H, i: (_: H, ...args: Args) => I, j: (_: I, ...args: Args) => J, k: (_: J, ...args: Args) => K, l: (_: K, ...args: Args) => L, m: (_: L, ...args: Args) => M): (...args: Args) => M; // overload 27
export declare const fnUntraced: <Self, Eff extends Yieldable<any, any, any, any>, AEff, Args extends Array<any>, A, B, C, D, E, F, G, H, I, J, K, L, M>(body: (this: Self, ...args: Args) => Generator<Eff, AEff, never>, a: (_: Effect<AEff, [Eff] extends [never] ? never : [Eff] extends [Yieldable<infer _S, infer _A, infer E, infer _R>] ? E : never, [Eff] extends [never] ? never : [Eff] extends [Yieldable<infer _S, infer _A, infer _E, infer R>] ? R : never>, ...args: Args) => A, b: (_: A, ...args: Args) => B, c: (_: B, ...args: Args) => C, d: (_: C, ...args: Args) => D, e: (_: D, ...args: Args) => E, f: (_: E, ...args: Args) => F, g: (_: F, ...args: Args) => G, h: (_: G, ...args: Args) => H, i: (_: H, ...args: Args) => I, j: (_: I, ...args: Args) => J, k: (_: J, ...args: Args) => K, l: (_: K, ...args: Args) => L, m: (_: L, ...args: Args) => M): (this: Self, ...args: Args) => M; // overload 28
export declare const fnUntraced: <Eff extends Yieldable<any, any, any, any>, AEff, Args extends Array<any>, A, B, C, D, E, F, G, H, I, J, K, L, M, N>(body: (this: unassigned, ...args: Args) => Generator<Eff, AEff, never>, a: (_: Effect<AEff, [Eff] extends [never] ? never : [Eff] extends [Yieldable<infer _S, infer _A, infer E, infer _R>] ? E : never, [Eff] extends [never] ? never : [Eff] extends [Yieldable<infer _S, infer _A, infer _E, infer R>] ? R : never>, ...args: Args) => A, b: (_: A, ...args: Args) => B, c: (_: B, ...args: Args) => C, d: (_: C, ...args: Args) => D, e: (_: D, ...args: Args) => E, f: (_: E, ...args: Args) => F, g: (_: F, ...args: Args) => G, h: (_: G, ...args: Args) => H, i: (_: H, ...args: Args) => I, j: (_: I, ...args: Args) => J, k: (_: J, ...args: Args) => K, l: (_: K, ...args: Args) => L, m: (_: L, ...args: Args) => M, n: (_: M, ...args: Args) => N): (...args: Args) => N; // overload 29
export declare const fnUntraced: <Self, Eff extends Yieldable<any, any, any, any>, AEff, Args extends Array<any>, A, B, C, D, E, F, G, H, I, J, K, L, M, N>(body: (this: Self, ...args: Args) => Generator<Eff, AEff, never>, a: (_: Effect<AEff, [Eff] extends [never] ? never : [Eff] extends [Yieldable<infer _S, infer _A, infer E, infer _R>] ? E : never, [Eff] extends [never] ? never : [Eff] extends [Yieldable<infer _S, infer _A, infer _E, infer R>] ? R : never>, ...args: Args) => A, b: (_: A, ...args: Args) => B, c: (_: B, ...args: Args) => C, d: (_: C, ...args: Args) => D, e: (_: D, ...args: Args) => E, f: (_: E, ...args: Args) => F, g: (_: F, ...args: Args) => G, h: (_: G, ...args: Args) => H, i: (_: H, ...args: Args) => I, j: (_: I, ...args: Args) => J, k: (_: J, ...args: Args) => K, l: (_: K, ...args: Args) => L, m: (_: L, ...args: Args) => M, n: (_: M, ...args: Args) => N): (this: Self, ...args: Args) => N; // overload 30
export declare const fnUntraced: <Eff extends Yieldable<any, any, any, any>, AEff, Args extends Array<any>, A, B, C, D, E, F, G, H, I, J, K, L, M, N, O>(body: (this: unassigned, ...args: Args) => Generator<Eff, AEff, never>, a: (_: Effect<AEff, [Eff] extends [never] ? never : [Eff] extends [Yieldable<infer _S, infer _A, infer E, infer _R>] ? E : never, [Eff] extends [never] ? never : [Eff] extends [Yieldable<infer _S, infer _A, infer _E, infer R>] ? R : never>, ...args: Args) => A, b: (_: A, ...args: Args) => B, c: (_: B, ...args: Args) => C, d: (_: C, ...args: Args) => D, e: (_: D, ...args: Args) => E, f: (_: E, ...args: Args) => F, g: (_: F, ...args: Args) => G, h: (_: G, ...args: Args) => H, i: (_: H, ...args: Args) => I, j: (_: I, ...args: Args) => J, k: (_: J, ...args: Args) => K, l: (_: K, ...args: Args) => L, m: (_: L, ...args: Args) => M, n: (_: M, ...args: Args) => N, o: (_: N, ...args: Args) => O): (...args: Args) => O; // overload 31
export declare const fnUntraced: <Self, Eff extends Yieldable<any, any, any, any>, AEff, Args extends Array<any>, A, B, C, D, E, F, G, H, I, J, K, L, M, N, O>(body: (this: Self, ...args: Args) => Generator<Eff, AEff, never>, a: (_: Effect<AEff, [Eff] extends [never] ? never : [Eff] extends [Yieldable<infer _S, infer _A, infer E, infer _R>] ? E : never, [Eff] extends [never] ? never : [Eff] extends [Yieldable<infer _S, infer _A, infer _E, infer R>] ? R : never>, ...args: Args) => A, b: (_: A, ...args: Args) => B, c: (_: B, ...args: Args) => C, d: (_: C, ...args: Args) => D, e: (_: D, ...args: Args) => E, f: (_: E, ...args: Args) => F, g: (_: F, ...args: Args) => G, h: (_: G, ...args: Args) => H, i: (_: H, ...args: Args) => I, j: (_: I, ...args: Args) => J, k: (_: J, ...args: Args) => K, l: (_: K, ...args: Args) => L, m: (_: L, ...args: Args) => M, n: (_: M, ...args: Args) => N, o: (_: N, ...args: Args) => O): (this: Self, ...args: Args) => O; // overload 32
export declare const fnUntraced: <Eff extends Yieldable<any, any, any, any>, AEff, Args extends Array<any>, A, B, C, D, E, F, G, H, I, J, K, L, M, N, O, P>(body: (this: unassigned, ...args: Args) => Generator<Eff, AEff, never>, a: (_: Effect<AEff, [Eff] extends [never] ? never : [Eff] extends [Yieldable<infer _S, infer _A, infer E, infer _R>] ? E : never, [Eff] extends [never] ? never : [Eff] extends [Yieldable<infer _S, infer _A, infer _E, infer R>] ? R : never>, ...args: Args) => A, b: (_: A, ...args: Args) => B, c: (_: B, ...args: Args) => C, d: (_: C, ...args: Args) => D, e: (_: D, ...args: Args) => E, f: (_: E, ...args: Args) => F, g: (_: F, ...args: Args) => G, h: (_: G, ...args: Args) => H, i: (_: H, ...args: Args) => I, j: (_: I, ...args: Args) => J, k: (_: J, ...args: Args) => K, l: (_: K, ...args: Args) => L, m: (_: L, ...args: Args) => M, n: (_: M, ...args: Args) => N, o: (_: N, ...args: Args) => O, p: (_: O, ...args: Args) => P): (...args: Args) => P; // overload 33
export declare const fnUntraced: <Self, Eff extends Yieldable<any, any, any, any>, AEff, Args extends Array<any>, A, B, C, D, E, F, G, H, I, J, K, L, M, N, O, P>(body: (this: Self, ...args: Args) => Generator<Eff, AEff, never>, a: (_: Effect<AEff, [Eff] extends [never] ? never : [Eff] extends [Yieldable<infer _S, infer _A, infer E, infer _R>] ? E : never, [Eff] extends [never] ? never : [Eff] extends [Yieldable<infer _S, infer _A, infer _E, infer R>] ? R : never>, ...args: Args) => A, b: (_: A, ...args: Args) => B, c: (_: B, ...args: Args) => C, d: (_: C, ...args: Args) => D, e: (_: D, ...args: Args) => E, f: (_: E, ...args: Args) => F, g: (_: F, ...args: Args) => G, h: (_: G, ...args: Args) => H, i: (_: H, ...args: Args) => I, j: (_: I, ...args: Args) => J, k: (_: J, ...args: Args) => K, l: (_: K, ...args: Args) => L, m: (_: L, ...args: Args) => M, n: (_: M, ...args: Args) => N, o: (_: N, ...args: Args) => O, p: (_: O, ...args: Args) => P): (this: Self, ...args: Args) => P; // overload 34
export declare const fnUntraced: <Eff extends Yieldable<any, any, any, any>, AEff, Args extends Array<any>, A, B, C, D, E, F, G, H, I, J, K, L, M, N, O, P, Q>(body: (this: unassigned, ...args: Args) => Generator<Eff, AEff, never>, a: (_: Effect<AEff, [Eff] extends [never] ? never : [Eff] extends [Yieldable<infer _S, infer _A, infer E, infer _R>] ? E : never, [Eff] extends [never] ? never : [Eff] extends [Yieldable<infer _S, infer _A, infer _E, infer R>] ? R : never>, ...args: Args) => A, b: (_: A, ...args: Args) => B, c: (_: B, ...args: Args) => C, d: (_: C, ...args: Args) => D, e: (_: D, ...args: Args) => E, f: (_: E, ...args: Args) => F, g: (_: F, ...args: Args) => G, h: (_: G, ...args: Args) => H, i: (_: H, ...args: Args) => I, j: (_: I, ...args: Args) => J, k: (_: J, ...args: Args) => K, l: (_: K, ...args: Args) => L, m: (_: L, ...args: Args) => M, n: (_: M, ...args: Args) => N, o: (_: N, ...args: Args) => O, p: (_: O, ...args: Args) => P, q: (_: P, ...args: Args) => Q): (...args: Args) => Q; // overload 35
export declare const fnUntraced: <Self, Eff extends Yieldable<any, any, any, any>, AEff, Args extends Array<any>, A, B, C, D, E, F, G, H, I, J, K, L, M, N, O, P, Q>(body: (this: Self, ...args: Args) => Generator<Eff, AEff, never>, a: (_: Effect<AEff, [Eff] extends [never] ? never : [Eff] extends [Yieldable<infer _S, infer _A, infer E, infer _R>] ? E : never, [Eff] extends [never] ? never : [Eff] extends [Yieldable<infer _S, infer _A, infer _E, infer R>] ? R : never>, ...args: Args) => A, b: (_: A, ...args: Args) => B, c: (_: B, ...args: Args) => C, d: (_: C, ...args: Args) => D, e: (_: D, ...args: Args) => E, f: (_: E, ...args: Args) => F, g: (_: F, ...args: Args) => G, h: (_: G, ...args: Args) => H, i: (_: H, ...args: Args) => I, j: (_: I, ...args: Args) => J, k: (_: J, ...args: Args) => K, l: (_: K, ...args: Args) => L, m: (_: L, ...args: Args) => M, n: (_: M, ...args: Args) => N, o: (_: N, ...args: Args) => O, p: (_: O, ...args: Args) => P, q: (_: P, ...args: Args) => Q): (this: Self, ...args: Args) => Q; // overload 36
export declare const fnUntraced: <Eff extends Yieldable<any, any, any, any>, AEff, Args extends Array<any>, A, B, C, D, E, F, G, H, I, J, K, L, M, N, O, P, Q, R>(body: (this: unassigned, ...args: Args) => Generator<Eff, AEff, never>, a: (_: Effect<AEff, [Eff] extends [never] ? never : [Eff] extends [Yieldable<infer _S, infer _A, infer E, infer _R>] ? E : never, [Eff] extends [never] ? never : [Eff] extends [Yieldable<infer _S, infer _A, infer _E, infer R>] ? R : never>, ...args: Args) => A, b: (_: A, ...args: Args) => B, c: (_: B, ...args: Args) => C, d: (_: C, ...args: Args) => D, e: (_: D, ...args: Args) => E, f: (_: E, ...args: Args) => F, g: (_: F, ...args: Args) => G, h: (_: G, ...args: Args) => H, i: (_: H, ...args: Args) => I, j: (_: I, ...args: Args) => J, k: (_: J, ...args: Args) => K, l: (_: K, ...args: Args) => L, m: (_: L, ...args: Args) => M, n: (_: M, ...args: Args) => N, o: (_: N, ...args: Args) => O, p: (_: O, ...args: Args) => P, q: (_: P, ...args: Args) => Q, r: (_: Q, ...args: Args) => R): (...args: Args) => R; // overload 37
export declare const fnUntraced: <Self, Eff extends Yieldable<any, any, any, any>, AEff, Args extends Array<any>, A, B, C, D, E, F, G, H, I, J, K, L, M, N, O, P, Q, R>(body: (this: Self, ...args: Args) => Generator<Eff, AEff, never>, a: (_: Effect<AEff, [Eff] extends [never] ? never : [Eff] extends [Yieldable<infer _S, infer _A, infer E, infer _R>] ? E : never, [Eff] extends [never] ? never : [Eff] extends [Yieldable<infer _S, infer _A, infer _E, infer R>] ? R : never>, ...args: Args) => A, b: (_: A, ...args: Args) => B, c: (_: B, ...args: Args) => C, d: (_: C, ...args: Args) => D, e: (_: D, ...args: Args) => E, f: (_: E, ...args: Args) => F, g: (_: F, ...args: Args) => G, h: (_: G, ...args: Args) => H, i: (_: H, ...args: Args) => I, j: (_: I, ...args: Args) => J, k: (_: J, ...args: Args) => K, l: (_: K, ...args: Args) => L, m: (_: L, ...args: Args) => M, n: (_: M, ...args: Args) => N, o: (_: N, ...args: Args) => O, p: (_: O, ...args: Args) => P, q: (_: P, ...args: Args) => Q, r: (_: Q, ...args: Args) => R): (this: Self, ...args: Args) => R; // overload 38
export declare const fnUntraced: <Eff extends Yieldable<any, any, any, any>, AEff, Args extends Array<any>, A, B, C, D, E, F, G, H, I, J, K, L, M, N, O, P, Q, R, S>(body: (this: unassigned, ...args: Args) => Generator<Eff, AEff, never>, a: (_: Effect<AEff, [Eff] extends [never] ? never : [Eff] extends [Yieldable<infer _S, infer _A, infer E, infer _R>] ? E : never, [Eff] extends [never] ? never : [Eff] extends [Yieldable<infer _S, infer _A, infer _E, infer R>] ? R : never>, ...args: Args) => A, b: (_: A, ...args: Args) => B, c: (_: B, ...args: Args) => C, d: (_: C, ...args: Args) => D, e: (_: D, ...args: Args) => E, f: (_: E, ...args: Args) => F, g: (_: F, ...args: Args) => G, h: (_: G, ...args: Args) => H, i: (_: H, ...args: Args) => I, j: (_: I, ...args: Args) => J, k: (_: J, ...args: Args) => K, l: (_: K, ...args: Args) => L, m: (_: L, ...args: Args) => M, n: (_: M, ...args: Args) => N, o: (_: N, ...args: Args) => O, p: (_: O, ...args: Args) => P, q: (_: P, ...args: Args) => Q, r: (_: Q, ...args: Args) => R, s: (_: R, ...args: Args) => S): (...args: Args) => S; // overload 39
export declare const fnUntraced: <Self, Eff extends Yieldable<any, any, any, any>, AEff, Args extends Array<any>, A, B, C, D, E, F, G, H, I, J, K, L, M, N, O, P, Q, R, S>(body: (this: Self, ...args: Args) => Generator<Eff, AEff, never>, a: (_: Effect<AEff, [Eff] extends [never] ? never : [Eff] extends [Yieldable<infer _S, infer _A, infer E, infer _R>] ? E : never, [Eff] extends [never] ? never : [Eff] extends [Yieldable<infer _S, infer _A, infer _E, infer R>] ? R : never>, ...args: Args) => A, b: (_: A, ...args: Args) => B, c: (_: B, ...args: Args) => C, d: (_: C, ...args: Args) => D, e: (_: D, ...args: Args) => E, f: (_: E, ...args: Args) => F, g: (_: F, ...args: Args) => G, h: (_: G, ...args: Args) => H, i: (_: H, ...args: Args) => I, j: (_: I, ...args: Args) => J, k: (_: J, ...args: Args) => K, l: (_: K, ...args: Args) => L, m: (_: L, ...args: Args) => M, n: (_: M, ...args: Args) => N, o: (_: N, ...args: Args) => O, p: (_: O, ...args: Args) => P, q: (_: P, ...args: Args) => Q, r: (_: Q, ...args: Args) => R, s: (_: R, ...args: Args) => S): (this: Self, ...args: Args) => S; // overload 40
export declare const fnUntraced: <Eff extends Yieldable<any, any, any, any>, AEff, Args extends Array<any>, A, B, C, D, E, F, G, H, I, J, K, L, M, N, O, P, Q, R, S, T>(body: (this: unassigned, ...args: Args) => Generator<Eff, AEff, never>, a: (_: Effect<AEff, [Eff] extends [never] ? never : [Eff] extends [Yieldable<infer _S, infer _A, infer E, infer _R>] ? E : never, [Eff] extends [never] ? never : [Eff] extends [Yieldable<infer _S, infer _A, infer _E, infer R>] ? R : never>, ...args: Args) => A, b: (_: A, ...args: Args) => B, c: (_: B, ...args: Args) => C, d: (_: C, ...args: Args) => D, e: (_: D, ...args: Args) => E, f: (_: E, ...args: Args) => F, g: (_: F, ...args: Args) => G, h: (_: G, ...args: Args) => H, i: (_: H, ...args: Args) => I, j: (_: I, ...args: Args) => J, k: (_: J, ...args: Args) => K, l: (_: K, ...args: Args) => L, m: (_: L, ...args: Args) => M, n: (_: M, ...args: Args) => N, o: (_: N, ...args: Args) => O, p: (_: O, ...args: Args) => P, q: (_: P, ...args: Args) => Q, r: (_: Q, ...args: Args) => R, s: (_: R, ...args: Args) => S, t: (_: S, ...args: Args) => T): (...args: Args) => T; // overload 41
export declare const fnUntraced: <Self, Eff extends Yieldable<any, any, any, any>, AEff, Args extends Array<any>, A, B, C, D, E, F, G, H, I, J, K, L, M, N, O, P, Q, R, S, T>(body: (this: Self, ...args: Args) => Generator<Eff, AEff, never>, a: (_: Effect<AEff, [Eff] extends [never] ? never : [Eff] extends [Yieldable<infer _S, infer _A, infer E, infer _R>] ? E : never, [Eff] extends [never] ? never : [Eff] extends [Yieldable<infer _S, infer _A, infer _E, infer R>] ? R : never>, ...args: Args) => A, b: (_: A, ...args: Args) => B, c: (_: B, ...args: Args) => C, d: (_: C, ...args: Args) => D, e: (_: D, ...args: Args) => E, f: (_: E, ...args: Args) => F, g: (_: F, ...args: Args) => G, h: (_: G, ...args: Args) => H, i: (_: H, ...args: Args) => I, j: (_: I, ...args: Args) => J, k: (_: J, ...args: Args) => K, l: (_: K, ...args: Args) => L, m: (_: L, ...args: Args) => M, n: (_: M, ...args: Args) => N, o: (_: N, ...args: Args) => O, p: (_: O, ...args: Args) => P, q: (_: P, ...args: Args) => Q, r: (_: Q, ...args: Args) => R, s: (_: R, ...args: Args) => S, t: (_: S, ...args: Args) => T): (this: Self, ...args: Args) => T; // overload 42
export declare const fnUntracedEager: <Eff extends Yieldable<any, any, any, any>, AEff, Args extends Array<any>>(body: (this: unassigned, ...args: Args) => Generator<Eff, AEff, never>): (...args: Args) => Effect<AEff, [Eff] extends [never] ? never : [Eff] extends [Yieldable<infer _S, infer _A, infer E, infer _R>] ? E : never, [Eff] extends [never] ? never : [Eff] extends [Yieldable<infer _S, infer _A, infer _E, infer R>] ? R : never>; // overload 1
export declare const fnUntracedEager: <Self, Eff extends Yieldable<any, any, any, any>, AEff, Args extends Array<any>>(body: (this: Self, ...args: Args) => Generator<Eff, AEff, never>): (this: Self, ...args: Args) => Effect<AEff, [Eff] extends [never] ? never : [Eff] extends [Yieldable<infer _S, infer _A, infer E, infer _R>] ? E : never, [Eff] extends [never] ? never : [Eff] extends [Yieldable<infer _S, infer _A, infer _E, infer R>] ? R : never>; // overload 2
export declare const fnUntracedEager: <Eff extends Yieldable<any, any, any, any>, AEff, Args extends Array<any>, A>(body: (this: unassigned, ...args: Args) => Generator<Eff, AEff, never>, a: (_: Effect<AEff, [Eff] extends [never] ? never : [Eff] extends [Yieldable<infer _S, infer _A, infer E, infer _R>] ? E : never, [Eff] extends [never] ? never : [Eff] extends [Yieldable<infer _S, infer _A, infer _E, infer R>] ? R : never>, ...args: Args) => A): (...args: Args) => A; // overload 3
export declare const fnUntracedEager: <Self, Eff extends Yieldable<any, any, any, any>, AEff, Args extends Array<any>, A>(body: (this: Self, ...args: Args) => Generator<Eff, AEff, never>, a: (_: Effect<AEff, [Eff] extends [never] ? never : [Eff] extends [Yieldable<infer _S, infer _A, infer E, infer _R>] ? E : never, [Eff] extends [never] ? never : [Eff] extends [Yieldable<infer _S, infer _A, infer _E, infer R>] ? R : never>, ...args: Args) => A): (this: Self, ...args: Args) => A; // overload 4
export declare const fnUntracedEager: <Eff extends Yieldable<any, any, any, any>, AEff, Args extends Array<any>, A, B>(body: (this: unassigned, ...args: Args) => Generator<Eff, AEff, never>, a: (_: Effect<AEff, [Eff] extends [never] ? never : [Eff] extends [Yieldable<infer _S, infer _A, infer E, infer _R>] ? E : never, [Eff] extends [never] ? never : [Eff] extends [Yieldable<infer _S, infer _A, infer _E, infer R>] ? R : never>, ...args: Args) => A, b: (_: A, ...args: Args) => B): (...args: Args) => B; // overload 5
export declare const fnUntracedEager: <Self, Eff extends Yieldable<any, any, any, any>, AEff, Args extends Array<any>, A, B>(body: (this: Self, ...args: Args) => Generator<Eff, AEff, never>, a: (_: Effect<AEff, [Eff] extends [never] ? never : [Eff] extends [Yieldable<infer _S, infer _A, infer E, infer _R>] ? E : never, [Eff] extends [never] ? never : [Eff] extends [Yieldable<infer _S, infer _A, infer _E, infer R>] ? R : never>, ...args: Args) => A, b: (_: A, ...args: Args) => B): (this: Self, ...args: Args) => B; // overload 6
export declare const fnUntracedEager: <Eff extends Yieldable<any, any, any, any>, AEff, Args extends Array<any>, A, B, C>(body: (this: unassigned, ...args: Args) => Generator<Eff, AEff, never>, a: (_: Effect<AEff, [Eff] extends [never] ? never : [Eff] extends [Yieldable<infer _S, infer _A, infer E, infer _R>] ? E : never, [Eff] extends [never] ? never : [Eff] extends [Yieldable<infer _S, infer _A, infer _E, infer R>] ? R : never>, ...args: Args) => A, b: (_: A, ...args: Args) => B, c: (_: B, ...args: Args) => C): (...args: Args) => C; // overload 7
export declare const fnUntracedEager: <Self, Eff extends Yieldable<any, any, any, any>, AEff, Args extends Array<any>, A, B, C>(body: (this: Self, ...args: Args) => Generator<Eff, AEff, never>, a: (_: Effect<AEff, [Eff] extends [never] ? never : [Eff] extends [Yieldable<infer _S, infer _A, infer E, infer _R>] ? E : never, [Eff] extends [never] ? never : [Eff] extends [Yieldable<infer _S, infer _A, infer _E, infer R>] ? R : never>, ...args: Args) => A, b: (_: A, ...args: Args) => B, c: (_: B, ...args: Args) => C): (this: Self, ...args: Args) => C; // overload 8
export declare const fnUntracedEager: <Eff extends Yieldable<any, any, any, any>, AEff, Args extends Array<any>, A, B, C, D>(body: (...args: Args) => Generator<Eff, AEff, never>, a: (_: Effect<AEff, [Eff] extends [never] ? never : [Eff] extends [Yieldable<infer _S, infer _A, infer E, infer _R>] ? E : never, [Eff] extends [never] ? never : [Eff] extends [Yieldable<infer _S, infer _A, infer _E, infer R>] ? R : never>, ...args: Args) => A, b: (_: A, ...args: Args) => B, c: (_: B, ...args: Args) => C, d: (_: C, ...args: Args) => D): (...args: Args) => D; // overload 9
export declare const fnUntracedEager: <Self, Eff extends Yieldable<any, any, any, any>, AEff, Args extends Array<any>, A, B, C, D>(body: (this: Self, ...args: Args) => Generator<Eff, AEff, never>, a: (_: Effect<AEff, [Eff] extends [never] ? never : [Eff] extends [Yieldable<infer _S, infer _A, infer E, infer _R>] ? E : never, [Eff] extends [never] ? never : [Eff] extends [Yieldable<infer _S, infer _A, infer _E, infer R>] ? R : never>, ...args: Args) => A, b: (_: A, ...args: Args) => B, c: (_: B, ...args: Args) => C, d: (_: C, ...args: Args) => D): (this: Self, ...args: Args) => D; // overload 10
export declare const fnUntracedEager: <Eff extends Yieldable<any, any, any, any>, AEff, Args extends Array<any>, A, B, C, D, E>(body: (this: unassigned, ...args: Args) => Generator<Eff, AEff, never>, a: (_: Effect<AEff, [Eff] extends [never] ? never : [Eff] extends [Yieldable<infer _S, infer _A, infer E, infer _R>] ? E : never, [Eff] extends [never] ? never : [Eff] extends [Yieldable<infer _S, infer _A, infer _E, infer R>] ? R : never>, ...args: Args) => A, b: (_: A, ...args: Args) => B, c: (_: B, ...args: Args) => C, d: (_: C, ...args: Args) => D, e: (_: D, ...args: Args) => E): (...args: Args) => E; // overload 11
export declare const fnUntracedEager: <Self, Eff extends Yieldable<any, any, any, any>, AEff, Args extends Array<any>, A, B, C, D, E>(body: (this: Self, ...args: Args) => Generator<Eff, AEff, never>, a: (_: Effect<AEff, [Eff] extends [never] ? never : [Eff] extends [Yieldable<infer _S, infer _A, infer E, infer _R>] ? E : never, [Eff] extends [never] ? never : [Eff] extends [Yieldable<infer _S, infer _A, infer _E, infer R>] ? R : never>, ...args: Args) => A, b: (_: A, ...args: Args) => B, c: (_: B, ...args: Args) => C, d: (_: C, ...args: Args) => D, e: (_: D, ...args: Args) => E): (this: Self, ...args: Args) => E; // overload 12
export declare const fnUntracedEager: <Eff extends Yieldable<any, any, any, any>, AEff, Args extends Array<any>, A, B, C, D, E, F>(body: (this: unassigned, ...args: Args) => Generator<Eff, AEff, never>, a: (_: Effect<AEff, [Eff] extends [never] ? never : [Eff] extends [Yieldable<infer _S, infer _A, infer E, infer _R>] ? E : never, [Eff] extends [never] ? never : [Eff] extends [Yieldable<infer _S, infer _A, infer _E, infer R>] ? R : never>, ...args: Args) => A, b: (_: A, ...args: Args) => B, c: (_: B, ...args: Args) => C, d: (_: C, ...args: Args) => D, e: (_: D, ...args: Args) => E, f: (_: E, ...args: Args) => F): (...args: Args) => F; // overload 13
export declare const fnUntracedEager: <Self, Eff extends Yieldable<any, any, any, any>, AEff, Args extends Array<any>, A, B, C, D, E, F>(body: (this: Self, ...args: Args) => Generator<Eff, AEff, never>, a: (_: Effect<AEff, [Eff] extends [never] ? never : [Eff] extends [Yieldable<infer _S, infer _A, infer E, infer _R>] ? E : never, [Eff] extends [never] ? never : [Eff] extends [Yieldable<infer _S, infer _A, infer _E, infer R>] ? R : never>, ...args: Args) => A, b: (_: A, ...args: Args) => B, c: (_: B, ...args: Args) => C, d: (_: C, ...args: Args) => D, e: (_: D, ...args: Args) => E, f: (_: E, ...args: Args) => F): (this: Self, ...args: Args) => F; // overload 14
export declare const fnUntracedEager: <Eff extends Yieldable<any, any, any, any>, AEff, Args extends Array<any>, A, B, C, D, E, F, G>(body: (this: unassigned, ...args: Args) => Generator<Eff, AEff, never>, a: (_: Effect<AEff, [Eff] extends [never] ? never : [Eff] extends [Yieldable<infer _S, infer _A, infer E, infer _R>] ? E : never, [Eff] extends [never] ? never : [Eff] extends [Yieldable<infer _S, infer _A, infer _E, infer R>] ? R : never>, ...args: Args) => A, b: (_: A, ...args: Args) => B, c: (_: B, ...args: Args) => C, d: (_: C, ...args: Args) => D, e: (_: D, ...args: Args) => E, f: (_: E, ...args: Args) => F, g: (_: F, ...args: Args) => G): (...args: Args) => G; // overload 15
export declare const fnUntracedEager: <Self, Eff extends Yieldable<any, any, any, any>, AEff, Args extends Array<any>, A, B, C, D, E, F, G>(body: (this: Self, ...args: Args) => Generator<Eff, AEff, never>, a: (_: Effect<AEff, [Eff] extends [never] ? never : [Eff] extends [Yieldable<infer _S, infer _A, infer E, infer _R>] ? E : never, [Eff] extends [never] ? never : [Eff] extends [Yieldable<infer _S, infer _A, infer _E, infer R>] ? R : never>, ...args: Args) => A, b: (_: A, ...args: Args) => B, c: (_: B, ...args: Args) => C, d: (_: C, ...args: Args) => D, e: (_: D, ...args: Args) => E, f: (_: E, ...args: Args) => F, g: (_: F, ...args: Args) => G): (this: Self, ...args: Args) => G; // overload 16
export declare const fnUntracedEager: <Eff extends Yieldable<any, any, any, any>, AEff, Args extends Array<any>, A, B, C, D, E, F, G, H>(body: (this: unassigned, ...args: Args) => Generator<Eff, AEff, never>, a: (_: Effect<AEff, [Eff] extends [never] ? never : [Eff] extends [Yieldable<infer _S, infer _A, infer E, infer _R>] ? E : never, [Eff] extends [never] ? never : [Eff] extends [Yieldable<infer _S, infer _A, infer _E, infer R>] ? R : never>, ...args: Args) => A, b: (_: A, ...args: Args) => B, c: (_: B, ...args: Args) => C, d: (_: C, ...args: Args) => D, e: (_: D, ...args: Args) => E, f: (_: E, ...args: Args) => F, g: (_: F, ...args: Args) => G, h: (_: G, ...args: Args) => H): (...args: Args) => H; // overload 17
export declare const fnUntracedEager: <Self, Eff extends Yieldable<any, any, any, any>, AEff, Args extends Array<any>, A, B, C, D, E, F, G, H>(body: (this: Self, ...args: Args) => Generator<Eff, AEff, never>, a: (_: Effect<AEff, [Eff] extends [never] ? never : [Eff] extends [Yieldable<infer _S, infer _A, infer E, infer _R>] ? E : never, [Eff] extends [never] ? never : [Eff] extends [Yieldable<infer _S, infer _A, infer _E, infer R>] ? R : never>, ...args: Args) => A, b: (_: A, ...args: Args) => B, c: (_: B, ...args: Args) => C, d: (_: C, ...args: Args) => D, e: (_: D, ...args: Args) => E, f: (_: E, ...args: Args) => F, g: (_: F, ...args: Args) => G, h: (_: G, ...args: Args) => H): (this: Self, ...args: Args) => H; // overload 18
export declare const fnUntracedEager: <Eff extends Yieldable<any, any, any, any>, AEff, Args extends Array<any>, A, B, C, D, E, F, G, H, I>(body: (this: unassigned, ...args: Args) => Generator<Eff, AEff, never>, a: (_: Effect<AEff, [Eff] extends [never] ? never : [Eff] extends [Yieldable<infer _S, infer _A, infer E, infer _R>] ? E : never, [Eff] extends [never] ? never : [Eff] extends [Yieldable<infer _S, infer _A, infer _E, infer R>] ? R : never>, ...args: Args) => A, b: (_: A, ...args: Args) => B, c: (_: B, ...args: Args) => C, d: (_: C, ...args: Args) => D, e: (_: D, ...args: Args) => E, f: (_: E, ...args: Args) => F, g: (_: F, ...args: Args) => G, h: (_: G, ...args: Args) => H, i: (_: H, ...args: Args) => I): (...args: Args) => I; // overload 19
export declare const fnUntracedEager: <Self, Eff extends Yieldable<any, any, any, any>, AEff, Args extends Array<any>, A, B, C, D, E, F, G, H, I>(body: (this: Self, ...args: Args) => Generator<Eff, AEff, never>, a: (_: Effect<AEff, [Eff] extends [never] ? never : [Eff] extends [Yieldable<infer _S, infer _A, infer E, infer _R>] ? E : never, [Eff] extends [never] ? never : [Eff] extends [Yieldable<infer _S, infer _A, infer _E, infer R>] ? R : never>, ...args: Args) => A, b: (_: A, ...args: Args) => B, c: (_: B, ...args: Args) => C, d: (_: C, ...args: Args) => D, e: (_: D, ...args: Args) => E, f: (_: E, ...args: Args) => F, g: (_: F, ...args: Args) => G, h: (_: G, ...args: Args) => H, i: (_: H, ...args: Args) => I): (this: Self, ...args: Args) => I; // overload 20
export declare const fnUntracedEager: <Eff extends Yieldable<any, any, any, any>, AEff, Args extends Array<any>, A, B, C, D, E, F, G, H, I, J>(body: (this: unassigned, ...args: Args) => Generator<Eff, AEff, never>, a: (_: Effect<AEff, [Eff] extends [never] ? never : [Eff] extends [Yieldable<infer _S, infer _A, infer E, infer _R>] ? E : never, [Eff] extends [never] ? never : [Eff] extends [Yieldable<infer _S, infer _A, infer _E, infer R>] ? R : never>, ...args: Args) => A, b: (_: A, ...args: Args) => B, c: (_: B, ...args: Args) => C, d: (_: C, ...args: Args) => D, e: (_: D, ...args: Args) => E, f: (_: E, ...args: Args) => F, g: (_: F, ...args: Args) => G, h: (_: G, ...args: Args) => H, i: (_: H, ...args: Args) => I, j: (_: I, ...args: Args) => J): (...args: Args) => J; // overload 21
export declare const fnUntracedEager: <Self, Eff extends Yieldable<any, any, any, any>, AEff, Args extends Array<any>, A, B, C, D, E, F, G, H, I, J>(body: (this: Self, ...args: Args) => Generator<Eff, AEff, never>, a: (_: Effect<AEff, [Eff] extends [never] ? never : [Eff] extends [Yieldable<infer _S, infer _A, infer E, infer _R>] ? E : never, [Eff] extends [never] ? never : [Eff] extends [Yieldable<infer _S, infer _A, infer _E, infer R>] ? R : never>, ...args: Args) => A, b: (_: A, ...args: Args) => B, c: (_: B, ...args: Args) => C, d: (_: C, ...args: Args) => D, e: (_: D, ...args: Args) => E, f: (_: E, ...args: Args) => F, g: (_: F, ...args: Args) => G, h: (_: G, ...args: Args) => H, i: (_: H, ...args: Args) => I, j: (_: I, ...args: Args) => J): (this: Self, ...args: Args) => J; // overload 22
export declare const fnUntracedEager: <Eff extends Yieldable<any, any, any, any>, AEff, Args extends Array<any>, A, B, C, D, E, F, G, H, I, J, K>(body: (this: unassigned, ...args: Args) => Generator<Eff, AEff, never>, a: (_: Effect<AEff, [Eff] extends [never] ? never : [Eff] extends [Yieldable<infer _S, infer _A, infer E, infer _R>] ? E : never, [Eff] extends [never] ? never : [Eff] extends [Yieldable<infer _S, infer _A, infer _E, infer R>] ? R : never>, ...args: Args) => A, b: (_: A, ...args: Args) => B, c: (_: B, ...args: Args) => C, d: (_: C, ...args: Args) => D, e: (_: D, ...args: Args) => E, f: (_: E, ...args: Args) => F, g: (_: F, ...args: Args) => G, h: (_: G, ...args: Args) => H, i: (_: H, ...args: Args) => I, j: (_: I, ...args: Args) => J, k: (_: J, ...args: Args) => K): (...args: Args) => K; // overload 23
export declare const fnUntracedEager: <Self, Eff extends Yieldable<any, any, any, any>, AEff, Args extends Array<any>, A, B, C, D, E, F, G, H, I, J, K>(body: (this: Self, ...args: Args) => Generator<Eff, AEff, never>, a: (_: Effect<AEff, [Eff] extends [never] ? never : [Eff] extends [Yieldable<infer _S, infer _A, infer E, infer _R>] ? E : never, [Eff] extends [never] ? never : [Eff] extends [Yieldable<infer _S, infer _A, infer _E, infer R>] ? R : never>, ...args: Args) => A, b: (_: A, ...args: Args) => B, c: (_: B, ...args: Args) => C, d: (_: C, ...args: Args) => D, e: (_: D, ...args: Args) => E, f: (_: E, ...args: Args) => F, g: (_: F, ...args: Args) => G, h: (_: G, ...args: Args) => H, i: (_: H, ...args: Args) => I, j: (_: I, ...args: Args) => J, k: (_: J, ...args: Args) => K): (this: Self, ...args: Args) => K; // overload 24
export declare const fnUntracedEager: <Eff extends Yieldable<any, any, any, any>, AEff, Args extends Array<any>, A, B, C, D, E, F, G, H, I, J, K, L>(body: (this: unassigned, ...args: Args) => Generator<Eff, AEff, never>, a: (_: Effect<AEff, [Eff] extends [never] ? never : [Eff] extends [Yieldable<infer _S, infer _A, infer E, infer _R>] ? E : never, [Eff] extends [never] ? never : [Eff] extends [Yieldable<infer _S, infer _A, infer _E, infer R>] ? R : never>, ...args: Args) => A, b: (_: A, ...args: Args) => B, c: (_: B, ...args: Args) => C, d: (_: C, ...args: Args) => D, e: (_: D, ...args: Args) => E, f: (_: E, ...args: Args) => F, g: (_: F, ...args: Args) => G, h: (_: G, ...args: Args) => H, i: (_: H, ...args: Args) => I, j: (_: I, ...args: Args) => J, k: (_: J, ...args: Args) => K, l: (_: K, ...args: Args) => L): (...args: Args) => L; // overload 25
export declare const fnUntracedEager: <Self, Eff extends Yieldable<any, any, any, any>, AEff, Args extends Array<any>, A, B, C, D, E, F, G, H, I, J, K, L>(body: (this: Self, ...args: Args) => Generator<Eff, AEff, never>, a: (_: Effect<AEff, [Eff] extends [never] ? never : [Eff] extends [Yieldable<infer _S, infer _A, infer E, infer _R>] ? E : never, [Eff] extends [never] ? never : [Eff] extends [Yieldable<infer _S, infer _A, infer _E, infer R>] ? R : never>, ...args: Args) => A, b: (_: A, ...args: Args) => B, c: (_: B, ...args: Args) => C, d: (_: C, ...args: Args) => D, e: (_: D, ...args: Args) => E, f: (_: E, ...args: Args) => F, g: (_: F, ...args: Args) => G, h: (_: G, ...args: Args) => H, i: (_: H, ...args: Args) => I, j: (_: I, ...args: Args) => J, k: (_: J, ...args: Args) => K, l: (_: K, ...args: Args) => L): (this: Self, ...args: Args) => L; // overload 26
export declare const fnUntracedEager: <Eff extends Yieldable<any, any, any, any>, AEff, Args extends Array<any>, A, B, C, D, E, F, G, H, I, J, K, L, M>(body: (this: unassigned, ...args: Args) => Generator<Eff, AEff, never>, a: (_: Effect<AEff, [Eff] extends [never] ? never : [Eff] extends [Yieldable<infer _S, infer _A, infer E, infer _R>] ? E : never, [Eff] extends [never] ? never : [Eff] extends [Yieldable<infer _S, infer _A, infer _E, infer R>] ? R : never>, ...args: Args) => A, b: (_: A, ...args: Args) => B, c: (_: B, ...args: Args) => C, d: (_: C, ...args: Args) => D, e: (_: D, ...args: Args) => E, f: (_: E, ...args: Args) => F, g: (_: F, ...args: Args) => G, h: (_: G, ...args: Args) => H, i: (_: H, ...args: Args) => I, j: (_: I, ...args: Args) => J, k: (_: J, ...args: Args) => K, l: (_: K, ...args: Args) => L, m: (_: L, ...args: Args) => M): (...args: Args) => M; // overload 27
export declare const fnUntracedEager: <Self, Eff extends Yieldable<any, any, any, any>, AEff, Args extends Array<any>, A, B, C, D, E, F, G, H, I, J, K, L, M>(body: (this: Self, ...args: Args) => Generator<Eff, AEff, never>, a: (_: Effect<AEff, [Eff] extends [never] ? never : [Eff] extends [Yieldable<infer _S, infer _A, infer E, infer _R>] ? E : never, [Eff] extends [never] ? never : [Eff] extends [Yieldable<infer _S, infer _A, infer _E, infer R>] ? R : never>, ...args: Args) => A, b: (_: A, ...args: Args) => B, c: (_: B, ...args: Args) => C, d: (_: C, ...args: Args) => D, e: (_: D, ...args: Args) => E, f: (_: E, ...args: Args) => F, g: (_: F, ...args: Args) => G, h: (_: G, ...args: Args) => H, i: (_: H, ...args: Args) => I, j: (_: I, ...args: Args) => J, k: (_: J, ...args: Args) => K, l: (_: K, ...args: Args) => L, m: (_: L, ...args: Args) => M): (this: Self, ...args: Args) => M; // overload 28
export declare const fnUntracedEager: <Eff extends Yieldable<any, any, any, any>, AEff, Args extends Array<any>, A, B, C, D, E, F, G, H, I, J, K, L, M, N>(body: (this: unassigned, ...args: Args) => Generator<Eff, AEff, never>, a: (_: Effect<AEff, [Eff] extends [never] ? never : [Eff] extends [Yieldable<infer _S, infer _A, infer E, infer _R>] ? E : never, [Eff] extends [never] ? never : [Eff] extends [Yieldable<infer _S, infer _A, infer _E, infer R>] ? R : never>, ...args: Args) => A, b: (_: A, ...args: Args) => B, c: (_: B, ...args: Args) => C, d: (_: C, ...args: Args) => D, e: (_: D, ...args: Args) => E, f: (_: E, ...args: Args) => F, g: (_: F, ...args: Args) => G, h: (_: G, ...args: Args) => H, i: (_: H, ...args: Args) => I, j: (_: I, ...args: Args) => J, k: (_: J, ...args: Args) => K, l: (_: K, ...args: Args) => L, m: (_: L, ...args: Args) => M, n: (_: M, ...args: Args) => N): (...args: Args) => N; // overload 29
export declare const fnUntracedEager: <Self, Eff extends Yieldable<any, any, any, any>, AEff, Args extends Array<any>, A, B, C, D, E, F, G, H, I, J, K, L, M, N>(body: (this: Self, ...args: Args) => Generator<Eff, AEff, never>, a: (_: Effect<AEff, [Eff] extends [never] ? never : [Eff] extends [Yieldable<infer _S, infer _A, infer E, infer _R>] ? E : never, [Eff] extends [never] ? never : [Eff] extends [Yieldable<infer _S, infer _A, infer _E, infer R>] ? R : never>, ...args: Args) => A, b: (_: A, ...args: Args) => B, c: (_: B, ...args: Args) => C, d: (_: C, ...args: Args) => D, e: (_: D, ...args: Args) => E, f: (_: E, ...args: Args) => F, g: (_: F, ...args: Args) => G, h: (_: G, ...args: Args) => H, i: (_: H, ...args: Args) => I, j: (_: I, ...args: Args) => J, k: (_: J, ...args: Args) => K, l: (_: K, ...args: Args) => L, m: (_: L, ...args: Args) => M, n: (_: M, ...args: Args) => N): (this: Self, ...args: Args) => N; // overload 30
export declare const fnUntracedEager: <Eff extends Yieldable<any, any, any, any>, AEff, Args extends Array<any>, A, B, C, D, E, F, G, H, I, J, K, L, M, N, O>(body: (this: unassigned, ...args: Args) => Generator<Eff, AEff, never>, a: (_: Effect<AEff, [Eff] extends [never] ? never : [Eff] extends [Yieldable<infer _S, infer _A, infer E, infer _R>] ? E : never, [Eff] extends [never] ? never : [Eff] extends [Yieldable<infer _S, infer _A, infer _E, infer R>] ? R : never>, ...args: Args) => A, b: (_: A, ...args: Args) => B, c: (_: B, ...args: Args) => C, d: (_: C, ...args: Args) => D, e: (_: D, ...args: Args) => E, f: (_: E, ...args: Args) => F, g: (_: F, ...args: Args) => G, h: (_: G, ...args: Args) => H, i: (_: H, ...args: Args) => I, j: (_: I, ...args: Args) => J, k: (_: J, ...args: Args) => K, l: (_: K, ...args: Args) => L, m: (_: L, ...args: Args) => M, n: (_: M, ...args: Args) => N, o: (_: N, ...args: Args) => O): (...args: Args) => O; // overload 31
export declare const fnUntracedEager: <Self, Eff extends Yieldable<any, any, any, any>, AEff, Args extends Array<any>, A, B, C, D, E, F, G, H, I, J, K, L, M, N, O>(body: (this: Self, ...args: Args) => Generator<Eff, AEff, never>, a: (_: Effect<AEff, [Eff] extends [never] ? never : [Eff] extends [Yieldable<infer _S, infer _A, infer E, infer _R>] ? E : never, [Eff] extends [never] ? never : [Eff] extends [Yieldable<infer _S, infer _A, infer _E, infer R>] ? R : never>, ...args: Args) => A, b: (_: A, ...args: Args) => B, c: (_: B, ...args: Args) => C, d: (_: C, ...args: Args) => D, e: (_: D, ...args: Args) => E, f: (_: E, ...args: Args) => F, g: (_: F, ...args: Args) => G, h: (_: G, ...args: Args) => H, i: (_: H, ...args: Args) => I, j: (_: I, ...args: Args) => J, k: (_: J, ...args: Args) => K, l: (_: K, ...args: Args) => L, m: (_: L, ...args: Args) => M, n: (_: M, ...args: Args) => N, o: (_: N, ...args: Args) => O): (this: Self, ...args: Args) => O; // overload 32
export declare const fnUntracedEager: <Eff extends Yieldable<any, any, any, any>, AEff, Args extends Array<any>, A, B, C, D, E, F, G, H, I, J, K, L, M, N, O, P>(body: (this: unassigned, ...args: Args) => Generator<Eff, AEff, never>, a: (_: Effect<AEff, [Eff] extends [never] ? never : [Eff] extends [Yieldable<infer _S, infer _A, infer E, infer _R>] ? E : never, [Eff] extends [never] ? never : [Eff] extends [Yieldable<infer _S, infer _A, infer _E, infer R>] ? R : never>, ...args: Args) => A, b: (_: A, ...args: Args) => B, c: (_: B, ...args: Args) => C, d: (_: C, ...args: Args) => D, e: (_: D, ...args: Args) => E, f: (_: E, ...args: Args) => F, g: (_: F, ...args: Args) => G, h: (_: G, ...args: Args) => H, i: (_: H, ...args: Args) => I, j: (_: I, ...args: Args) => J, k: (_: J, ...args: Args) => K, l: (_: K, ...args: Args) => L, m: (_: L, ...args: Args) => M, n: (_: M, ...args: Args) => N, o: (_: N, ...args: Args) => O, p: (_: O, ...args: Args) => P): (...args: Args) => P; // overload 33
export declare const fnUntracedEager: <Self, Eff extends Yieldable<any, any, any, any>, AEff, Args extends Array<any>, A, B, C, D, E, F, G, H, I, J, K, L, M, N, O, P>(body: (this: Self, ...args: Args) => Generator<Eff, AEff, never>, a: (_: Effect<AEff, [Eff] extends [never] ? never : [Eff] extends [Yieldable<infer _S, infer _A, infer E, infer _R>] ? E : never, [Eff] extends [never] ? never : [Eff] extends [Yieldable<infer _S, infer _A, infer _E, infer R>] ? R : never>, ...args: Args) => A, b: (_: A, ...args: Args) => B, c: (_: B, ...args: Args) => C, d: (_: C, ...args: Args) => D, e: (_: D, ...args: Args) => E, f: (_: E, ...args: Args) => F, g: (_: F, ...args: Args) => G, h: (_: G, ...args: Args) => H, i: (_: H, ...args: Args) => I, j: (_: I, ...args: Args) => J, k: (_: J, ...args: Args) => K, l: (_: K, ...args: Args) => L, m: (_: L, ...args: Args) => M, n: (_: M, ...args: Args) => N, o: (_: N, ...args: Args) => O, p: (_: O, ...args: Args) => P): (this: Self, ...args: Args) => P; // overload 34
export declare const fnUntracedEager: <Eff extends Yieldable<any, any, any, any>, AEff, Args extends Array<any>, A, B, C, D, E, F, G, H, I, J, K, L, M, N, O, P, Q>(body: (this: unassigned, ...args: Args) => Generator<Eff, AEff, never>, a: (_: Effect<AEff, [Eff] extends [never] ? never : [Eff] extends [Yieldable<infer _S, infer _A, infer E, infer _R>] ? E : never, [Eff] extends [never] ? never : [Eff] extends [Yieldable<infer _S, infer _A, infer _E, infer R>] ? R : never>, ...args: Args) => A, b: (_: A, ...args: Args) => B, c: (_: B, ...args: Args) => C, d: (_: C, ...args: Args) => D, e: (_: D, ...args: Args) => E, f: (_: E, ...args: Args) => F, g: (_: F, ...args: Args) => G, h: (_: G, ...args: Args) => H, i: (_: H, ...args: Args) => I, j: (_: I, ...args: Args) => J, k: (_: J, ...args: Args) => K, l: (_: K, ...args: Args) => L, m: (_: L, ...args: Args) => M, n: (_: M, ...args: Args) => N, o: (_: N, ...args: Args) => O, p: (_: O, ...args: Args) => P, q: (_: P, ...args: Args) => Q): (...args: Args) => Q; // overload 35
export declare const fnUntracedEager: <Self, Eff extends Yieldable<any, any, any, any>, AEff, Args extends Array<any>, A, B, C, D, E, F, G, H, I, J, K, L, M, N, O, P, Q>(body: (this: Self, ...args: Args) => Generator<Eff, AEff, never>, a: (_: Effect<AEff, [Eff] extends [never] ? never : [Eff] extends [Yieldable<infer _S, infer _A, infer E, infer _R>] ? E : never, [Eff] extends [never] ? never : [Eff] extends [Yieldable<infer _S, infer _A, infer _E, infer R>] ? R : never>, ...args: Args) => A, b: (_: A, ...args: Args) => B, c: (_: B, ...args: Args) => C, d: (_: C, ...args: Args) => D, e: (_: D, ...args: Args) => E, f: (_: E, ...args: Args) => F, g: (_: F, ...args: Args) => G, h: (_: G, ...args: Args) => H, i: (_: H, ...args: Args) => I, j: (_: I, ...args: Args) => J, k: (_: J, ...args: Args) => K, l: (_: K, ...args: Args) => L, m: (_: L, ...args: Args) => M, n: (_: M, ...args: Args) => N, o: (_: N, ...args: Args) => O, p: (_: O, ...args: Args) => P, q: (_: P, ...args: Args) => Q): (this: Self, ...args: Args) => Q; // overload 36
export declare const fnUntracedEager: <Eff extends Yieldable<any, any, any, any>, AEff, Args extends Array<any>, A, B, C, D, E, F, G, H, I, J, K, L, M, N, O, P, Q, R>(body: (this: unassigned, ...args: Args) => Generator<Eff, AEff, never>, a: (_: Effect<AEff, [Eff] extends [never] ? never : [Eff] extends [Yieldable<infer _S, infer _A, infer E, infer _R>] ? E : never, [Eff] extends [never] ? never : [Eff] extends [Yieldable<infer _S, infer _A, infer _E, infer R>] ? R : never>, ...args: Args) => A, b: (_: A, ...args: Args) => B, c: (_: B, ...args: Args) => C, d: (_: C, ...args: Args) => D, e: (_: D, ...args: Args) => E, f: (_: E, ...args: Args) => F, g: (_: F, ...args: Args) => G, h: (_: G, ...args: Args) => H, i: (_: H, ...args: Args) => I, j: (_: I, ...args: Args) => J, k: (_: J, ...args: Args) => K, l: (_: K, ...args: Args) => L, m: (_: L, ...args: Args) => M, n: (_: M, ...args: Args) => N, o: (_: N, ...args: Args) => O, p: (_: O, ...args: Args) => P, q: (_: P, ...args: Args) => Q, r: (_: Q, ...args: Args) => R): (...args: Args) => R; // overload 37
export declare const fnUntracedEager: <Self, Eff extends Yieldable<any, any, any, any>, AEff, Args extends Array<any>, A, B, C, D, E, F, G, H, I, J, K, L, M, N, O, P, Q, R>(body: (this: Self, ...args: Args) => Generator<Eff, AEff, never>, a: (_: Effect<AEff, [Eff] extends [never] ? never : [Eff] extends [Yieldable<infer _S, infer _A, infer E, infer _R>] ? E : never, [Eff] extends [never] ? never : [Eff] extends [Yieldable<infer _S, infer _A, infer _E, infer R>] ? R : never>, ...args: Args) => A, b: (_: A, ...args: Args) => B, c: (_: B, ...args: Args) => C, d: (_: C, ...args: Args) => D, e: (_: D, ...args: Args) => E, f: (_: E, ...args: Args) => F, g: (_: F, ...args: Args) => G, h: (_: G, ...args: Args) => H, i: (_: H, ...args: Args) => I, j: (_: I, ...args: Args) => J, k: (_: J, ...args: Args) => K, l: (_: K, ...args: Args) => L, m: (_: L, ...args: Args) => M, n: (_: M, ...args: Args) => N, o: (_: N, ...args: Args) => O, p: (_: O, ...args: Args) => P, q: (_: P, ...args: Args) => Q, r: (_: Q, ...args: Args) => R): (this: Self, ...args: Args) => R; // overload 38
export declare const fnUntracedEager: <Eff extends Yieldable<any, any, any, any>, AEff, Args extends Array<any>, A, B, C, D, E, F, G, H, I, J, K, L, M, N, O, P, Q, R, S>(body: (this: unassigned, ...args: Args) => Generator<Eff, AEff, never>, a: (_: Effect<AEff, [Eff] extends [never] ? never : [Eff] extends [Yieldable<infer _S, infer _A, infer E, infer _R>] ? E : never, [Eff] extends [never] ? never : [Eff] extends [Yieldable<infer _S, infer _A, infer _E, infer R>] ? R : never>, ...args: Args) => A, b: (_: A, ...args: Args) => B, c: (_: B, ...args: Args) => C, d: (_: C, ...args: Args) => D, e: (_: D, ...args: Args) => E, f: (_: E, ...args: Args) => F, g: (_: F, ...args: Args) => G, h: (_: G, ...args: Args) => H, i: (_: H, ...args: Args) => I, j: (_: I, ...args: Args) => J, k: (_: J, ...args: Args) => K, l: (_: K, ...args: Args) => L, m: (_: L, ...args: Args) => M, n: (_: M, ...args: Args) => N, o: (_: N, ...args: Args) => O, p: (_: O, ...args: Args) => P, q: (_: P, ...args: Args) => Q, r: (_: Q, ...args: Args) => R, s: (_: R, ...args: Args) => S): (...args: Args) => S; // overload 39
export declare const fnUntracedEager: <Self, Eff extends Yieldable<any, any, any, any>, AEff, Args extends Array<any>, A, B, C, D, E, F, G, H, I, J, K, L, M, N, O, P, Q, R, S>(body: (this: Self, ...args: Args) => Generator<Eff, AEff, never>, a: (_: Effect<AEff, [Eff] extends [never] ? never : [Eff] extends [Yieldable<infer _S, infer _A, infer E, infer _R>] ? E : never, [Eff] extends [never] ? never : [Eff] extends [Yieldable<infer _S, infer _A, infer _E, infer R>] ? R : never>, ...args: Args) => A, b: (_: A, ...args: Args) => B, c: (_: B, ...args: Args) => C, d: (_: C, ...args: Args) => D, e: (_: D, ...args: Args) => E, f: (_: E, ...args: Args) => F, g: (_: F, ...args: Args) => G, h: (_: G, ...args: Args) => H, i: (_: H, ...args: Args) => I, j: (_: I, ...args: Args) => J, k: (_: J, ...args: Args) => K, l: (_: K, ...args: Args) => L, m: (_: L, ...args: Args) => M, n: (_: M, ...args: Args) => N, o: (_: N, ...args: Args) => O, p: (_: O, ...args: Args) => P, q: (_: P, ...args: Args) => Q, r: (_: Q, ...args: Args) => R, s: (_: R, ...args: Args) => S): (this: Self, ...args: Args) => S; // overload 40
export declare const fnUntracedEager: <Eff extends Yieldable<any, any, any, any>, AEff, Args extends Array<any>, A, B, C, D, E, F, G, H, I, J, K, L, M, N, O, P, Q, R, S, T>(body: (this: unassigned, ...args: Args) => Generator<Eff, AEff, never>, a: (_: Effect<AEff, [Eff] extends [never] ? never : [Eff] extends [Yieldable<infer _S, infer _A, infer E, infer _R>] ? E : never, [Eff] extends [never] ? never : [Eff] extends [Yieldable<infer _S, infer _A, infer _E, infer R>] ? R : never>, ...args: Args) => A, b: (_: A, ...args: Args) => B, c: (_: B, ...args: Args) => C, d: (_: C, ...args: Args) => D, e: (_: D, ...args: Args) => E, f: (_: E, ...args: Args) => F, g: (_: F, ...args: Args) => G, h: (_: G, ...args: Args) => H, i: (_: H, ...args: Args) => I, j: (_: I, ...args: Args) => J, k: (_: J, ...args: Args) => K, l: (_: K, ...args: Args) => L, m: (_: L, ...args: Args) => M, n: (_: M, ...args: Args) => N, o: (_: N, ...args: Args) => O, p: (_: O, ...args: Args) => P, q: (_: P, ...args: Args) => Q, r: (_: Q, ...args: Args) => R, s: (_: R, ...args: Args) => S, t: (_: S, ...args: Args) => T): (...args: Args) => T; // overload 41
export declare const fnUntracedEager: <Self, Eff extends Yieldable<any, any, any, any>, AEff, Args extends Array<any>, A, B, C, D, E, F, G, H, I, J, K, L, M, N, O, P, Q, R, S, T>(body: (this: Self, ...args: Args) => Generator<Eff, AEff, never>, a: (_: Effect<AEff, [Eff] extends [never] ? never : [Eff] extends [Yieldable<infer _S, infer _A, infer E, infer _R>] ? E : never, [Eff] extends [never] ? never : [Eff] extends [Yieldable<infer _S, infer _A, infer _E, infer R>] ? R : never>, ...args: Args) => A, b: (_: A, ...args: Args) => B, c: (_: B, ...args: Args) => C, d: (_: C, ...args: Args) => D, e: (_: D, ...args: Args) => E, f: (_: E, ...args: Args) => F, g: (_: F, ...args: Args) => G, h: (_: G, ...args: Args) => H, i: (_: H, ...args: Args) => I, j: (_: I, ...args: Args) => J, k: (_: J, ...args: Args) => K, l: (_: K, ...args: Args) => L, m: (_: L, ...args: Args) => M, n: (_: M, ...args: Args) => N, o: (_: N, ...args: Args) => O, p: (_: O, ...args: Args) => P, q: (_: P, ...args: Args) => Q, r: (_: Q, ...args: Args) => R, s: (_: R, ...args: Args) => S, t: (_: S, ...args: Args) => T): (this: Self, ...args: Args) => T; // overload 42
export declare const forEach: <B, E, R, S extends Iterable<any>, const Discard extends boolean = false>(f: (a: Arr.ReadonlyArray.Infer<S>, i: number) => Effect<B, E, R>, options?: { readonly concurrency?: Concurrency | undefined; readonly discard?: Discard | undefined; } | undefined): (self: S) => Effect<Discard extends false ? Arr.ReadonlyArray.With<S, B> : void, E, R>; // overload 1
export declare const forEach: <B, E, R, S extends Iterable<any>, const Discard extends boolean = false>(self: S, f: (a: Arr.ReadonlyArray.Infer<S>, i: number) => Effect<B, E, R>, options?: { readonly concurrency?: Concurrency | undefined; readonly discard?: Discard | undefined; } | undefined): Effect<Discard extends false ? Arr.ReadonlyArray.With<S, B> : void, E, R>; // overload 2
export declare const forever: <Arg extends Effect<any, any, any> | { readonly disableYield?: boolean | undefined; } | undefined = { readonly disableYield?: boolean | undefined; }>(effectOrOptions?: Arg, options?: { readonly disableYield?: boolean | undefined; } | undefined): [Arg] extends [Effect<infer _A, infer _E, infer _R>] ? Effect<never, _E, _R> : <A, E, R>(self: Effect<A, E, R>) => Effect<never, E, R>;
export declare const forkChild: <Arg extends Effect<any, any, any> | { readonly startImmediately?: boolean | undefined; readonly uninterruptible?: boolean | "inherit" | undefined; } | undefined = { readonly startImmediately?: boolean | undefined; readonly uninterruptible?: boolean | "inherit" | undefined; }>(effectOrOptions?: Arg, options?: { readonly startImmediately?: boolean | undefined; readonly uninterruptible?: boolean | "inherit" | undefined; } | undefined): [Arg] extends [Effect<infer _A, infer _E, infer _R>] ? Effect<Fiber<_A, _E>, never, _R> : <A, E, R>(self: Effect<A, E, R>) => Effect<Fiber<A, E>, never, R>;
export declare const forkDetach: <Arg extends Effect<any, any, any> | { readonly startImmediately?: boolean | undefined; readonly uninterruptible?: boolean | "inherit" | undefined; } | undefined = { readonly startImmediately?: boolean | undefined; readonly uninterruptible?: boolean | "inherit" | undefined; }>(effectOrOptions?: Arg, options?: { readonly startImmediately?: boolean | undefined; readonly uninterruptible?: boolean | "inherit" | undefined; } | undefined): [Arg] extends [Effect<infer _A, infer _E, infer _R>] ? Effect<Fiber<_A, _E>, never, _R> : <A, E, R>(self: Effect<A, E, R>) => Effect<Fiber<A, E>, never, R>;
export declare const forkIn: (scope: Scope, options?: { readonly startImmediately?: boolean | undefined; readonly uninterruptible?: boolean | "inherit" | undefined; }): <A, E, R>(self: Effect<A, E, R>) => Effect<Fiber<A, E>, never, R>; // overload 1
export declare const forkIn: <A, E, R>(self: Effect<A, E, R>, scope: Scope, options?: { readonly startImmediately?: boolean | undefined; readonly uninterruptible?: boolean | "inherit" | undefined; }): Effect<Fiber<A, E>, never, R>; // overload 2
export declare const forkScoped: <Arg extends Effect<any, any, any> | { readonly startImmediately?: boolean | undefined; readonly uninterruptible?: boolean | "inherit" | undefined; } | undefined = { readonly startImmediately?: boolean | undefined; readonly uninterruptible?: boolean | "inherit" | undefined; }>(effectOrOptions?: Arg, options?: { readonly startImmediately?: boolean | undefined; readonly uninterruptible?: boolean | "inherit" | undefined; } | undefined): [Arg] extends [Effect<infer _A, infer _E, infer _R>] ? Effect<Fiber<_A, _E>, never, _R> : <A, E, R>(self: Effect<A, E, R>) => Effect<Fiber<A, E>, never, R | Scope>;
export declare const fromNullishOr: <A>(value: A): Effect<NonNullable<A>, Cause.NoSuchElementError>;
export declare const fromOption: <A>(option: Option<A>): Effect<A, Cause.NoSuchElementError>;
export declare const fromResult: <A, E>(result: Result.Result<A, E>): Effect<A, E>;
export declare const fromYieldable: <Self extends Yieldable.Any, A, E, R>(yieldable: Yieldable<Self, A, E, R>): Effect<A, E, R>;
export declare const gen: <Eff extends Yieldable<any, any, any, any>, AEff>(f: () => Generator<Eff, AEff, never>): Effect<AEff, [Eff] extends [never] ? never : [Eff] extends [Yieldable<infer _S, infer _A, infer E, infer _R>] ? E : never, [Eff] extends [never] ? never : [Eff] extends [Yieldable<infer _S, infer _A, infer _E, infer R>] ? R : never>; // overload 1
export declare const gen: <Self, Eff extends Yieldable<any, any, any, any>, AEff>(options: { readonly self: Self; }, f: (this: Self) => Generator<Eff, AEff, never>): Effect<AEff, [Eff] extends [never] ? never : [Eff] extends [Yieldable<infer _S, infer _A, infer E, infer _R>] ? E : never, [Eff] extends [never] ? never : [Eff] extends [Yieldable<infer _S, infer _A, infer _E, infer R>] ? R : never>; // overload 2
export declare const ignore: <Arg extends Effect<any, any, any> | { readonly log?: boolean | LogLevel | undefined; } | undefined = { readonly log?: boolean | LogLevel | undefined; }>(effectOrOptions?: Arg, options?: { readonly log?: boolean | LogLevel | undefined; } | undefined): [Arg] extends [Effect<infer _A, infer _E, infer _R>] ? Effect<void, never, _R> : <A, E, R>(self: Effect<A, E, R>) => Effect<void, never, R>;
export declare const ignoreCause: <Arg extends Effect<any, any, any> | { readonly log?: boolean | LogLevel | undefined; } | undefined = { readonly log?: boolean | LogLevel | undefined; }>(effectOrOptions?: Arg, options?: { readonly log?: boolean | LogLevel | undefined; } | undefined): [Arg] extends [Effect<infer _A, infer _E, infer _R>] ? Effect<void, never, _R> : <A, E, R>(self: Effect<A, E, R>) => Effect<void, never, R>;
export declare const interruptible: <A, E, R>(self: Effect<A, E, R>): Effect<A, E, R>;
export declare const interruptibleMask: <A, E, R>(f: (restore: <AX, EX, RX>(effect: Effect<AX, EX, RX>) => Effect<AX, EX, RX>) => Effect<A, E, R>): Effect<A, E, R>;
export declare const isEffect: (u: unknown): u is Effect<any, any, any>;
export declare const isFailure: <A, E, R>(self: Effect<A, E, R>): Effect<boolean, never, R>;
export declare const isSuccess: <A, E, R>(self: Effect<A, E, R>): Effect<boolean, never, R>;
export declare const linkSpans: (span: AnySpan | ReadonlyArray<AnySpan>, attributes?: Record<string, unknown>): <A, E, R>(self: Effect<A, E, R>) => Effect<A, E, R>; // overload 1
export declare const linkSpans: <A, E, R>(self: Effect<A, E, R>, span: AnySpan | ReadonlyArray<AnySpan>, attributes?: Record<string, unknown>): Effect<A, E, R>; // overload 2
export declare const log: (...message: ReadonlyArray<any>): Effect<void>;
export declare const logDebug: (...message: ReadonlyArray<any>): Effect<void>;
export declare const logError: (...message: ReadonlyArray<any>): Effect<void>;
export declare const logFatal: (...message: ReadonlyArray<any>): Effect<void>;
export declare const logInfo: (...message: ReadonlyArray<any>): Effect<void>;
export declare const logTrace: (...message: ReadonlyArray<any>): Effect<void>;
export declare const logWarning: (...message: ReadonlyArray<any>): Effect<void>;
export declare const logWithLevel: (level?: LogLevel): (...message: ReadonlyArray<any>) => Effect<void>;
export declare const makeSpan: (name: string, options?: SpanOptionsNoTrace): Effect<Span>;
export declare const makeSpanScoped: (name: string, options?: SpanOptionsNoTrace | undefined): Effect<Span, never, Scope>;
export declare const map: <A, B>(f: (a: A) => B): <E, R>(self: Effect<A, E, R>) => Effect<B, E, R>; // overload 1
export declare const map: <A, E, R, B>(self: Effect<A, E, R>, f: (a: A) => B): Effect<B, E, R>; // overload 2
export declare const mapBoth: <E, E2, A, A2>(options: { readonly onFailure: (e: E) => E2; readonly onSuccess: (a: A) => A2; }): <R>(self: Effect<A, E, R>) => Effect<A2, E2, R>; // overload 1
export declare const mapBoth: <A, E, R, E2, A2>(self: Effect<A, E, R>, options: { readonly onFailure: (e: E) => E2; readonly onSuccess: (a: A) => A2; }): Effect<A2, E2, R>; // overload 2
export declare const mapBothEager: <E, E2, A, A2>(options: { readonly onFailure: (e: E) => E2; readonly onSuccess: (a: A) => A2; }): <R>(self: Effect<A, E, R>) => Effect<A2, E2, R>; // overload 1
export declare const mapBothEager: <A, E, R, E2, A2>(self: Effect<A, E, R>, options: { readonly onFailure: (e: E) => E2; readonly onSuccess: (a: A) => A2; }): Effect<A2, E2, R>; // overload 2
export declare const mapEager: <A, B>(f: (a: A) => B): <E, R>(self: Effect<A, E, R>) => Effect<B, E, R>; // overload 1
export declare const mapEager: <A, E, R, B>(self: Effect<A, E, R>, f: (a: A) => B): Effect<B, E, R>; // overload 2
export declare const mapError: <E, E2>(f: (e: E) => E2): <A, R>(self: Effect<A, E, R>) => Effect<A, E2, R>; // overload 1
export declare const mapError: <A, E, R, E2>(self: Effect<A, E, R>, f: (e: E) => E2): Effect<A, E2, R>; // overload 2
export declare const mapErrorEager: <E, E2>(f: (e: E) => E2): <A, R>(self: Effect<A, E, R>) => Effect<A, E2, R>; // overload 1
export declare const mapErrorEager: <A, E, R, E2>(self: Effect<A, E, R>, f: (e: E) => E2): Effect<A, E2, R>; // overload 2
export declare const match: <E, A2, A, A3>(options: { readonly onFailure: (error: E) => A2; readonly onSuccess: (value: A) => A3; }): <R>(self: Effect<A, E, R>) => Effect<A2 | A3, never, R>; // overload 1
export declare const match: <A, E, R, A2, A3>(self: Effect<A, E, R>, options: { readonly onFailure: (error: E) => A2; readonly onSuccess: (value: A) => A3; }): Effect<A2 | A3, never, R>; // overload 2
export declare const matchCause: <E, A2, A, A3>(options: { readonly onFailure: (cause: Cause.Cause<E>) => A2; readonly onSuccess: (a: A) => A3; }): <R>(self: Effect<A, E, R>) => Effect<A2 | A3, never, R>; // overload 1
export declare const matchCause: <A, E, R, A2, A3>(self: Effect<A, E, R>, options: { readonly onFailure: (cause: Cause.Cause<E>) => A2; readonly onSuccess: (a: A) => A3; }): Effect<A2 | A3, never, R>; // overload 2
export declare const matchCauseEager: <E, A2, A, A3>(options: { readonly onFailure: (cause: Cause.Cause<E>) => A2; readonly onSuccess: (value: A) => A3; }): <R>(self: Effect<A, E, R>) => Effect<A2 | A3, never, R>; // overload 1
export declare const matchCauseEager: <A, E, R, A2, A3>(self: Effect<A, E, R>, options: { readonly onFailure: (cause: Cause.Cause<E>) => A2; readonly onSuccess: (value: A) => A3; }): Effect<A2 | A3, never, R>; // overload 2
export declare const matchCauseEffect: <E, A2, E2, R2, A, A3, E3, R3>(options: { readonly onFailure: (cause: Cause.Cause<E>) => Effect<A2, E2, R2>; readonly onSuccess: (a: A) => Effect<A3, E3, R3>; }): <R>(self: Effect<A, E, R>) => Effect<A2 | A3, E2 | E3, R2 | R3 | R>; // overload 1
export declare const matchCauseEffect: <A, E, R, A2, E2, R2, A3, E3, R3>(self: Effect<A, E, R>, options: { readonly onFailure: (cause: Cause.Cause<E>) => Effect<A2, E2, R2>; readonly onSuccess: (a: A) => Effect<A3, E3, R3>; }): Effect<A2 | A3, E2 | E3, R2 | R3 | R>; // overload 2
export declare const matchCauseEffectEager: <E, A2, E2, R2, A, A3, E3, R3>(options: { readonly onFailure: (cause: Cause.Cause<E>) => Effect<A2, E2, R2>; readonly onSuccess: (a: A) => Effect<A3, E3, R3>; }): <R>(self: Effect<A, E, R>) => Effect<A2 | A3, E2 | E3, R2 | R3 | R>; // overload 1
export declare const matchCauseEffectEager: <A, E, R, A2, E2, R2, A3, E3, R3>(self: Effect<A, E, R>, options: { readonly onFailure: (cause: Cause.Cause<E>) => Effect<A2, E2, R2>; readonly onSuccess: (a: A) => Effect<A3, E3, R3>; }): Effect<A2 | A3, E2 | E3, R2 | R3 | R>; // overload 2
export declare const matchEager: <E, A2, A, A3>(options: { readonly onFailure: (error: E) => A2; readonly onSuccess: (value: A) => A3; }): <R>(self: Effect<A, E, R>) => Effect<A2 | A3, never, R>; // overload 1
export declare const matchEager: <A, E, R, A2, A3>(self: Effect<A, E, R>, options: { readonly onFailure: (error: E) => A2; readonly onSuccess: (value: A) => A3; }): Effect<A2 | A3, never, R>; // overload 2
export declare const matchEffect: <E, A2, E2, R2, A, A3, E3, R3>(options: { readonly onFailure: (e: E) => Effect<A2, E2, R2>; readonly onSuccess: (a: A) => Effect<A3, E3, R3>; }): <R>(self: Effect<A, E, R>) => Effect<A2 | A3, E2 | E3, R2 | R3 | R>; // overload 1
export declare const matchEffect: <A, E, R, A2, E2, R2, A3, E3, R3>(self: Effect<A, E, R>, options: { readonly onFailure: (e: E) => Effect<A2, E2, R2>; readonly onSuccess: (a: A) => Effect<A3, E3, R3>; }): Effect<A2 | A3, E2 | E3, R2 | R3 | R>; // overload 2
export declare const onError: <E, X, R2>(cleanup: (cause: Cause.Cause<E>) => Effect<X, never, R2>): <A, R>(self: Effect<A, E, R>) => Effect<A, E, R2 | R>; // overload 1
export declare const onError: <A, E, R, X, R2>(self: Effect<A, E, R>, cleanup: (cause: Cause.Cause<E>) => Effect<X, never, R2>): Effect<A, E, R2 | R>; // overload 2
export declare const onErrorIf: <E, Result extends Filter.ResultOrBool, XE, XR>(filter: Filter.OrPredicate<Cause.Cause<E>, Result>, f: (failure: Filter.Pass<Cause.Cause<E>, Result>, cause: Cause.Cause<E>) => Effect<void, XE, XR>): <A, R>(self: Effect<A, E, R>) => Effect<A, E | XE, R | XR>; // overload 1
export declare const onErrorIf: <A, E, R, XE, XR, Result extends Filter.ResultOrBool>(self: Effect<A, E, R>, filter: Filter.OrPredicate<Cause.Cause<E>, Result>, f: (failure: Filter.Pass<Cause.Cause<E>, Result>, cause: Cause.Cause<E>) => Effect<void, XE, XR>): Effect<A, E | XE, R | XR>; // overload 2
export declare const onExit: <A, E, XE = never, XR = never>(f: (exit: Exit.Exit<A, E>) => Effect<void, XE, XR>): <R>(self: Effect<A, E, R>) => Effect<A, E | XE, R | XR>; // overload 1
export declare const onExit: <A, E, R, XE = never, XR = never>(self: Effect<A, E, R>, f: (exit: Exit.Exit<A, E>) => Effect<void, XE, XR>): Effect<A, E | XE, R | XR>; // overload 2
export declare const onExitIf: <A, E, XE, XR, Result extends Filter.ResultOrBool>(filter: Filter.OrPredicate<Exit.Exit<NoInfer<A>, NoInfer<E>>, Result>, f: (pass: Filter.Pass<Exit.Exit<NoInfer<A>, NoInfer<E>>, Result>, exit: Exit.Exit<NoInfer<A>, NoInfer<E>>) => Effect<void, XE, XR>): <R>(self: Effect<A, E, R>) => Effect<A, E | XE, R | XR>; // overload 1
export declare const onExitIf: <A, E, R, XE, XR, Result extends Filter.ResultOrBool>(self: Effect<A, E, R>, filter: Filter.OrPredicate<Exit.Exit<NoInfer<A>, NoInfer<E>>, Result>, f: (pass: Filter.Pass<Exit.Exit<NoInfer<A>, NoInfer<E>>, Result>, exit: Exit.Exit<NoInfer<A>, NoInfer<E>>) => Effect<void, XE, XR>): Effect<A, E | XE, R | XR>; // overload 2
export declare const onExitPrimitive: <A, E, R, XE = never, XR = never>(self: Effect<A, E, R>, f: (exit: Exit.Exit<A, E>) => Effect<void, XE, XR> | undefined, interruptible?: boolean): Effect<A, E | XE, R | XR>;
export declare const onInterrupt: <XE, XR>(finalizer: (interruptors: ReadonlySet<number>) => Effect<void, XE, XR>): <A, E, R>(self: Effect<A, E, R>) => Effect<A, E | XE, R | XR>; // overload 1
export declare const onInterrupt: <A, E, R, XE, XR>(self: Effect<A, E, R>, finalizer: (interruptors: ReadonlySet<number>) => Effect<void, XE, XR>): Effect<A, E | XE, R | XR>; // overload 2
export declare const option: <A, E, R>(self: Effect<A, E, R>): Effect<Option<A>, never, R>;
export declare const orDie: <A, E, R>(self: Effect<A, E, R>): Effect<A, never, R>;
export declare const orElseSucceed: <A2>(evaluate: LazyArg<A2>): <A, E, R>(self: Effect<A, E, R>) => Effect<A2 | A, never, R>; // overload 1
export declare const orElseSucceed: <A, E, R, A2>(self: Effect<A, E, R>, evaluate: LazyArg<A2>): Effect<A | A2, never, R>; // overload 2
export declare const partition: <A, B, E, R>(f: (a: A, i: number) => Effect<B, E, R>, options?: { readonly concurrency?: Concurrency | undefined; }): (elements: Iterable<A>) => Effect<[excluded: Array<E>, satisfying: Array<B>], never, R>; // overload 1
export declare const partition: <A, B, E, R>(elements: Iterable<A>, f: (a: A, i: number) => Effect<B, E, R>, options?: { readonly concurrency?: Concurrency | undefined; }): Effect<[excluded: Array<E>, satisfying: Array<B>], never, R>; // overload 2
export declare const promise: <A>(evaluate: (signal: AbortSignal) => PromiseLike<A>): Effect<A>;
export declare const provide: <const Layers extends [Layer.Any, ...Array<Layer.Any>]>(layers: Layers, options?: { readonly local?: boolean | undefined; } | undefined): <A, E, R>(self: Effect<A, E, R>) => Effect<A, E | Layer.Error<Layers[number]>, Layer.Services<Layers[number]> | Exclude<R, Layer.Success<Layers[number]>>>; // overload 1
export declare const provide: <ROut, E2, RIn>(layer: Layer.Layer<ROut, E2, RIn>, options?: { readonly local?: boolean | undefined; } | undefined): <A, E, R>(self: Effect<A, E, R>) => Effect<A, E | E2, RIn | Exclude<R, ROut>>; // overload 2
export declare const provide: <R2>(context: ServiceMap.ServiceMap<R2>): <A, E, R>(self: Effect<A, E, R>) => Effect<A, E, Exclude<R, R2>>; // overload 3
export declare const provide: <A, E, R, const Layers extends [Layer.Any, ...Array<Layer.Any>]>(self: Effect<A, E, R>, layers: Layers, options?: { readonly local?: boolean | undefined; } | undefined): Effect<A, E | Layer.Error<Layers[number]>, Layer.Services<Layers[number]> | Exclude<R, Layer.Success<Layers[number]>>>; // overload 4
export declare const provide: <A, E, R, ROut, E2, RIn>(self: Effect<A, E, R>, layer: Layer.Layer<ROut, E2, RIn>, options?: { readonly local?: boolean | undefined; } | undefined): Effect<A, E | E2, RIn | Exclude<R, ROut>>; // overload 5
export declare const provide: <A, E, R, R2>(self: Effect<A, E, R>, context: ServiceMap.ServiceMap<R2>): Effect<A, E, Exclude<R, R2>>; // overload 6
export declare const provideService: <I, S>(service: ServiceMap.Service<I, S>): { (implementation: S): <A, E, R>(self: Effect<A, E, R>) => Effect<A, E, Exclude<R, I>>; <A, E, R>(self: Effect<A, E, R>, implementation: S): Effect<A, E, Exclude<R, I>>; }; // overload 1
export declare const provideService: <I, S>(service: ServiceMap.Service<I, S>, implementation: S): <A, E, R>(self: Effect<A, E, R>) => Effect<A, E, Exclude<R, I>>; // overload 2
export declare const provideService: <A, E, R, I, S>(self: Effect<A, E, R>, service: ServiceMap.Service<I, S>, implementation: S): Effect<A, E, Exclude<R, I>>; // overload 3
export declare const provideServiceEffect: <I, S, E2, R2>(service: ServiceMap.Service<I, S>, acquire: Effect<S, E2, R2>): <A, E, R>(self: Effect<A, E, R>) => Effect<A, E | E2, Exclude<R, I> | R2>; // overload 1
export declare const provideServiceEffect: <A, E, R, I, S, E2, R2>(self: Effect<A, E, R>, service: ServiceMap.Service<I, S>, acquire: Effect<S, E2, R2>): Effect<A, E | E2, Exclude<R, I> | R2>; // overload 2
export declare const provideServices: <XR>(context: ServiceMap.ServiceMap<XR>): <A, E, R>(self: Effect<A, E, R>) => Effect<A, E, Exclude<R, XR>>; // overload 1
export declare const provideServices: <A, E, R, XR>(self: Effect<A, E, R>, context: ServiceMap.ServiceMap<XR>): Effect<A, E, Exclude<R, XR>>; // overload 2
export declare const race: <A2, E2, R2>(that: Effect<A2, E2, R2>, options?: { readonly onWinner?: (options: { readonly fiber: Fiber<any, any>; readonly index: number; readonly parentFiber: Fiber<any, any>; }) => void; }): <A, E, R>(self: Effect<A, E, R>) => Effect<A | A2, E | E2, R | R2>; // overload 1
export declare const race: <A, E, R, A2, E2, R2>(self: Effect<A, E, R>, that: Effect<A2, E2, R2>, options?: { readonly onWinner?: (options: { readonly fiber: Fiber<any, any>; readonly index: number; readonly parentFiber: Fiber<any, any>; }) => void; }): Effect<A | A2, E | E2, R | R2>; // overload 2
export declare const raceAll: <Eff extends Effect<any, any, any>>(all: Iterable<Eff>, options?: { readonly onWinner?: (options: { readonly fiber: Fiber<any, any>; readonly index: number; readonly parentFiber: Fiber<any, any>; }) => void; }): Effect<Success<Eff>, Error<Eff>, Services<Eff>>;
export declare const raceAllFirst: <Eff extends Effect<any, any, any>>(all: Iterable<Eff>, options?: { readonly onWinner?: (options: { readonly fiber: Fiber<any, any>; readonly index: number; readonly parentFiber: Fiber<any, any>; }) => void; }): Effect<Success<Eff>, Error<Eff>, Services<Eff>>;
export declare const raceFirst: <A2, E2, R2>(that: Effect<A2, E2, R2>, options?: { readonly onWinner?: (options: { readonly fiber: Fiber<any, any>; readonly index: number; readonly parentFiber: Fiber<any, any>; }) => void; }): <A, E, R>(self: Effect<A, E, R>) => Effect<A | A2, E | E2, R | R2>; // overload 1
export declare const raceFirst: <A, E, R, A2, E2, R2>(self: Effect<A, E, R>, that: Effect<A2, E2, R2>, options?: { readonly onWinner?: (options: { readonly fiber: Fiber<any, any>; readonly index: number; readonly parentFiber: Fiber<any, any>; }) => void; }): Effect<A | A2, E | E2, R | R2>; // overload 2
export declare const repeat: <O extends Repeat.Options<A>, A>(options: O): <E, R>(self: Effect<A, E, R>) => Repeat.Return<R, E, A, O>; // overload 1
export declare const repeat: <Output, Input, Error, Env>(schedule: Schedule<Output, NoInfer<Input>, Error, Env>): <E, R>(self: Effect<Input, E, R>) => Effect<Output, E | Error, R | Env>; // overload 2
export declare const repeat: <Output, Input, Error, Env>(builder: ($: <O, E, R>(_: Schedule<O, NoInfer<Input>, E, R>) => Schedule<O, Input, E, R>) => Schedule<Output, NoInfer<Input>, Error, Env>): <E, R>(self: Effect<Input, E, R>) => Effect<Output, E | Error, R | Env>; // overload 3
export declare const repeat: <A, E, R, O extends Repeat.Options<A>>(self: Effect<A, E, R>, options: O): Repeat.Return<R, E, A, O>; // overload 4
export declare const repeat: <Input, E, R, Output, Error, Env>(self: Effect<Input, E, R>, schedule: Schedule<Output, NoInfer<Input>, Error, Env>): Effect<Output, E | Error, R | Env>; // overload 5
export declare const repeat: <Input, E, R, Output, Error, Env>(self: Effect<Input, E, R>, builder: ($: <O, E, R>(_: Schedule<O, NoInfer<Input>, E, R>) => Schedule<O, Input, E, R>) => Schedule<Output, NoInfer<Input>, Error, Env>): Effect<Output, E | Error, R | Env>; // overload 6
export declare const repeatOrElse: <R2, A, B, E, E2, E3, R3>(schedule: Schedule<B, A, E2, R2>, orElse: (error: E | E2, option: Option<B>) => Effect<B, E3, R3>): <R>(self: Effect<A, E, R>) => Effect<B, E3, R | R2 | R3>; // overload 1
export declare const repeatOrElse: <A, E, R, R2, B, E2, E3, R3>(self: Effect<A, E, R>, schedule: Schedule<B, A, E2, R2>, orElse: (error: E | E2, option: Option<B>) => Effect<B, E3, R3>): Effect<B, E3, R | R2 | R3>; // overload 2
export declare const replicate: (n: number): <A, E, R>(self: Effect<A, E, R>) => Array<Effect<A, E, R>>; // overload 1
export declare const replicate: <A, E, R>(self: Effect<A, E, R>, n: number): Array<Effect<A, E, R>>; // overload 2
export declare const replicateEffect: (n: number, options?: { readonly concurrency?: Concurrency | undefined; readonly discard?: false | undefined; }): <A, E, R>(self: Effect<A, E, R>) => Effect<Array<A>, E, R>; // overload 1
export declare const replicateEffect: (n: number, options: { readonly concurrency?: Concurrency | undefined; readonly discard: true; }): <A, E, R>(self: Effect<A, E, R>) => Effect<void, E, R>; // overload 2
export declare const replicateEffect: <A, E, R>(self: Effect<A, E, R>, n: number, options?: { readonly concurrency?: Concurrency | undefined; readonly discard?: false | undefined; }): Effect<Array<A>, E, R>; // overload 3
export declare const replicateEffect: <A, E, R>(self: Effect<A, E, R>, n: number, options: { readonly concurrency?: Concurrency | undefined; readonly discard: true; }): Effect<void, E, R>; // overload 4
export declare const request: <A extends Request.Any, EX = never, RX = never>(resolver: RequestResolver<A> | Effect<RequestResolver<A>, EX, RX>): (self: A) => Effect<Request.Success<A>, Request.Error<A> | EX, Request.Services<A> | RX>; // overload 1
export declare const request: <A extends Request.Any, EX = never, RX = never>(self: A, resolver: RequestResolver<A> | Effect<RequestResolver<A>, EX, RX>): Effect<Request.Success<A>, Request.Error<A> | EX, Request.Services<A> | RX>; // overload 2
export declare const requestUnsafe: <A extends Request.Any>(self: A, options: { readonly resolver: RequestResolver<A>; readonly onExit: (exit: Exit.Exit<Request.Success<A>, Request.Error<A>>) => void; readonly services: ServiceMap.ServiceMap<never>; }): () => void;
export declare const result: <A, E, R>(self: Effect<A, E, R>): Effect<Result.Result<A, E>, never, R>;
export declare const retry: <E, O extends Retry.Options<E>>(options: O): <A, R>(self: Effect<A, E, R>) => Retry.Return<R, E, A, O>; // overload 1
export declare const retry: <B, E, Error, Env>(policy: Schedule<B, NoInfer<E>, Error, Env>): <A, R>(self: Effect<A, E, R>) => Effect<A, E | Error, R | Env>; // overload 2
export declare const retry: <B, E, Error, Env>(builder: ($: <O, SE, R>(_: Schedule<O, NoInfer<E>, SE, R>) => Schedule<O, E, SE, R>) => Schedule<B, NoInfer<E>, Error, Env>): <A, R>(self: Effect<A, E, R>) => Effect<A, E | Error, R | Env>; // overload 3
export declare const retry: <A, E, R, O extends Retry.Options<E>>(self: Effect<A, E, R>, options: O): Retry.Return<R, E, A, O>; // overload 4
export declare const retry: <A, E, R, B, Error, Env>(self: Effect<A, E, R>, policy: Schedule<B, NoInfer<E>, Error, Env>): Effect<A, E | Error, R | Env>; // overload 5
export declare const retry: <A, E, R, B, Error, Env>(self: Effect<A, E, R>, builder: ($: <O, SE, R>(_: Schedule<O, NoInfer<E>, SE, R>) => Schedule<O, E, SE, R>) => Schedule<B, NoInfer<E>, Error, Env>): Effect<A, E | Error, R | Env>; // overload 6
export declare const retryOrElse: <A1, E, E1, R1, A2, E2, R2>(policy: Schedule<A1, NoInfer<E>, E1, R1>, orElse: (e: NoInfer<E>, out: A1) => Effect<A2, E2, R2>): <A, R>(self: Effect<A, E, R>) => Effect<A | A2, E1 | E2, R | R1 | R2>; // overload 1
export declare const retryOrElse: <A, E, R, A1, E1, R1, A2, E2, R2>(self: Effect<A, E, R>, policy: Schedule<A1, NoInfer<E>, E1, R1>, orElse: (e: NoInfer<E>, out: A1) => Effect<A2, E2, R2>): Effect<A | A2, E1 | E2, R | R1 | R2>; // overload 2
export declare const runCallback: <A, E>(effect: Effect<A, E, never>, options?: (RunOptions & { readonly onExit: (exit: Exit.Exit<A, E>) => void; }) | undefined): (interruptor?: number | undefined) => void;
export declare const runCallbackWith: <R>(services: ServiceMap.ServiceMap<R>): <A, E>(effect: Effect<A, E, R>, options?: (RunOptions & { readonly onExit: (exit: Exit.Exit<A, E>) => void; }) | undefined) => (interruptor?: number | undefined) => void;
export declare const runFork: <A, E>(effect: Effect<A, E, never>, options?: RunOptions | undefined): Fiber<A, E>;
export declare const runForkWith: <R>(services: ServiceMap.ServiceMap<R>): <A, E>(effect: Effect<A, E, R>, options?: RunOptions | undefined) => Fiber<A, E>;
export declare const runPromise: <A, E>(effect: Effect<A, E>, options?: RunOptions | undefined): Promise<A>;
export declare const runPromiseExit: <A, E>(effect: Effect<A, E>, options?: RunOptions | undefined): Promise<Exit.Exit<A, E>>;
export declare const runPromiseExitWith: <R>(services: ServiceMap.ServiceMap<R>): <A, E>(effect: Effect<A, E, R>, options?: RunOptions | undefined) => Promise<Exit.Exit<A, E>>;
export declare const runPromiseWith: <R>(services: ServiceMap.ServiceMap<R>): <A, E>(effect: Effect<A, E, R>, options?: RunOptions | undefined) => Promise<A>;
export declare const runSync: <A, E>(effect: Effect<A, E>): A;
export declare const runSyncExit: <A, E>(effect: Effect<A, E>): Exit.Exit<A, E>;
export declare const runSyncExitWith: <R>(services: ServiceMap.ServiceMap<R>): <A, E>(effect: Effect<A, E, R>) => Exit.Exit<A, E>;
export declare const runSyncWith: <R>(services: ServiceMap.ServiceMap<R>): <A, E>(effect: Effect<A, E, R>) => A;
export declare const sandbox: <A, E, R>(self: Effect<A, E, R>): Effect<A, Cause.Cause<E>, R>;
export declare const satisfiesErrorType: <E>(): <A, E2 extends E, R>(effect: Effect<A, E2, R>) => Effect<A, E2, R>;
export declare const satisfiesServicesType: <R>(): <A, E, R2 extends R>(effect: Effect<A, E, R2>) => Effect<A, E, R2>;
export declare const satisfiesSuccessType: <A>(): <A2 extends A, E, R>(effect: Effect<A2, E, R>) => Effect<A2, E, R>;
export declare const schedule: <Output, Error, Env>(schedule: Schedule<Output, unknown, Error, Env>): <A, E, R>(self: Effect<A, E, R>) => Effect<Output, E, R | Env>; // overload 1
export declare const schedule: <A, E, R, Output, Error, Env>(self: Effect<A, E, R>, schedule: Schedule<Output, unknown, Error, Env>): Effect<Output, E, R | Env>; // overload 2
export declare const scheduleFrom: <Input, Output, Error, Env>(initial: Input, schedule: Schedule<Output, Input, Error, Env>): <E, R>(self: Effect<Input, E, R>) => Effect<Output, E, R | Env>; // overload 1
export declare const scheduleFrom: <Input, E, R, Output, Error, Env>(self: Effect<Input, E, R>, initial: Input, schedule: Schedule<Output, Input, Error, Env>): Effect<Output, E, R | Env>; // overload 2
export declare const scoped: <A, E, R>(self: Effect<A, E, R>): Effect<A, E, Exclude<R, Scope>>;
export declare const scopedWith: <A, E, R>(f: (scope: Scope) => Effect<A, E, R>): Effect<A, E, R>;
export declare const service: <I, S>(service: ServiceMap.Service<I, S>): Effect<S, never, I>;
export declare const serviceOption: <I, S>(key: ServiceMap.Service<I, S>): Effect<Option<S>>;
export declare const services: <R>(): Effect<ServiceMap.ServiceMap<R>, never, R>;
export declare const servicesWith: <R, A, E, R2>(f: (services: ServiceMap.ServiceMap<R>) => Effect<A, E, R2>): Effect<A, E, R | R2>;
export declare const sleep: (duration: Duration.Input): Effect<void>;
export declare const succeed: <A>(value: A): Effect<A>;
export declare const succeedSome: <A>(value: A): Effect<Option<A>>;
export declare const suspend: <A, E, R>(effect: LazyArg<Effect<A, E, R>>): Effect<A, E, R>;
export declare const sync: <A>(thunk: LazyArg<A>): Effect<A>;
export declare const tap: <A, B, E2, R2>(f: (a: NoInfer<A>) => Effect<B, E2, R2>): <E, R>(self: Effect<A, E, R>) => Effect<A, E | E2, R | R2>; // overload 1
export declare const tap: <B, E2, R2>(f: Effect<B, E2, R2>): <A, E, R>(self: Effect<A, E, R>) => Effect<A, E | E2, R | R2>; // overload 2
export declare const tap: <A, E, R, B, E2, R2>(self: Effect<A, E, R>, f: (a: NoInfer<A>) => Effect<B, E2, R2>): Effect<A, E | E2, R | R2>; // overload 3
export declare const tap: <A, E, R, B, E2, R2>(self: Effect<A, E, R>, f: Effect<B, E2, R2>): Effect<A, E | E2, R | R2>; // overload 4
export declare const tapCause: <E, X, E2, R2>(f: (cause: Cause.Cause<NoInfer<E>>) => Effect<X, E2, R2>): <A, R>(self: Effect<A, E, R>) => Effect<A, E | E2, R2 | R>; // overload 1
export declare const tapCause: <A, E, R, X, E2, R2>(self: Effect<A, E, R>, f: (cause: Cause.Cause<E>) => Effect<X, E2, R2>): Effect<A, E | E2, R | R2>; // overload 2
export declare const tapCauseIf: <E, Result extends Filter.ResultOrBool, B, E2, R2>(filter: Filter.OrPredicate<Cause.Cause<E>, Result>, f: (a: Filter.Pass<Cause.Cause<E>, Result>, cause: Cause.Cause<E>) => Effect<B, E2, R2>): <A, R>(self: Effect<A, E, R>) => Effect<A, E | E2, R | R2>; // overload 1
export declare const tapCauseIf: <A, E, R, Result extends Filter.ResultOrBool, B, E2, R2>(self: Effect<A, E, R>, filter: Filter.OrPredicate<Cause.Cause<E>, Result>, f: (a: Filter.Pass<Cause.Cause<E>, Result>, cause: Cause.Cause<E>) => Effect<B, E2, R2>): Effect<A, E | E2, R | R2>; // overload 2
export declare const tapDefect: <E, B, E2, R2>(f: (defect: unknown) => Effect<B, E2, R2>): <A, R>(self: Effect<A, E, R>) => Effect<A, E | E2, R | R2>; // overload 1
export declare const tapDefect: <A, E, R, B, E2, R2>(self: Effect<A, E, R>, f: (defect: unknown) => Effect<B, E2, R2>): Effect<A, E | E2, R | R2>; // overload 2
export declare const tapError: <E, X, E2, R2>(f: (e: NoInfer<E>) => Effect<X, E2, R2>): <A, R>(self: Effect<A, E, R>) => Effect<A, E | E2, R2 | R>; // overload 1
export declare const tapError: <A, E, R, X, E2, R2>(self: Effect<A, E, R>, f: (e: E) => Effect<X, E2, R2>): Effect<A, E | E2, R | R2>; // overload 2
export declare const tapErrorTag: <const K extends Tags<E> | Arr.NonEmptyReadonlyArray<Tags<E>>, E, A1, E1, R1>(k: K, f: (e: ExtractTag<NoInfer<E>, K extends Arr.NonEmptyReadonlyArray<string> ? K[number] : K>) => Effect<A1, E1, R1>): <A, R>(self: Effect<A, E, R>) => Effect<A, E | E1, R1 | R>; // overload 1
export declare const tapErrorTag: <A, E, R, const K extends Tags<E> | Arr.NonEmptyReadonlyArray<Tags<E>>, R1, E1, A1>(self: Effect<A, E, R>, k: K, f: (e: ExtractTag<E, K extends Arr.NonEmptyReadonlyArray<string> ? K[number] : K>) => Effect<A1, E1, R1>): Effect<A, E | E1, R | R1>; // overload 2
export declare const timed: <A, E, R>(self: Effect<A, E, R>): Effect<[duration: Duration.Duration, result: A], E, R>;
export declare const timeout: (duration: Duration.Input): <A, E, R>(self: Effect<A, E, R>) => Effect<A, E | Cause.TimeoutError, R>; // overload 1
export declare const timeout: <A, E, R>(self: Effect<A, E, R>, duration: Duration.Input): Effect<A, E | Cause.TimeoutError, R>; // overload 2
export declare const timeoutOption: (duration: Duration.Input): <A, E, R>(self: Effect<A, E, R>) => Effect<Option<A>, E, R>; // overload 1
export declare const timeoutOption: <A, E, R>(self: Effect<A, E, R>, duration: Duration.Input): Effect<Option<A>, E, R>; // overload 2
export declare const timeoutOrElse: <A2, E2, R2>(options: { readonly duration: Duration.Input; readonly onTimeout: LazyArg<Effect<A2, E2, R2>>; }): <A, E, R>(self: Effect<A, E, R>) => Effect<A | A2, E | E2, R | R2>; // overload 1
export declare const timeoutOrElse: <A, E, R, A2, E2, R2>(self: Effect<A, E, R>, options: { readonly duration: Duration.Input; readonly onTimeout: LazyArg<Effect<A2, E2, R2>>; }): Effect<A | A2, E | E2, R | R2>; // overload 2
export declare const track: <Input, State, E, A>(metric: Metric.Metric<Input, State>, f: (exit: Exit.Exit<A, E>) => Input): <E, R>(self: Effect<A, E, R>) => Effect<A, E, R>; // overload 1
export declare const track: <State, E, A>(metric: Metric.Metric<Exit.Exit<NoInfer<A>, NoInfer<E>>, State>): <R>(self: Effect<A, E, R>) => Effect<A, E, R>; // overload 2
export declare const track: <A, E, R, Input, State>(self: Effect<A, E, R>, metric: Metric.Metric<Input, State>, f: (exit: Exit.Exit<A, E>) => Input): Effect<A, E, R>; // overload 3
export declare const track: <A, E, R, State>(self: Effect<A, E, R>, metric: Metric.Metric<Exit.Exit<NoInfer<A>, NoInfer<E>>, State>): Effect<A, E, R>; // overload 4
export declare const trackDefects: <Input, State>(metric: Metric.Metric<Input, State>, f: (defect: unknown) => Input): <A, E, R>(self: Effect<A, E, R>) => Effect<A, E, R>; // overload 1
export declare const trackDefects: <State, E>(metric: Metric.Metric<unknown, State>): <A, R>(self: Effect<A, E, R>) => Effect<A, E, R>; // overload 2
export declare const trackDefects: <A, E, R, Input, State>(self: Effect<A, E, R>, metric: Metric.Metric<Input, State>, f: (defect: unknown) => Input): Effect<A, E, R>; // overload 3
export declare const trackDefects: <A, E, R, State>(self: Effect<A, E, R>, metric: Metric.Metric<unknown, State>): Effect<A, E, R>; // overload 4
export declare const trackDuration: <Input, State>(metric: Metric.Metric<Input, State>, f: (duration: Duration.Duration) => Input): <A, E, R>(self: Effect<A, E, R>) => Effect<A, E, R>; // overload 1
export declare const trackDuration: <State, E>(metric: Metric.Metric<Duration.Duration, State>): <A, R>(self: Effect<A, E, R>) => Effect<A, E, R>; // overload 2
export declare const trackDuration: <A, E, R, Input, State>(self: Effect<A, E, R>, metric: Metric.Metric<Input, State>, f: (duration: Duration.Duration) => Input): Effect<A, E, R>; // overload 3
export declare const trackDuration: <A, E, R, State>(self: Effect<A, E, R>, metric: Metric.Metric<Duration.Duration, State>): Effect<A, E, R>; // overload 4
export declare const trackErrors: <Input, State, E>(metric: Metric.Metric<Input, State>, f: (error: E) => Input): <A, R>(self: Effect<A, E, R>) => Effect<A, E, R>; // overload 1
export declare const trackErrors: <State, E>(metric: Metric.Metric<NoInfer<E>, State>): <A, R>(self: Effect<A, E, R>) => Effect<A, E, R>; // overload 2
export declare const trackErrors: <A, E, R, Input, State>(self: Effect<A, E, R>, metric: Metric.Metric<Input, State>, f: (error: E) => Input): Effect<A, E, R>; // overload 3
export declare const trackErrors: <A, E, R, State>(self: Effect<A, E, R>, metric: Metric.Metric<NoInfer<E>, State>): Effect<A, E, R>; // overload 4
export declare const trackSuccesses: <Input, State, A>(metric: Metric.Metric<Input, State>, f: (value: A) => Input): <E, R>(self: Effect<A, E, R>) => Effect<A, E, R>; // overload 1
export declare const trackSuccesses: <State, A>(metric: Metric.Metric<NoInfer<A>, State>): <E, R>(self: Effect<A, E, R>) => Effect<A, E, R>; // overload 2
export declare const trackSuccesses: <A, E, R, Input, State>(self: Effect<A, E, R>, metric: Metric.Metric<Input, State>, f: (value: A) => Input): Effect<A, E, R>; // overload 3
export declare const trackSuccesses: <A, E, R, State>(self: Effect<A, E, R>, metric: Metric.Metric<NoInfer<A>, State>): Effect<A, E, R>; // overload 4
export declare const transaction: <A, E, R>(effect: Effect<A, E, R>): Effect<A, E, Exclude<R, Transaction>>;
export declare const transactionWith: <A, E, R>(f: (state: Transaction["Service"]) => Effect<A, E, R>): Effect<A, E, Exclude<R, Transaction>>;
export declare const try: <A, E>(options: { try: LazyArg<A>; catch: (error: unknown) => E; }): Effect<A, E>;
export declare const tryPromise: <A, E = Cause.UnknownError>(options: { readonly try: (signal: AbortSignal) => PromiseLike<A>; readonly catch: (error: unknown) => E; } | ((signal: AbortSignal) => PromiseLike<A>)): Effect<A, E>;
export declare const uninterruptible: <A, E, R>(self: Effect<A, E, R>): Effect<A, E, R>;
export declare const uninterruptibleMask: <A, E, R>(f: (restore: <AX, EX, RX>(effect: Effect<AX, EX, RX>) => Effect<AX, EX, RX>) => Effect<A, E, R>): Effect<A, E, R>;
export declare const unwrapReason: <K extends TagsWithReason<E>, E>(errorTag: K): <A, R>(self: Effect<A, E, R>) => Effect<A, ExcludeTag<E, K> | ReasonOf<ExtractTag<E, K>>, R>; // overload 1
export declare const unwrapReason: <A, E, R, K extends TagsWithReason<E>>(self: Effect<A, E, R>, errorTag: K): Effect<A, ExcludeTag<E, K> | ReasonOf<ExtractTag<E, K>>, R>; // overload 2
export declare const updateService: <I, A>(service: ServiceMap.Service<I, A>, f: (value: A) => A): <XA, E, R>(self: Effect<XA, E, R>) => Effect<XA, E, R | I>; // overload 1
export declare const updateService: <XA, E, R, I, A>(self: Effect<XA, E, R>, service: ServiceMap.Service<I, A>, f: (value: A) => A): Effect<XA, E, R | I>; // overload 2
export declare const updateServices: <R2, R>(f: (services: ServiceMap.ServiceMap<R2>) => ServiceMap.ServiceMap<NoInfer<R>>): <A, E>(self: Effect<A, E, R>) => Effect<A, E, R2>; // overload 1
export declare const updateServices: <A, E, R, R2>(self: Effect<A, E, R>, f: (services: ServiceMap.ServiceMap<R2>) => ServiceMap.ServiceMap<NoInfer<R>>): Effect<A, E, R2>; // overload 2
export declare const useSpan: <A, E, R>(name: string, evaluate: (span: Span) => Effect<A, E, R>): Effect<A, E, R>; // overload 1
export declare const useSpan: <A, E, R>(name: string, options: SpanOptionsNoTrace, evaluate: (span: Span) => Effect<A, E, R>): Effect<A, E, R>; // overload 2
export declare const when: <E2 = never, R2 = never>(condition: Effect<boolean, E2, R2>): <A, E, R>(self: Effect<A, E, R>) => Effect<Option<A>, E | E2, R | R2>; // overload 1
export declare const when: <A, E, R, E2 = never, R2 = never>(self: Effect<A, E, R>, condition: Effect<boolean, E2, R2>): Effect<Option<A>, E | E2, R | R2>; // overload 2
export declare const whileLoop: <A, E, R>(options: { readonly while: LazyArg<boolean>; readonly body: LazyArg<Effect<A, E, R>>; readonly step: (a: A) => void; }): Effect<void, E, R>;
export declare const withConcurrency: (concurrency: number | "unbounded"): <A, E, R>(self: Effect<A, E, R>) => Effect<A, E, R>; // overload 1
export declare const withConcurrency: <A, E, R>(self: Effect<A, E, R>, concurrency: number | "unbounded"): Effect<A, E, R>; // overload 2
export declare const withExecutionPlan: <Input, Provides, PlanE, PlanR>(plan: ExecutionPlan<{ provides: Provides; input: Input; error: PlanE; requirements: PlanR; }>): <A, E extends Input, R>(effect: Effect<A, E, R>) => Effect<A, E | PlanE, Exclude<R, Provides> | PlanR>; // overload 1
export declare const withExecutionPlan: <A, E extends Input, R, Provides, Input, PlanE, PlanR>(effect: Effect<A, E, R>, plan: ExecutionPlan<{ provides: Provides; input: Input; error: PlanE; requirements: PlanR; }>): Effect<A, E | PlanE, Exclude<R, Provides> | PlanR>; // overload 2
export declare const withFiber: <A, E = never, R = never>(evaluate: (fiber: Fiber<unknown, unknown>) => Effect<A, E, R>): Effect<A, E, R>;
export declare const withLogger: <Output>(logger: Logger<unknown, Output>): <A, E, R>(effect: Effect<A, E, R>) => Effect<A, E, R>; // overload 1
export declare const withLogger: <A, E, R, Output>(effect: Effect<A, E, R>, logger: Logger<unknown, Output>): Effect<A, E, R>; // overload 2
export declare const withLogSpan: (label: string): <A, E, R>(effect: Effect<A, E, R>) => Effect<A, E, R>; // overload 1
export declare const withLogSpan: <A, E, R>(effect: Effect<A, E, R>, label: string): Effect<A, E, R>; // overload 2
export declare const withParentSpan: (value: AnySpan, options?: TraceOptions): <A, E, R>(self: Effect<A, E, R>) => Effect<A, E, Exclude<R, ParentSpan>>; // overload 1
export declare const withParentSpan: <A, E, R>(self: Effect<A, E, R>, value: AnySpan, options?: TraceOptions): Effect<A, E, Exclude<R, ParentSpan>>; // overload 2
export declare const withSpan: <Args extends ReadonlyArray<any>>(name: string, options?: SpanOptionsNoTrace | ((...args: NoInfer<Args>) => SpanOptionsNoTrace) | undefined, traceOptions?: TraceOptions | undefined): <A, E, R>(self: Effect<A, E, R>, ...args: Args) => Effect<A, E, Exclude<R, ParentSpan>>; // overload 1
export declare const withSpan: <A, E, R>(self: Effect<A, E, R>, name: string, options?: SpanOptions | undefined): Effect<A, E, Exclude<R, ParentSpan>>; // overload 2
export declare const withSpanScoped: (name: string, options?: SpanOptions): <A, E, R>(self: Effect<A, E, R>) => Effect<A, E, Exclude<R, ParentSpan> | Scope>; // overload 1
export declare const withSpanScoped: <A, E, R>(self: Effect<A, E, R>, name: string, options?: SpanOptions): Effect<A, E, Exclude<R, ParentSpan> | Scope>; // overload 2
export declare const withTracer: (value: Tracer): <A, E, R>(effect: Effect<A, E, R>) => Effect<A, E, R>; // overload 1
export declare const withTracer: <A, E, R>(effect: Effect<A, E, R>, value: Tracer): Effect<A, E, R>; // overload 2
export declare const withTracerEnabled: (enabled: boolean): <A, E, R>(effect: Effect<A, E, R>) => Effect<A, E, R>; // overload 1
export declare const withTracerEnabled: <A, E, R>(effect: Effect<A, E, R>, enabled: boolean): Effect<A, E, R>; // overload 2
export declare const withTracerTiming: (enabled: boolean): <A, E, R>(effect: Effect<A, E, R>) => Effect<A, E, R>; // overload 1
export declare const withTracerTiming: <A, E, R>(effect: Effect<A, E, R>, enabled: boolean): Effect<A, E, R>; // overload 2
export declare const yieldNowWith: (priority?: number): Effect<void>;
export declare const zip: <A2, E2, R2>(that: Effect<A2, E2, R2>, options?: { readonly concurrent?: boolean | undefined; } | undefined): <A, E, R>(self: Effect<A, E, R>) => Effect<[A, A2], E2 | E, R2 | R>; // overload 1
export declare const zip: <A, E, R, A2, E2, R2>(self: Effect<A, E, R>, that: Effect<A2, E2, R2>, options?: { readonly concurrent?: boolean | undefined; }): Effect<[A, A2], E | E2, R | R2>; // overload 2
export declare const zipWith: <A2, E2, R2, A, B>(that: Effect<A2, E2, R2>, f: (a: A, b: A2) => B, options?: { readonly concurrent?: boolean | undefined; }): <E, R>(self: Effect<A, E, R>) => Effect<B, E2 | E, R2 | R>; // overload 1
export declare const zipWith: <A, E, R, A2, E2, R2, B>(self: Effect<A, E, R>, that: Effect<A2, E2, R2>, f: (a: A, b: A2) => B, options?: { readonly concurrent?: boolean | undefined; }): Effect<B, E2 | E, R2 | R>; // overload 2
```

## Other Exports (Non-Function)

- `All` (namespace)
- `currentParentSpan` (variable)
- `currentSpan` (variable)
- `Effect` (interface)
- `Effectify` (namespace)
- `EffectIterator` (interface)
- `EffectTypeLambda` (interface)
- `EffectUnify` (interface)
- `EffectUnifyIgnore` (interface)
- `Error` (type)
- `fiber` (variable)
- `fiberId` (variable)
- `interrupt` (variable)
- `never` (variable)
- `Repeat` (namespace)
- `Retry` (namespace)
- `retryTransaction` (variable)
- `RunOptions` (interface)
- `scope` (variable)
- `Services` (type)
- `spanAnnotations` (variable)
- `spanLinks` (variable)
- `succeedNone` (variable)
- `Success` (type)
- `TagsWithReason` (type)
- `tracer` (variable)
- `Transaction` (class)
- `undefined` (variable)
- `Variance` (interface)
- `void` (variable)
- `Yieldable` (interface)
- `YieldableClass` (class)
- `yieldNow` (variable)
