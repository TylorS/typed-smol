# API Reference: effect/Effect#concurrency

- Import path: `effect/Effect#concurrency`
- Source file: `packages/effect/src/Effect.ts`
- Thematic facet: `concurrency`
- Function exports (callable): 23
- Non-function exports: 4

## Purpose

The `Effect` module is the core of the Effect library, providing a powerful and expressive way to model and compose asynchronous, concurrent, and effectful computations.

## Key Function Exports

- `fnUntraced`
- `fnUntracedEager`
- `forkChild`
- `forkDetach`
- `forkIn`
- `forkScoped`
- `interruptible`
- `interruptibleMask`
- `logTrace`
- `onInterrupt`
- `race`
- `raceAll`
- `raceAllFirst`
- `raceFirst`
- `runFork`
- `runForkWith`
- `uninterruptible`
- `uninterruptibleMask`

## All Function Signatures

```ts
export declare const fnUntraced: <Eff extends Yieldable<any, any, any, any>, AEff, Args extends Array<any>>(body: (this: unassigned, ...args: Args) => Generator<Eff, AEff, never>): (...args: Args) => Effect<AEff, [Eff] extends [never] ? never : [Eff] extends [Yieldable<infer _S, infer _A, infer E, infer _R>] ? E : never, [Eff] extends [never] ? never : [Eff] extends [Yieldable<infer _S, infer _A, infer _E, infer R>] ? R : never>; // overload 1
export declare const fnUntraced: <Self, Eff extends Yieldable<any, any, any, any>, AEff, Args extends Array<any>>(body: (this: Self, ...args: Args) => Generator<Eff, AEff, never>): (this: Self, ...args: Args) => Effect<AEff, [Eff] extends [never] ? never : [Eff] extends [Yieldable<infer _S, infer _A, infer E, infer _R>] ? E : never, [Eff] extends [never] ? never : [Eff] extends [Yieldable<infer _S, infer _A, infer _E, infer R>] ? R : never>; // overload 2
export declare const fnUntraced: <Eff extends Yieldable<any, any, any, any>, AEff, Args extends Array<any>, A>(body: (this: unassigned, ...args: Args) => Generator<Eff, AEff, never>, a: (_: Effect<AEff, [Eff] extends [never] ? never : [Eff] extends [Yieldable<infer _S, infer _A, infer E, infer _R>] ? E : never, [Eff] extends [never] ? never : [Eff] extends [Yieldable<infer _S, infer _A, infer _E, infer R>] ? R : never>, ...args: Args) => A): (...args: Args) => A; // overload 3
export declare const fnUntraced: <Self, Eff extends Yieldable<any, any, any, any>, AEff, Args extends Array<any>, A>(body: (this: Self, ...args: Args) => Generator<Eff, AEff, never>, a: (_: Effect<AEff, [Eff] extends [never] ? never : [Eff] extends [Yieldable<infer _S, infer _A, infer E, infer _R>] ? E : never, [Eff] extends [never] ? never : [Eff] extends [Yieldable<infer _S, infer _A, infer _E, infer R>] ? R : never>, ...args: Args) => A): (this: Self, ...args: Args) => A; // overload 4
export declare const fnUntraced: <Eff extends Yieldable<any, any, any, any>, AEff, Args extends Array<any>, A, B>(body: (this: unassigned, ...args: Args) => Generator<Eff, AEff, never>, a: (_: Effect<AEff, [Eff] extends [never] ? never : [Eff] extends [Yieldable<infer _S, infer _A, infer E, infer _R>] ? E : never, [Eff] extends [never] ? never : [Eff] extends [Yieldable<infer _S, infer _A, infer _E, infer R>] ? R : never>, ...args: Args) => A, b: (_: A, ...args: Args) => B): (...args: Args) => B; // overload 5
export declare const fnUntraced: <Self, Eff extends Yieldable<any, any, any, any>, AEff, Args extends Array<any>, A, B>(body: (this: Self, ...args: Args) => Generator<Eff, AEff, never>, a: (_: Effect<AEff, [Eff] extends [never] ? never : [Eff] extends [Yieldable<infer _S, infer _A, infer E, infer _R>] ? E : never, [Eff] extends [never] ? never : [Eff] extends [Yieldable<infer _S, infer _A, infer _E, infer R>] ? R : never>, ...args: Args) => A, b: (_: A, ...args: Args) => B): (this: Self, ...args: Args) => B; // overload 6
export declare const fnUntraced: <Eff extends Yieldable<any, any, any, any>, AEff, Args extends Array<any>, A, B, C>(body: (this: unassigned, ...args: Args) => Generator<Eff, AEff, never>, a: (_: Effect<AEff, [Eff] extends [never] ? never : [Eff] extends [Yieldable<infer _S, infer _A, infer E, infer _R>] ? E : never, [Eff] extends [never] ? never : [Eff] extends [Yieldable<infer _S, infer _A, infer _E, infer R>] ? R : never>, ...args: Args) => A, b: (_: A, ...args: Args) => B, c: (_: B, ...args: Args) => C): (...args: Args) => C; // overload 7
export declare const fnUntraced: <Self, Eff extends Yieldable<any, any, any, any>, AEff, Args extends Array<any>, A, B, C>(body: (this: Self, ...args: Args) => Generator<Eff, AEff, never>, a: (_: Effect<AEff, [Eff] extends [never] ? never : [Eff] extends [Yieldable<infer _S, infer _A, infer E, infer _R>] ? E : never, [Eff] extends [never] ? never : [Eff] extends [Yieldable<infer _S, infer _A, infer _E, infer R>] ? R : never>, ...args: Args) => A, b: (_: A, ...args: Args) => B, c: (_: B, ...args: Args) => C): (this: Self, ...args: Args) => C; // overload 8
export declare const fnUntraced: <Eff extends Yieldable<any, any, any, any>, AEff, Args extends Array<any>, A, B, C, D>(body: (...args: Args) => Generator<Eff, AEff, never>, a: (_: Effect<AEff, [Eff] extends [never] ? never : [Eff] extends [Yieldable<infer _S, infer _A, infer E, infer _R>] ? E : never, [Eff] extends [never] ? never : [Eff] extends [Yieldable<infer _S, infer _A, infer _E, infer R>] ? R : never>, ...args: Args) => A, b: (_: A, ...args: Args) => B, c: (_: B, ...args: Args) => C, d: (_: C, ...args: Args) => D): (...args: Args) => D; // overload 9
export declare const fnUntraced: <Self, Eff extends Yieldable<any, any, any, any>, AEff, Args extends Array<any>, A, B, C, D>(body: (this: Self, ...args: Args) => Generator<Eff, AEff, never>, a: (_: Effect<AEff, [Eff] extends [never] ? never : [Eff] extends [Yieldable<infer _S, infer _A, infer E, infer _R>] ? E : never, [Eff] extends [never] ? never : [Eff] extends [Yieldable<infer _S, infer _A, infer _E, infer R>] ? R : never>, ...args: Args) => A, b: (_: A, ...args: Args) => B, c: (_: B, ...args: Args) => C, d: (_: C, ...args: Args) => D): (this: Self, ...args: Args) => D; // overload 10
export declare const fnUntraced: <Eff extends Yieldable<any, any, any, any>, AEff, Args extends Array<any>, A, B, C, D, E>(body: (this: unassigned, ...args: Args) => Generator<Eff, AEff, never>, a: (_: Effect<AEff, [Eff] extends [never] ? never : [Eff] extends [Yieldable<infer _S, infer _A, infer E, infer _R>] ? E : never, [Eff] extends [never] ? never : [Eff] extends [Yieldable<infer _S, infer _A, infer _E, infer R>] ? R : never>, ...args: Args) => A, b: (_: A, ...args: Args) => B, c: (_: B, ...args: Args) => C, d: (_: C, ...args: Args) => D, e: (_: D, ...args: Args) => E): (...args: Args) => E; // overload 11
export declare const fnUntraced: <Self, Eff extends Yieldable<any, any, any, any>, AEff, Args extends Array<any>, A, B, C, D, E>(body: (this: Self, ...args: Args) => Generator<Eff, AEff, never>, a: (_: Effect<AEff, [Eff] extends [never] ? never : [Eff] extends [Yieldable<infer _S, infer _A, infer E, infer _R>] ? E : never, [Eff] extends [never] ? never : [Eff] extends [Yieldable<infer _S, infer _A, infer _E, infer R>] ? R : never>, ...args: Args) => A, b: (_: A, ...args: Args) => B, c: (_: B, ...args: Args) => C, d: (_: C, ...args: Args) => D, e: (_: D, ...args: Args) => E): (this: Self, ...args: Args) => E; // overload 12
export declare const fnUntraced: <Eff extends Yieldable<any, any, any, any>, AEff, Args extends Array<any>, A, B, C, D, E, F>(body: (this: unassigned, ...args: Args) => Generator<Eff, AEff, never>, a: (_: Effect<AEff, [Eff] extends [never] ? never : [Eff] extends [Yieldable<infer _S, infer _A, infer E, infer _R>] ? E : never, [Eff] extends [never] ? never : [Eff] extends [Yieldable<infer _S, infer _A, infer _E, infer R>] ? R : never>, ...args: Args) => A, b: (_: A, ...args: Args) => B, c: (_: B, ...args: Args) => C, d: (_: C, ...args: Args) => D, e: (_: D, ...args: Args) => E, f: (_: E, ...args: Args) => F): (...args: Args) => F; // overload 13
export declare const fnUntraced: <Self, Eff extends Yieldable<any, any, any, any>, AEff, Args extends Array<any>, A, B, C, D, E, F>(body: (this: Self, ...args: Args) => Generator<Eff, AEff, never>, a: (_: Effect<AEff, [Eff] extends [never] ? never : [Eff] extends [Yieldable<infer _S, infer _A, infer E, infer _R>] ? E : never, [Eff] extends [never] ? never : [Eff] extends [Yieldable<infer _S, infer _A, infer _E, infer R>] ? R : never>, ...args: Args) => A, b: (_: A, ...args: Args) => B, c: (_: B, ...args: Args) => C, d: (_: C, ...args: Args) => D, e: (_: D, ...args: Args) => E, f: (_: E, ...args: Args) => F): (this: Self, ...args: Args) => F; // overload 14
export declare const fnUntraced: <Eff extends Yieldable<any, any, any, any>, AEff, Args extends Array<any>, A, B, C, D, E, F, G>(body: (this: unassigned, ...args: Args) => Generator<Eff, AEff, never>, a: (_: Effect<AEff, [Eff] extends [never] ? never : [Eff] extends [Yieldable<infer _S, infer _A, infer E, infer _R>] ? E : never, [Eff] extends [never] ? never : [Eff] extends [Yieldable<infer _S, infer _A, infer _E, infer R>] ? R : never>, ...args: Args) => A, b: (_: A, ...args: Args) => B, c: (_: B, ...args: Args) => C, d: (_: C, ...args: Args) => D, e: (_: D, ...args: Args) => E, f: (_: E, ...args: Args) => F, g: (_: F, ...args: Args) => G): (...args: Args) => G; // overload 15
export declare const fnUntraced: <Self, Eff extends Yieldable<any, any, any, any>, AEff, Args extends Array<any>, A, B, C, D, E, F, G>(body: (this: Self, ...args: Args) => Generator<Eff, AEff, never>, a: (_: Effect<AEff, [Eff] extends [never] ? never : [Eff] extends [Yieldable<infer _S, infer _A, infer E, infer _R>] ? E : never, [Eff] extends [never] ? never : [Eff] extends [Yieldable<infer _S, infer _A, infer _E, infer R>] ? R : never>, ...args: Args) => A, b: (_: A, ...args: Args) => B, c: (_: B, ...args: Args) => C, d: (_: C, ...args: Args) => D, e: (_: D, ...args: Args) => E, f: (_: E, ...args: Args) => F, g: (_: F, ...args: Args) => G): (this: Self, ...args: Args) => G; // overload 16
export declare const fnUntraced: <Eff extends Yieldable<any, any, any, any>, AEff, Args extends Array<any>, A, B, C, D, E, F, G, H>(body: (this: unassigned, ...args: Args) => Generator<Eff, AEff, never>, a: (_: Effect<AEff, [Eff] extends [never] ? never : [Eff] extends [Yieldable<infer _S, infer _A, infer E, infer _R>] ? E : never, [Eff] extends [never] ? never : [Eff] extends [Yieldable<infer _S, infer _A, infer _E, infer R>] ? R : never>, ...args: Args) => A, b: (_: A, ...args: Args) => B, c: (_: B, ...args: Args) => C, d: (_: C, ...args: Args) => D, e: (_: D, ...args: Args) => E, f: (_: E, ...args: Args) => F, g: (_: F, ...args: Args) => G, h: (_: G, ...args: Args) => H): (...args: Args) => H; // overload 17
export declare const fnUntraced: <Self, Eff extends Yieldable<any, any, any, any>, AEff, Args extends Array<any>, A, B, C, D, E, F, G, H>(body: (this: Self, ...args: Args) => Generator<Eff, AEff, never>, a: (_: Effect<AEff, [Eff] extends [never] ? never : [Eff] extends [Yieldable<infer _S, infer _A, infer E, infer _R>] ? E : never, [Eff] extends [never] ? never : [Eff] extends [Yieldable<infer _S, infer _A, infer _E, infer R>] ? R : never>, ...args: Args) => A, b: (_: A, ...args: Args) => B, c: (_: B, ...args: Args) => C, d: (_: C, ...args: Args) => D, e: (_: D, ...args: Args) => E, f: (_: E, ...args: Args) => F, g: (_: F, ...args: Args) => G, h: (_: G, ...args: Args) => H): (this: Self, ...args: Args) => H; // overload 18
export declare const fnUntraced: <Eff extends Yieldable<any, any, any, any>, AEff, Args extends Array<any>, A, B, C, D, E, F, G, H, I>(body: (this: unassigned, ...args: Args) => Generator<Eff, AEff, never>, a: (_: Effect<AEff, [Eff] extends [never] ? never : [Eff] extends [Yieldable<infer _S, infer _A, infer E, infer _R>] ? E : never, [Eff] extends [never] ? never : [Eff] extends [Yieldable<infer _S, infer _A, infer _E, infer R>] ? R : never>, ...args: Args) => A, b: (_: A, ...args: Args) => B, c: (_: B, ...args: Args) => C, d: (_: C, ...args: Args) => D, e: (_: D, ...args: Args) => E, f: (_: E, ...args: Args) => F, g: (_: F, ...args: Args) => G, h: (_: G, ...args: Args) => H, i: (_: H, ...args: Args) => I): (...args: Args) => I; // overload 19
export declare const fnUntraced: <Self, Eff extends Yieldable<any, any, any, any>, AEff, Args extends Array<any>, A, B, C, D, E, F, G, H, I>(body: (this: Self, ...args: Args) => Generator<Eff, AEff, never>, a: (_: Effect<AEff, [Eff] extends [never] ? never : [Eff] extends [Yieldable<infer _S, infer _A, infer E, infer _R>] ? E : never, [Eff] extends [never] ? never : [Eff] extends [Yieldable<infer _S, infer _A, infer _E, infer R>] ? R : never>, ...args: Args) => A, b: (_: A, ...args: Args) => B, c: (_: B, ...args: Args) => C, d: (_: C, ...args: Args) => D, e: (_: D, ...args: Args) => E, f: (_: E, ...args: Args) => F, g: (_: F, ...args: Args) => G, h: (_: G, ...args: Args) => H, i: (_: H, ...args: Args) => I): (this: Self, ...args: Args) => I; // overload 20
export declare const fnUntraced: <Eff extends Yieldable<any, any, any, any>, AEff, Args extends Array<any>, A, B, C, D, E, F, G, H, I, J>(body: (this: unassigned, ...args: Args) => Generator<Eff, AEff, never>, a: (_: Effect<AEff, [Eff] extends [never] ? never : [Eff] extends [Yieldable<infer _S, infer _A, infer E, infer _R>] ? E : never, [Eff] extends [never] ? never : [Eff] extends [Yieldable<infer _S, infer _A, infer _E, infer R>] ? R : never>, ...args: Args) => A, b: (_: A, ...args: Args) => B, c: (_: B, ...args: Args) => C, d: (_: C, ...args: Args) => D, e: (_: D, ...args: Args) => E, f: (_: E, ...args: Args) => F, g: (_: F, ...args: Args) => G, h: (_: G, ...args: Args) => H, i: (_: H, ...args: Args) => I, j: (_: I, ...args: Args) => J): (...args: Args) => J; // overload 21
export declare const fnUntraced: <Self, Eff extends Yieldable<any, any, any, any>, AEff, Args extends Array<any>, A, B, C, D, E, F, G, H, I, J>(body: (this: Self, ...args: Args) => Generator<Eff, AEff, never>, a: (_: Effect<AEff, [Eff] extends [never] ? never : [Eff] extends [Yieldable<infer _S, infer _A, infer E, infer _R>] ? E : never, [Eff] extends [never] ? never : [Eff] extends [Yieldable<infer _S, infer _A, infer _E, infer R>] ? R : never>, ...args: Args) => A, b: (_: A, ...args: Args) => B, c: (_: B, ...args: Args) => C, d: (_: C, ...args: Args) => D, e: (_: D, ...args: Args) => E, f: (_: E, ...args: Args) => F, g: (_: F, ...args: Args) => G, h: (_: G, ...args: Args) => H, i: (_: H, ...args: Args) => I, j: (_: I, ...args: Args) => J): (this: Self, ...args: Args) => J; // overload 22
export declare const fnUntraced: <Eff extends Yieldable<any, any, any, any>, AEff, Args extends Array<any>, A, B, C, D, E, F, G, H, I, J, K>(body: (this: unassigned, ...args: Args) => Generator<Eff, AEff, never>, a: (_: Effect<AEff, [Eff] extends [never] ? never : [Eff] extends [Yieldable<infer _S, infer _A, infer E, infer _R>] ? E : never, [Eff] extends [never] ? never : [Eff] extends [Yieldable<infer _S, infer _A, infer _E, infer R>] ? R : never>, ...args: Args) => A, b: (_: A, ...args: Args) => B, c: (_: B, ...args: Args) => C, d: (_: C, ...args: Args) => D, e: (_: D, ...args: Args) => E, f: (_: E, ...args: Args) => F, g: (_: F, ...args: Args) => G, h: (_: G, ...args: Args) => H, i: (_: H, ...args: Args) => I, j: (_: I, ...args: Args) => J, k: (_: J, ...args: Args) => K): (...args: Args) => K; // overload 23
export declare const fnUntraced: <Self, Eff extends Yieldable<any, any, any, any>, AEff, Args extends Array<any>, A, B, C, D, E, F, G, H, I, J, K>(body: (this: Self, ...args: Args) => Generator<Eff, AEff, never>, a: (_: Effect<AEff, [Eff] extends [never] ? never : [Eff] extends [Yieldable<infer _S, infer _A, infer E, infer _R>] ? E : never, [Eff] extends [never] ? never : [Eff] extends [Yieldable<infer _S, infer _A, infer _E, infer R>] ? R : never>, ...args: Args) => A, b: (_: A, ...args: Args) => B, c: (_: B, ...args: Args) => C, d: (_: C, ...args: Args) => D, e: (_: D, ...args: Args) => E, f: (_: E, ...args: Args) => F, g: (_: F, ...args: Args) => G, h: (_: G, ...args: Args) => H, i: (_: H, ...args: Args) => I, j: (_: I, ...args: Args) => J, k: (_: J, ...args: Args) => K): (this: Self, ...args: Args) => K; // overload 24
export declare const fnUntraced: <Eff extends Yieldable<any, any, any, any>, AEff, Args extends Array<any>, A, B, C, D, E, F, G, H, I, J, K, L>(body: (this: unassigned, ...args: Args) => Generator<Eff, AEff, never>, a: (_: Effect<AEff, [Eff] extends [never] ? never : [Eff] extends [Yieldable<infer _S, infer _A, infer E, infer _R>] ? E : never, [Eff] extends [never] ? never : [Eff] extends [Yieldable<infer _S, infer _A, infer _E, infer R>] ? R : never>, ...args: Args) => A, b: (_: A, ...args: Args) => B, c: (_: B, ...args: Args) => C, d: (_: C, ...args: Args) => D, e: (_: D, ...args: Args) => E, f: (_: E, ...args: Args) => F, g: (_: F, ...args: Args) => G, h: (_: G, ...args: Args) => H, i: (_: H, ...args: Args) => I, j: (_: I, ...args: Args) => J, k: (_: J, ...args: Args) => K, l: (_: K, ...args: Args) => L): (...args: Args) => L; // overload 25
export declare const fnUntraced: <Self, Eff extends Yieldable<any, any, any, any>, AEff, Args extends Array<any>, A, B, C, D, E, F, G, H, I, J, K, L>(body: (this: Self, ...args: Args) => Generator<Eff, AEff, never>, a: (_: Effect<AEff, [Eff] extends [never] ? never : [Eff] extends [Yieldable<infer _S, infer _A, infer E, infer _R>] ? E : never, [Eff] extends [never] ? never : [Eff] extends [Yieldable<infer _S, infer _A, infer _E, infer R>] ? R : never>, ...args: Args) => A, b: (_: A, ...args: Args) => B, c: (_: B, ...args: Args) => C, d: (_: C, ...args: Args) => D, e: (_: D, ...args: Args) => E, f: (_: E, ...args: Args) => F, g: (_: F, ...args: Args) => G, h: (_: G, ...args: Args) => H, i: (_: H, ...args: Args) => I, j: (_: I, ...args: Args) => J, k: (_: J, ...args: Args) => K, l: (_: K, ...args: Args) => L): (this: Self, ...args: Args) => L; // overload 26
export declare const fnUntraced: <Eff extends Yieldable<any, any, any, any>, AEff, Args extends Array<any>, A, B, C, D, E, F, G, H, I, J, K, L, M>(body: (this: unassigned, ...args: Args) => Generator<Eff, AEff, never>, a: (_: Effect<AEff, [Eff] extends [never] ? never : [Eff] extends [Yieldable<infer _S, infer _A, infer E, infer _R>] ? E : never, [Eff] extends [never] ? never : [Eff] extends [Yieldable<infer _S, infer _A, infer _E, infer R>] ? R : never>, ...args: Args) => A, b: (_: A, ...args: Args) => B, c: (_: B, ...args: Args) => C, d: (_: C, ...args: Args) => D, e: (_: D, ...args: Args) => E, f: (_: E, ...args: Args) => F, g: (_: F, ...args: Args) => G, h: (_: G, ...args: Args) => H, i: (_: H, ...args: Args) => I, j: (_: I, ...args: Args) => J, k: (_: J, ...args: Args) => K, l: (_: K, ...args: Args) => L, m: (_: L, ...args: Args) => M): (...args: Args) => M; // overload 27
export declare const fnUntraced: <Self, Eff extends Yieldable<any, any, any, any>, AEff, Args extends Array<any>, A, B, C, D, E, F, G, H, I, J, K, L, M>(body: (this: Self, ...args: Args) => Generator<Eff, AEff, never>, a: (_: Effect<AEff, [Eff] extends [never] ? never : [Eff] extends [Yieldable<infer _S, infer _A, infer E, infer _R>] ? E : never, [Eff] extends [never] ? never : [Eff] extends [Yieldable<infer _S, infer _A, infer _E, infer R>] ? R : never>, ...args: Args) => A, b: (_: A, ...args: Args) => B, c: (_: B, ...args: Args) => C, d: (_: C, ...args: Args) => D, e: (_: D, ...args: Args) => E, f: (_: E, ...args: Args) => F, g: (_: F, ...args: Args) => G, h: (_: G, ...args: Args) => H, i: (_: H, ...args: Args) => I, j: (_: I, ...args: Args) => J, k: (_: J, ...args: Args) => K, l: (_: K, ...args: Args) => L, m: (_: L, ...args: Args) => M): (this: Self, ...args: Args) => M; // overload 28
export declare const fnUntraced: <Eff extends Yieldable<any, any, any, any>, AEff, Args extends Array<any>, A, B, C, D, E, F, G, H, I, J, K, L, M, N>(body: (this: unassigned, ...args: Args) => Generator<Eff, AEff, never>, a: (_: Effect<AEff, [Eff] extends [never] ? never : [Eff] extends [Yieldable<infer _S, infer _A, infer E, infer _R>] ? E : never, [Eff] extends [never] ? never : [Eff] extends [Yieldable<infer _S, infer _A, infer _E, infer R>] ? R : never>, ...args: Args) => A, b: (_: A, ...args: Args) => B, c: (_: B, ...args: Args) => C, d: (_: C, ...args: Args) => D, e: (_: D, ...args: Args) => E, f: (_: E, ...args: Args) => F, g: (_: F, ...args: Args) => G, h: (_: G, ...args: Args) => H, i: (_: H, ...args: Args) => I, j: (_: I, ...args: Args) => J, k: (_: J, ...args: Args) => K, l: (_: K, ...args: Args) => L, m: (_: L, ...args: Args) => M, n: (_: M, ...args: Args) => N): (...args: Args) => N; // overload 29
export declare const fnUntraced: <Self, Eff extends Yieldable<any, any, any, any>, AEff, Args extends Array<any>, A, B, C, D, E, F, G, H, I, J, K, L, M, N>(body: (this: Self, ...args: Args) => Generator<Eff, AEff, never>, a: (_: Effect<AEff, [Eff] extends [never] ? never : [Eff] extends [Yieldable<infer _S, infer _A, infer E, infer _R>] ? E : never, [Eff] extends [never] ? never : [Eff] extends [Yieldable<infer _S, infer _A, infer _E, infer R>] ? R : never>, ...args: Args) => A, b: (_: A, ...args: Args) => B, c: (_: B, ...args: Args) => C, d: (_: C, ...args: Args) => D, e: (_: D, ...args: Args) => E, f: (_: E, ...args: Args) => F, g: (_: F, ...args: Args) => G, h: (_: G, ...args: Args) => H, i: (_: H, ...args: Args) => I, j: (_: I, ...args: Args) => J, k: (_: J, ...args: Args) => K, l: (_: K, ...args: Args) => L, m: (_: L, ...args: Args) => M, n: (_: M, ...args: Args) => N): (this: Self, ...args: Args) => N; // overload 30
export declare const fnUntraced: <Eff extends Yieldable<any, any, any, any>, AEff, Args extends Array<any>, A, B, C, D, E, F, G, H, I, J, K, L, M, N, O>(body: (this: unassigned, ...args: Args) => Generator<Eff, AEff, never>, a: (_: Effect<AEff, [Eff] extends [never] ? never : [Eff] extends [Yieldable<infer _S, infer _A, infer E, infer _R>] ? E : never, [Eff] extends [never] ? never : [Eff] extends [Yieldable<infer _S, infer _A, infer _E, infer R>] ? R : never>, ...args: Args) => A, b: (_: A, ...args: Args) => B, c: (_: B, ...args: Args) => C, d: (_: C, ...args: Args) => D, e: (_: D, ...args: Args) => E, f: (_: E, ...args: Args) => F, g: (_: F, ...args: Args) => G, h: (_: G, ...args: Args) => H, i: (_: H, ...args: Args) => I, j: (_: I, ...args: Args) => J, k: (_: J, ...args: Args) => K, l: (_: K, ...args: Args) => L, m: (_: L, ...args: Args) => M, n: (_: M, ...args: Args) => N, o: (_: N, ...args: Args) => O): (...args: Args) => O; // overload 31
export declare const fnUntraced: <Self, Eff extends Yieldable<any, any, any, any>, AEff, Args extends Array<any>, A, B, C, D, E, F, G, H, I, J, K, L, M, N, O>(body: (this: Self, ...args: Args) => Generator<Eff, AEff, never>, a: (_: Effect<AEff, [Eff] extends [never] ? never : [Eff] extends [Yieldable<infer _S, infer _A, infer E, infer _R>] ? E : never, [Eff] extends [never] ? never : [Eff] extends [Yieldable<infer _S, infer _A, infer _E, infer R>] ? R : never>, ...args: Args) => A, b: (_: A, ...args: Args) => B, c: (_: B, ...args: Args) => C, d: (_: C, ...args: Args) => D, e: (_: D, ...args: Args) => E, f: (_: E, ...args: Args) => F, g: (_: F, ...args: Args) => G, h: (_: G, ...args: Args) => H, i: (_: H, ...args: Args) => I, j: (_: I, ...args: Args) => J, k: (_: J, ...args: Args) => K, l: (_: K, ...args: Args) => L, m: (_: L, ...args: Args) => M, n: (_: M, ...args: Args) => N, o: (_: N, ...args: Args) => O): (this: Self, ...args: Args) => O; // overload 32
export declare const fnUntraced: <Eff extends Yieldable<any, any, any, any>, AEff, Args extends Array<any>, A, B, C, D, E, F, G, H, I, J, K, L, M, N, O, P>(body: (this: unassigned, ...args: Args) => Generator<Eff, AEff, never>, a: (_: Effect<AEff, [Eff] extends [never] ? never : [Eff] extends [Yieldable<infer _S, infer _A, infer E, infer _R>] ? E : never, [Eff] extends [never] ? never : [Eff] extends [Yieldable<infer _S, infer _A, infer _E, infer R>] ? R : never>, ...args: Args) => A, b: (_: A, ...args: Args) => B, c: (_: B, ...args: Args) => C, d: (_: C, ...args: Args) => D, e: (_: D, ...args: Args) => E, f: (_: E, ...args: Args) => F, g: (_: F, ...args: Args) => G, h: (_: G, ...args: Args) => H, i: (_: H, ...args: Args) => I, j: (_: I, ...args: Args) => J, k: (_: J, ...args: Args) => K, l: (_: K, ...args: Args) => L, m: (_: L, ...args: Args) => M, n: (_: M, ...args: Args) => N, o: (_: N, ...args: Args) => O, p: (_: O, ...args: Args) => P): (...args: Args) => P; // overload 33
export declare const fnUntraced: <Self, Eff extends Yieldable<any, any, any, any>, AEff, Args extends Array<any>, A, B, C, D, E, F, G, H, I, J, K, L, M, N, O, P>(body: (this: Self, ...args: Args) => Generator<Eff, AEff, never>, a: (_: Effect<AEff, [Eff] extends [never] ? never : [Eff] extends [Yieldable<infer _S, infer _A, infer E, infer _R>] ? E : never, [Eff] extends [never] ? never : [Eff] extends [Yieldable<infer _S, infer _A, infer _E, infer R>] ? R : never>, ...args: Args) => A, b: (_: A, ...args: Args) => B, c: (_: B, ...args: Args) => C, d: (_: C, ...args: Args) => D, e: (_: D, ...args: Args) => E, f: (_: E, ...args: Args) => F, g: (_: F, ...args: Args) => G, h: (_: G, ...args: Args) => H, i: (_: H, ...args: Args) => I, j: (_: I, ...args: Args) => J, k: (_: J, ...args: Args) => K, l: (_: K, ...args: Args) => L, m: (_: L, ...args: Args) => M, n: (_: M, ...args: Args) => N, o: (_: N, ...args: Args) => O, p: (_: O, ...args: Args) => P): (this: Self, ...args: Args) => P; // overload 34
export declare const fnUntraced: <Eff extends Yieldable<any, any, any, any>, AEff, Args extends Array<any>, A, B, C, D, E, F, G, H, I, J, K, L, M, N, O, P, Q>(body: (this: unassigned, ...args: Args) => Generator<Eff, AEff, never>, a: (_: Effect<AEff, [Eff] extends [never] ? never : [Eff] extends [Yieldable<infer _S, infer _A, infer E, infer _R>] ? E : never, [Eff] extends [never] ? never : [Eff] extends [Yieldable<infer _S, infer _A, infer _E, infer R>] ? R : never>, ...args: Args) => A, b: (_: A, ...args: Args) => B, c: (_: B, ...args: Args) => C, d: (_: C, ...args: Args) => D, e: (_: D, ...args: Args) => E, f: (_: E, ...args: Args) => F, g: (_: F, ...args: Args) => G, h: (_: G, ...args: Args) => H, i: (_: H, ...args: Args) => I, j: (_: I, ...args: Args) => J, k: (_: J, ...args: Args) => K, l: (_: K, ...args: Args) => L, m: (_: L, ...args: Args) => M, n: (_: M, ...args: Args) => N, o: (_: N, ...args: Args) => O, p: (_: O, ...args: Args) => P, q: (_: P, ...args: Args) => Q): (...args: Args) => Q; // overload 35
export declare const fnUntraced: <Self, Eff extends Yieldable<any, any, any, any>, AEff, Args extends Array<any>, A, B, C, D, E, F, G, H, I, J, K, L, M, N, O, P, Q>(body: (this: Self, ...args: Args) => Generator<Eff, AEff, never>, a: (_: Effect<AEff, [Eff] extends [never] ? never : [Eff] extends [Yieldable<infer _S, infer _A, infer E, infer _R>] ? E : never, [Eff] extends [never] ? never : [Eff] extends [Yieldable<infer _S, infer _A, infer _E, infer R>] ? R : never>, ...args: Args) => A, b: (_: A, ...args: Args) => B, c: (_: B, ...args: Args) => C, d: (_: C, ...args: Args) => D, e: (_: D, ...args: Args) => E, f: (_: E, ...args: Args) => F, g: (_: F, ...args: Args) => G, h: (_: G, ...args: Args) => H, i: (_: H, ...args: Args) => I, j: (_: I, ...args: Args) => J, k: (_: J, ...args: Args) => K, l: (_: K, ...args: Args) => L, m: (_: L, ...args: Args) => M, n: (_: M, ...args: Args) => N, o: (_: N, ...args: Args) => O, p: (_: O, ...args: Args) => P, q: (_: P, ...args: Args) => Q): (this: Self, ...args: Args) => Q; // overload 36
export declare const fnUntraced: <Eff extends Yieldable<any, any, any, any>, AEff, Args extends Array<any>, A, B, C, D, E, F, G, H, I, J, K, L, M, N, O, P, Q, R>(body: (this: unassigned, ...args: Args) => Generator<Eff, AEff, never>, a: (_: Effect<AEff, [Eff] extends [never] ? never : [Eff] extends [Yieldable<infer _S, infer _A, infer E, infer _R>] ? E : never, [Eff] extends [never] ? never : [Eff] extends [Yieldable<infer _S, infer _A, infer _E, infer R>] ? R : never>, ...args: Args) => A, b: (_: A, ...args: Args) => B, c: (_: B, ...args: Args) => C, d: (_: C, ...args: Args) => D, e: (_: D, ...args: Args) => E, f: (_: E, ...args: Args) => F, g: (_: F, ...args: Args) => G, h: (_: G, ...args: Args) => H, i: (_: H, ...args: Args) => I, j: (_: I, ...args: Args) => J, k: (_: J, ...args: Args) => K, l: (_: K, ...args: Args) => L, m: (_: L, ...args: Args) => M, n: (_: M, ...args: Args) => N, o: (_: N, ...args: Args) => O, p: (_: O, ...args: Args) => P, q: (_: P, ...args: Args) => Q, r: (_: Q, ...args: Args) => R): (...args: Args) => R; // overload 37
export declare const fnUntraced: <Self, Eff extends Yieldable<any, any, any, any>, AEff, Args extends Array<any>, A, B, C, D, E, F, G, H, I, J, K, L, M, N, O, P, Q, R>(body: (this: Self, ...args: Args) => Generator<Eff, AEff, never>, a: (_: Effect<AEff, [Eff] extends [never] ? never : [Eff] extends [Yieldable<infer _S, infer _A, infer E, infer _R>] ? E : never, [Eff] extends [never] ? never : [Eff] extends [Yieldable<infer _S, infer _A, infer _E, infer R>] ? R : never>, ...args: Args) => A, b: (_: A, ...args: Args) => B, c: (_: B, ...args: Args) => C, d: (_: C, ...args: Args) => D, e: (_: D, ...args: Args) => E, f: (_: E, ...args: Args) => F, g: (_: F, ...args: Args) => G, h: (_: G, ...args: Args) => H, i: (_: H, ...args: Args) => I, j: (_: I, ...args: Args) => J, k: (_: J, ...args: Args) => K, l: (_: K, ...args: Args) => L, m: (_: L, ...args: Args) => M, n: (_: M, ...args: Args) => N, o: (_: N, ...args: Args) => O, p: (_: O, ...args: Args) => P, q: (_: P, ...args: Args) => Q, r: (_: Q, ...args: Args) => R): (this: Self, ...args: Args) => R; // overload 38
export declare const fnUntraced: <Eff extends Yieldable<any, any, any, any>, AEff, Args extends Array<any>, A, B, C, D, E, F, G, H, I, J, K, L, M, N, O, P, Q, R, S>(body: (this: unassigned, ...args: Args) => Generator<Eff, AEff, never>, a: (_: Effect<AEff, [Eff] extends [never] ? never : [Eff] extends [Yieldable<infer _S, infer _A, infer E, infer _R>] ? E : never, [Eff] extends [never] ? never : [Eff] extends [Yieldable<infer _S, infer _A, infer _E, infer R>] ? R : never>, ...args: Args) => A, b: (_: A, ...args: Args) => B, c: (_: B, ...args: Args) => C, d: (_: C, ...args: Args) => D, e: (_: D, ...args: Args) => E, f: (_: E, ...args: Args) => F, g: (_: F, ...args: Args) => G, h: (_: G, ...args: Args) => H, i: (_: H, ...args: Args) => I, j: (_: I, ...args: Args) => J, k: (_: J, ...args: Args) => K, l: (_: K, ...args: Args) => L, m: (_: L, ...args: Args) => M, n: (_: M, ...args: Args) => N, o: (_: N, ...args: Args) => O, p: (_: O, ...args: Args) => P, q: (_: P, ...args: Args) => Q, r: (_: Q, ...args: Args) => R, s: (_: R, ...args: Args) => S): (...args: Args) => S; // overload 39
export declare const fnUntraced: <Self, Eff extends Yieldable<any, any, any, any>, AEff, Args extends Array<any>, A, B, C, D, E, F, G, H, I, J, K, L, M, N, O, P, Q, R, S>(body: (this: Self, ...args: Args) => Generator<Eff, AEff, never>, a: (_: Effect<AEff, [Eff] extends [never] ? never : [Eff] extends [Yieldable<infer _S, infer _A, infer E, infer _R>] ? E : never, [Eff] extends [never] ? never : [Eff] extends [Yieldable<infer _S, infer _A, infer _E, infer R>] ? R : never>, ...args: Args) => A, b: (_: A, ...args: Args) => B, c: (_: B, ...args: Args) => C, d: (_: C, ...args: Args) => D, e: (_: D, ...args: Args) => E, f: (_: E, ...args: Args) => F, g: (_: F, ...args: Args) => G, h: (_: G, ...args: Args) => H, i: (_: H, ...args: Args) => I, j: (_: I, ...args: Args) => J, k: (_: J, ...args: Args) => K, l: (_: K, ...args: Args) => L, m: (_: L, ...args: Args) => M, n: (_: M, ...args: Args) => N, o: (_: N, ...args: Args) => O, p: (_: O, ...args: Args) => P, q: (_: P, ...args: Args) => Q, r: (_: Q, ...args: Args) => R, s: (_: R, ...args: Args) => S): (this: Self, ...args: Args) => S; // overload 40
export declare const fnUntraced: <Eff extends Yieldable<any, any, any, any>, AEff, Args extends Array<any>, A, B, C, D, E, F, G, H, I, J, K, L, M, N, O, P, Q, R, S, T>(body: (this: unassigned, ...args: Args) => Generator<Eff, AEff, never>, a: (_: Effect<AEff, [Eff] extends [never] ? never : [Eff] extends [Yieldable<infer _S, infer _A, infer E, infer _R>] ? E : never, [Eff] extends [never] ? never : [Eff] extends [Yieldable<infer _S, infer _A, infer _E, infer R>] ? R : never>, ...args: Args) => A, b: (_: A, ...args: Args) => B, c: (_: B, ...args: Args) => C, d: (_: C, ...args: Args) => D, e: (_: D, ...args: Args) => E, f: (_: E, ...args: Args) => F, g: (_: F, ...args: Args) => G, h: (_: G, ...args: Args) => H, i: (_: H, ...args: Args) => I, j: (_: I, ...args: Args) => J, k: (_: J, ...args: Args) => K, l: (_: K, ...args: Args) => L, m: (_: L, ...args: Args) => M, n: (_: M, ...args: Args) => N, o: (_: N, ...args: Args) => O, p: (_: O, ...args: Args) => P, q: (_: P, ...args: Args) => Q, r: (_: Q, ...args: Args) => R, s: (_: R, ...args: Args) => S, t: (_: S, ...args: Args) => T): (...args: Args) => T; // overload 41
export declare const fnUntraced: <Self, Eff extends Yieldable<any, any, any, any>, AEff, Args extends Array<any>, A, B, C, D, E, F, G, H, I, J, K, L, M, N, O, P, Q, R, S, T>(body: (this: Self, ...args: Args) => Generator<Eff, AEff, never>, a: (_: Effect<AEff, [Eff] extends [never] ? never : [Eff] extends [Yieldable<infer _S, infer _A, infer E, infer _R>] ? E : never, [Eff] extends [never] ? never : [Eff] extends [Yieldable<infer _S, infer _A, infer _E, infer R>] ? R : never>, ...args: Args) => A, b: (_: A, ...args: Args) => B, c: (_: B, ...args: Args) => C, d: (_: C, ...args: Args) => D, e: (_: D, ...args: Args) => E, f: (_: E, ...args: Args) => F, g: (_: F, ...args: Args) => G, h: (_: G, ...args: Args) => H, i: (_: H, ...args: Args) => I, j: (_: I, ...args: Args) => J, k: (_: J, ...args: Args) => K, l: (_: K, ...args: Args) => L, m: (_: L, ...args: Args) => M, n: (_: M, ...args: Args) => N, o: (_: N, ...args: Args) => O, p: (_: O, ...args: Args) => P, q: (_: P, ...args: Args) => Q, r: (_: Q, ...args: Args) => R, s: (_: R, ...args: Args) => S, t: (_: S, ...args: Args) => T): (this: Self, ...args: Args) => T; // overload 42
export declare const fnUntracedEager: <Eff extends Yieldable<any, any, any, any>, AEff, Args extends Array<any>>(body: (this: unassigned, ...args: Args) => Generator<Eff, AEff, never>): (...args: Args) => Effect<AEff, [Eff] extends [never] ? never : [Eff] extends [Yieldable<infer _S, infer _A, infer E, infer _R>] ? E : never, [Eff] extends [never] ? never : [Eff] extends [Yieldable<infer _S, infer _A, infer _E, infer R>] ? R : never>; // overload 1
export declare const fnUntracedEager: <Self, Eff extends Yieldable<any, any, any, any>, AEff, Args extends Array<any>>(body: (this: Self, ...args: Args) => Generator<Eff, AEff, never>): (this: Self, ...args: Args) => Effect<AEff, [Eff] extends [never] ? never : [Eff] extends [Yieldable<infer _S, infer _A, infer E, infer _R>] ? E : never, [Eff] extends [never] ? never : [Eff] extends [Yieldable<infer _S, infer _A, infer _E, infer R>] ? R : never>; // overload 2
export declare const fnUntracedEager: <Eff extends Yieldable<any, any, any, any>, AEff, Args extends Array<any>, A>(body: (this: unassigned, ...args: Args) => Generator<Eff, AEff, never>, a: (_: Effect<AEff, [Eff] extends [never] ? never : [Eff] extends [Yieldable<infer _S, infer _A, infer E, infer _R>] ? E : never, [Eff] extends [never] ? never : [Eff] extends [Yieldable<infer _S, infer _A, infer _E, infer R>] ? R : never>, ...args: Args) => A): (...args: Args) => A; // overload 3
export declare const fnUntracedEager: <Self, Eff extends Yieldable<any, any, any, any>, AEff, Args extends Array<any>, A>(body: (this: Self, ...args: Args) => Generator<Eff, AEff, never>, a: (_: Effect<AEff, [Eff] extends [never] ? never : [Eff] extends [Yieldable<infer _S, infer _A, infer E, infer _R>] ? E : never, [Eff] extends [never] ? never : [Eff] extends [Yieldable<infer _S, infer _A, infer _E, infer R>] ? R : never>, ...args: Args) => A): (this: Self, ...args: Args) => A; // overload 4
export declare const fnUntracedEager: <Eff extends Yieldable<any, any, any, any>, AEff, Args extends Array<any>, A, B>(body: (this: unassigned, ...args: Args) => Generator<Eff, AEff, never>, a: (_: Effect<AEff, [Eff] extends [never] ? never : [Eff] extends [Yieldable<infer _S, infer _A, infer E, infer _R>] ? E : never, [Eff] extends [never] ? never : [Eff] extends [Yieldable<infer _S, infer _A, infer _E, infer R>] ? R : never>, ...args: Args) => A, b: (_: A, ...args: Args) => B): (...args: Args) => B; // overload 5
export declare const fnUntracedEager: <Self, Eff extends Yieldable<any, any, any, any>, AEff, Args extends Array<any>, A, B>(body: (this: Self, ...args: Args) => Generator<Eff, AEff, never>, a: (_: Effect<AEff, [Eff] extends [never] ? never : [Eff] extends [Yieldable<infer _S, infer _A, infer E, infer _R>] ? E : never, [Eff] extends [never] ? never : [Eff] extends [Yieldable<infer _S, infer _A, infer _E, infer R>] ? R : never>, ...args: Args) => A, b: (_: A, ...args: Args) => B): (this: Self, ...args: Args) => B; // overload 6
export declare const fnUntracedEager: <Eff extends Yieldable<any, any, any, any>, AEff, Args extends Array<any>, A, B, C>(body: (this: unassigned, ...args: Args) => Generator<Eff, AEff, never>, a: (_: Effect<AEff, [Eff] extends [never] ? never : [Eff] extends [Yieldable<infer _S, infer _A, infer E, infer _R>] ? E : never, [Eff] extends [never] ? never : [Eff] extends [Yieldable<infer _S, infer _A, infer _E, infer R>] ? R : never>, ...args: Args) => A, b: (_: A, ...args: Args) => B, c: (_: B, ...args: Args) => C): (...args: Args) => C; // overload 7
export declare const fnUntracedEager: <Self, Eff extends Yieldable<any, any, any, any>, AEff, Args extends Array<any>, A, B, C>(body: (this: Self, ...args: Args) => Generator<Eff, AEff, never>, a: (_: Effect<AEff, [Eff] extends [never] ? never : [Eff] extends [Yieldable<infer _S, infer _A, infer E, infer _R>] ? E : never, [Eff] extends [never] ? never : [Eff] extends [Yieldable<infer _S, infer _A, infer _E, infer R>] ? R : never>, ...args: Args) => A, b: (_: A, ...args: Args) => B, c: (_: B, ...args: Args) => C): (this: Self, ...args: Args) => C; // overload 8
export declare const fnUntracedEager: <Eff extends Yieldable<any, any, any, any>, AEff, Args extends Array<any>, A, B, C, D>(body: (...args: Args) => Generator<Eff, AEff, never>, a: (_: Effect<AEff, [Eff] extends [never] ? never : [Eff] extends [Yieldable<infer _S, infer _A, infer E, infer _R>] ? E : never, [Eff] extends [never] ? never : [Eff] extends [Yieldable<infer _S, infer _A, infer _E, infer R>] ? R : never>, ...args: Args) => A, b: (_: A, ...args: Args) => B, c: (_: B, ...args: Args) => C, d: (_: C, ...args: Args) => D): (...args: Args) => D; // overload 9
export declare const fnUntracedEager: <Self, Eff extends Yieldable<any, any, any, any>, AEff, Args extends Array<any>, A, B, C, D>(body: (this: Self, ...args: Args) => Generator<Eff, AEff, never>, a: (_: Effect<AEff, [Eff] extends [never] ? never : [Eff] extends [Yieldable<infer _S, infer _A, infer E, infer _R>] ? E : never, [Eff] extends [never] ? never : [Eff] extends [Yieldable<infer _S, infer _A, infer _E, infer R>] ? R : never>, ...args: Args) => A, b: (_: A, ...args: Args) => B, c: (_: B, ...args: Args) => C, d: (_: C, ...args: Args) => D): (this: Self, ...args: Args) => D; // overload 10
export declare const fnUntracedEager: <Eff extends Yieldable<any, any, any, any>, AEff, Args extends Array<any>, A, B, C, D, E>(body: (this: unassigned, ...args: Args) => Generator<Eff, AEff, never>, a: (_: Effect<AEff, [Eff] extends [never] ? never : [Eff] extends [Yieldable<infer _S, infer _A, infer E, infer _R>] ? E : never, [Eff] extends [never] ? never : [Eff] extends [Yieldable<infer _S, infer _A, infer _E, infer R>] ? R : never>, ...args: Args) => A, b: (_: A, ...args: Args) => B, c: (_: B, ...args: Args) => C, d: (_: C, ...args: Args) => D, e: (_: D, ...args: Args) => E): (...args: Args) => E; // overload 11
export declare const fnUntracedEager: <Self, Eff extends Yieldable<any, any, any, any>, AEff, Args extends Array<any>, A, B, C, D, E>(body: (this: Self, ...args: Args) => Generator<Eff, AEff, never>, a: (_: Effect<AEff, [Eff] extends [never] ? never : [Eff] extends [Yieldable<infer _S, infer _A, infer E, infer _R>] ? E : never, [Eff] extends [never] ? never : [Eff] extends [Yieldable<infer _S, infer _A, infer _E, infer R>] ? R : never>, ...args: Args) => A, b: (_: A, ...args: Args) => B, c: (_: B, ...args: Args) => C, d: (_: C, ...args: Args) => D, e: (_: D, ...args: Args) => E): (this: Self, ...args: Args) => E; // overload 12
export declare const fnUntracedEager: <Eff extends Yieldable<any, any, any, any>, AEff, Args extends Array<any>, A, B, C, D, E, F>(body: (this: unassigned, ...args: Args) => Generator<Eff, AEff, never>, a: (_: Effect<AEff, [Eff] extends [never] ? never : [Eff] extends [Yieldable<infer _S, infer _A, infer E, infer _R>] ? E : never, [Eff] extends [never] ? never : [Eff] extends [Yieldable<infer _S, infer _A, infer _E, infer R>] ? R : never>, ...args: Args) => A, b: (_: A, ...args: Args) => B, c: (_: B, ...args: Args) => C, d: (_: C, ...args: Args) => D, e: (_: D, ...args: Args) => E, f: (_: E, ...args: Args) => F): (...args: Args) => F; // overload 13
export declare const fnUntracedEager: <Self, Eff extends Yieldable<any, any, any, any>, AEff, Args extends Array<any>, A, B, C, D, E, F>(body: (this: Self, ...args: Args) => Generator<Eff, AEff, never>, a: (_: Effect<AEff, [Eff] extends [never] ? never : [Eff] extends [Yieldable<infer _S, infer _A, infer E, infer _R>] ? E : never, [Eff] extends [never] ? never : [Eff] extends [Yieldable<infer _S, infer _A, infer _E, infer R>] ? R : never>, ...args: Args) => A, b: (_: A, ...args: Args) => B, c: (_: B, ...args: Args) => C, d: (_: C, ...args: Args) => D, e: (_: D, ...args: Args) => E, f: (_: E, ...args: Args) => F): (this: Self, ...args: Args) => F; // overload 14
export declare const fnUntracedEager: <Eff extends Yieldable<any, any, any, any>, AEff, Args extends Array<any>, A, B, C, D, E, F, G>(body: (this: unassigned, ...args: Args) => Generator<Eff, AEff, never>, a: (_: Effect<AEff, [Eff] extends [never] ? never : [Eff] extends [Yieldable<infer _S, infer _A, infer E, infer _R>] ? E : never, [Eff] extends [never] ? never : [Eff] extends [Yieldable<infer _S, infer _A, infer _E, infer R>] ? R : never>, ...args: Args) => A, b: (_: A, ...args: Args) => B, c: (_: B, ...args: Args) => C, d: (_: C, ...args: Args) => D, e: (_: D, ...args: Args) => E, f: (_: E, ...args: Args) => F, g: (_: F, ...args: Args) => G): (...args: Args) => G; // overload 15
export declare const fnUntracedEager: <Self, Eff extends Yieldable<any, any, any, any>, AEff, Args extends Array<any>, A, B, C, D, E, F, G>(body: (this: Self, ...args: Args) => Generator<Eff, AEff, never>, a: (_: Effect<AEff, [Eff] extends [never] ? never : [Eff] extends [Yieldable<infer _S, infer _A, infer E, infer _R>] ? E : never, [Eff] extends [never] ? never : [Eff] extends [Yieldable<infer _S, infer _A, infer _E, infer R>] ? R : never>, ...args: Args) => A, b: (_: A, ...args: Args) => B, c: (_: B, ...args: Args) => C, d: (_: C, ...args: Args) => D, e: (_: D, ...args: Args) => E, f: (_: E, ...args: Args) => F, g: (_: F, ...args: Args) => G): (this: Self, ...args: Args) => G; // overload 16
export declare const fnUntracedEager: <Eff extends Yieldable<any, any, any, any>, AEff, Args extends Array<any>, A, B, C, D, E, F, G, H>(body: (this: unassigned, ...args: Args) => Generator<Eff, AEff, never>, a: (_: Effect<AEff, [Eff] extends [never] ? never : [Eff] extends [Yieldable<infer _S, infer _A, infer E, infer _R>] ? E : never, [Eff] extends [never] ? never : [Eff] extends [Yieldable<infer _S, infer _A, infer _E, infer R>] ? R : never>, ...args: Args) => A, b: (_: A, ...args: Args) => B, c: (_: B, ...args: Args) => C, d: (_: C, ...args: Args) => D, e: (_: D, ...args: Args) => E, f: (_: E, ...args: Args) => F, g: (_: F, ...args: Args) => G, h: (_: G, ...args: Args) => H): (...args: Args) => H; // overload 17
export declare const fnUntracedEager: <Self, Eff extends Yieldable<any, any, any, any>, AEff, Args extends Array<any>, A, B, C, D, E, F, G, H>(body: (this: Self, ...args: Args) => Generator<Eff, AEff, never>, a: (_: Effect<AEff, [Eff] extends [never] ? never : [Eff] extends [Yieldable<infer _S, infer _A, infer E, infer _R>] ? E : never, [Eff] extends [never] ? never : [Eff] extends [Yieldable<infer _S, infer _A, infer _E, infer R>] ? R : never>, ...args: Args) => A, b: (_: A, ...args: Args) => B, c: (_: B, ...args: Args) => C, d: (_: C, ...args: Args) => D, e: (_: D, ...args: Args) => E, f: (_: E, ...args: Args) => F, g: (_: F, ...args: Args) => G, h: (_: G, ...args: Args) => H): (this: Self, ...args: Args) => H; // overload 18
export declare const fnUntracedEager: <Eff extends Yieldable<any, any, any, any>, AEff, Args extends Array<any>, A, B, C, D, E, F, G, H, I>(body: (this: unassigned, ...args: Args) => Generator<Eff, AEff, never>, a: (_: Effect<AEff, [Eff] extends [never] ? never : [Eff] extends [Yieldable<infer _S, infer _A, infer E, infer _R>] ? E : never, [Eff] extends [never] ? never : [Eff] extends [Yieldable<infer _S, infer _A, infer _E, infer R>] ? R : never>, ...args: Args) => A, b: (_: A, ...args: Args) => B, c: (_: B, ...args: Args) => C, d: (_: C, ...args: Args) => D, e: (_: D, ...args: Args) => E, f: (_: E, ...args: Args) => F, g: (_: F, ...args: Args) => G, h: (_: G, ...args: Args) => H, i: (_: H, ...args: Args) => I): (...args: Args) => I; // overload 19
export declare const fnUntracedEager: <Self, Eff extends Yieldable<any, any, any, any>, AEff, Args extends Array<any>, A, B, C, D, E, F, G, H, I>(body: (this: Self, ...args: Args) => Generator<Eff, AEff, never>, a: (_: Effect<AEff, [Eff] extends [never] ? never : [Eff] extends [Yieldable<infer _S, infer _A, infer E, infer _R>] ? E : never, [Eff] extends [never] ? never : [Eff] extends [Yieldable<infer _S, infer _A, infer _E, infer R>] ? R : never>, ...args: Args) => A, b: (_: A, ...args: Args) => B, c: (_: B, ...args: Args) => C, d: (_: C, ...args: Args) => D, e: (_: D, ...args: Args) => E, f: (_: E, ...args: Args) => F, g: (_: F, ...args: Args) => G, h: (_: G, ...args: Args) => H, i: (_: H, ...args: Args) => I): (this: Self, ...args: Args) => I; // overload 20
export declare const fnUntracedEager: <Eff extends Yieldable<any, any, any, any>, AEff, Args extends Array<any>, A, B, C, D, E, F, G, H, I, J>(body: (this: unassigned, ...args: Args) => Generator<Eff, AEff, never>, a: (_: Effect<AEff, [Eff] extends [never] ? never : [Eff] extends [Yieldable<infer _S, infer _A, infer E, infer _R>] ? E : never, [Eff] extends [never] ? never : [Eff] extends [Yieldable<infer _S, infer _A, infer _E, infer R>] ? R : never>, ...args: Args) => A, b: (_: A, ...args: Args) => B, c: (_: B, ...args: Args) => C, d: (_: C, ...args: Args) => D, e: (_: D, ...args: Args) => E, f: (_: E, ...args: Args) => F, g: (_: F, ...args: Args) => G, h: (_: G, ...args: Args) => H, i: (_: H, ...args: Args) => I, j: (_: I, ...args: Args) => J): (...args: Args) => J; // overload 21
export declare const fnUntracedEager: <Self, Eff extends Yieldable<any, any, any, any>, AEff, Args extends Array<any>, A, B, C, D, E, F, G, H, I, J>(body: (this: Self, ...args: Args) => Generator<Eff, AEff, never>, a: (_: Effect<AEff, [Eff] extends [never] ? never : [Eff] extends [Yieldable<infer _S, infer _A, infer E, infer _R>] ? E : never, [Eff] extends [never] ? never : [Eff] extends [Yieldable<infer _S, infer _A, infer _E, infer R>] ? R : never>, ...args: Args) => A, b: (_: A, ...args: Args) => B, c: (_: B, ...args: Args) => C, d: (_: C, ...args: Args) => D, e: (_: D, ...args: Args) => E, f: (_: E, ...args: Args) => F, g: (_: F, ...args: Args) => G, h: (_: G, ...args: Args) => H, i: (_: H, ...args: Args) => I, j: (_: I, ...args: Args) => J): (this: Self, ...args: Args) => J; // overload 22
export declare const fnUntracedEager: <Eff extends Yieldable<any, any, any, any>, AEff, Args extends Array<any>, A, B, C, D, E, F, G, H, I, J, K>(body: (this: unassigned, ...args: Args) => Generator<Eff, AEff, never>, a: (_: Effect<AEff, [Eff] extends [never] ? never : [Eff] extends [Yieldable<infer _S, infer _A, infer E, infer _R>] ? E : never, [Eff] extends [never] ? never : [Eff] extends [Yieldable<infer _S, infer _A, infer _E, infer R>] ? R : never>, ...args: Args) => A, b: (_: A, ...args: Args) => B, c: (_: B, ...args: Args) => C, d: (_: C, ...args: Args) => D, e: (_: D, ...args: Args) => E, f: (_: E, ...args: Args) => F, g: (_: F, ...args: Args) => G, h: (_: G, ...args: Args) => H, i: (_: H, ...args: Args) => I, j: (_: I, ...args: Args) => J, k: (_: J, ...args: Args) => K): (...args: Args) => K; // overload 23
export declare const fnUntracedEager: <Self, Eff extends Yieldable<any, any, any, any>, AEff, Args extends Array<any>, A, B, C, D, E, F, G, H, I, J, K>(body: (this: Self, ...args: Args) => Generator<Eff, AEff, never>, a: (_: Effect<AEff, [Eff] extends [never] ? never : [Eff] extends [Yieldable<infer _S, infer _A, infer E, infer _R>] ? E : never, [Eff] extends [never] ? never : [Eff] extends [Yieldable<infer _S, infer _A, infer _E, infer R>] ? R : never>, ...args: Args) => A, b: (_: A, ...args: Args) => B, c: (_: B, ...args: Args) => C, d: (_: C, ...args: Args) => D, e: (_: D, ...args: Args) => E, f: (_: E, ...args: Args) => F, g: (_: F, ...args: Args) => G, h: (_: G, ...args: Args) => H, i: (_: H, ...args: Args) => I, j: (_: I, ...args: Args) => J, k: (_: J, ...args: Args) => K): (this: Self, ...args: Args) => K; // overload 24
export declare const fnUntracedEager: <Eff extends Yieldable<any, any, any, any>, AEff, Args extends Array<any>, A, B, C, D, E, F, G, H, I, J, K, L>(body: (this: unassigned, ...args: Args) => Generator<Eff, AEff, never>, a: (_: Effect<AEff, [Eff] extends [never] ? never : [Eff] extends [Yieldable<infer _S, infer _A, infer E, infer _R>] ? E : never, [Eff] extends [never] ? never : [Eff] extends [Yieldable<infer _S, infer _A, infer _E, infer R>] ? R : never>, ...args: Args) => A, b: (_: A, ...args: Args) => B, c: (_: B, ...args: Args) => C, d: (_: C, ...args: Args) => D, e: (_: D, ...args: Args) => E, f: (_: E, ...args: Args) => F, g: (_: F, ...args: Args) => G, h: (_: G, ...args: Args) => H, i: (_: H, ...args: Args) => I, j: (_: I, ...args: Args) => J, k: (_: J, ...args: Args) => K, l: (_: K, ...args: Args) => L): (...args: Args) => L; // overload 25
export declare const fnUntracedEager: <Self, Eff extends Yieldable<any, any, any, any>, AEff, Args extends Array<any>, A, B, C, D, E, F, G, H, I, J, K, L>(body: (this: Self, ...args: Args) => Generator<Eff, AEff, never>, a: (_: Effect<AEff, [Eff] extends [never] ? never : [Eff] extends [Yieldable<infer _S, infer _A, infer E, infer _R>] ? E : never, [Eff] extends [never] ? never : [Eff] extends [Yieldable<infer _S, infer _A, infer _E, infer R>] ? R : never>, ...args: Args) => A, b: (_: A, ...args: Args) => B, c: (_: B, ...args: Args) => C, d: (_: C, ...args: Args) => D, e: (_: D, ...args: Args) => E, f: (_: E, ...args: Args) => F, g: (_: F, ...args: Args) => G, h: (_: G, ...args: Args) => H, i: (_: H, ...args: Args) => I, j: (_: I, ...args: Args) => J, k: (_: J, ...args: Args) => K, l: (_: K, ...args: Args) => L): (this: Self, ...args: Args) => L; // overload 26
export declare const fnUntracedEager: <Eff extends Yieldable<any, any, any, any>, AEff, Args extends Array<any>, A, B, C, D, E, F, G, H, I, J, K, L, M>(body: (this: unassigned, ...args: Args) => Generator<Eff, AEff, never>, a: (_: Effect<AEff, [Eff] extends [never] ? never : [Eff] extends [Yieldable<infer _S, infer _A, infer E, infer _R>] ? E : never, [Eff] extends [never] ? never : [Eff] extends [Yieldable<infer _S, infer _A, infer _E, infer R>] ? R : never>, ...args: Args) => A, b: (_: A, ...args: Args) => B, c: (_: B, ...args: Args) => C, d: (_: C, ...args: Args) => D, e: (_: D, ...args: Args) => E, f: (_: E, ...args: Args) => F, g: (_: F, ...args: Args) => G, h: (_: G, ...args: Args) => H, i: (_: H, ...args: Args) => I, j: (_: I, ...args: Args) => J, k: (_: J, ...args: Args) => K, l: (_: K, ...args: Args) => L, m: (_: L, ...args: Args) => M): (...args: Args) => M; // overload 27
export declare const fnUntracedEager: <Self, Eff extends Yieldable<any, any, any, any>, AEff, Args extends Array<any>, A, B, C, D, E, F, G, H, I, J, K, L, M>(body: (this: Self, ...args: Args) => Generator<Eff, AEff, never>, a: (_: Effect<AEff, [Eff] extends [never] ? never : [Eff] extends [Yieldable<infer _S, infer _A, infer E, infer _R>] ? E : never, [Eff] extends [never] ? never : [Eff] extends [Yieldable<infer _S, infer _A, infer _E, infer R>] ? R : never>, ...args: Args) => A, b: (_: A, ...args: Args) => B, c: (_: B, ...args: Args) => C, d: (_: C, ...args: Args) => D, e: (_: D, ...args: Args) => E, f: (_: E, ...args: Args) => F, g: (_: F, ...args: Args) => G, h: (_: G, ...args: Args) => H, i: (_: H, ...args: Args) => I, j: (_: I, ...args: Args) => J, k: (_: J, ...args: Args) => K, l: (_: K, ...args: Args) => L, m: (_: L, ...args: Args) => M): (this: Self, ...args: Args) => M; // overload 28
export declare const fnUntracedEager: <Eff extends Yieldable<any, any, any, any>, AEff, Args extends Array<any>, A, B, C, D, E, F, G, H, I, J, K, L, M, N>(body: (this: unassigned, ...args: Args) => Generator<Eff, AEff, never>, a: (_: Effect<AEff, [Eff] extends [never] ? never : [Eff] extends [Yieldable<infer _S, infer _A, infer E, infer _R>] ? E : never, [Eff] extends [never] ? never : [Eff] extends [Yieldable<infer _S, infer _A, infer _E, infer R>] ? R : never>, ...args: Args) => A, b: (_: A, ...args: Args) => B, c: (_: B, ...args: Args) => C, d: (_: C, ...args: Args) => D, e: (_: D, ...args: Args) => E, f: (_: E, ...args: Args) => F, g: (_: F, ...args: Args) => G, h: (_: G, ...args: Args) => H, i: (_: H, ...args: Args) => I, j: (_: I, ...args: Args) => J, k: (_: J, ...args: Args) => K, l: (_: K, ...args: Args) => L, m: (_: L, ...args: Args) => M, n: (_: M, ...args: Args) => N): (...args: Args) => N; // overload 29
export declare const fnUntracedEager: <Self, Eff extends Yieldable<any, any, any, any>, AEff, Args extends Array<any>, A, B, C, D, E, F, G, H, I, J, K, L, M, N>(body: (this: Self, ...args: Args) => Generator<Eff, AEff, never>, a: (_: Effect<AEff, [Eff] extends [never] ? never : [Eff] extends [Yieldable<infer _S, infer _A, infer E, infer _R>] ? E : never, [Eff] extends [never] ? never : [Eff] extends [Yieldable<infer _S, infer _A, infer _E, infer R>] ? R : never>, ...args: Args) => A, b: (_: A, ...args: Args) => B, c: (_: B, ...args: Args) => C, d: (_: C, ...args: Args) => D, e: (_: D, ...args: Args) => E, f: (_: E, ...args: Args) => F, g: (_: F, ...args: Args) => G, h: (_: G, ...args: Args) => H, i: (_: H, ...args: Args) => I, j: (_: I, ...args: Args) => J, k: (_: J, ...args: Args) => K, l: (_: K, ...args: Args) => L, m: (_: L, ...args: Args) => M, n: (_: M, ...args: Args) => N): (this: Self, ...args: Args) => N; // overload 30
export declare const fnUntracedEager: <Eff extends Yieldable<any, any, any, any>, AEff, Args extends Array<any>, A, B, C, D, E, F, G, H, I, J, K, L, M, N, O>(body: (this: unassigned, ...args: Args) => Generator<Eff, AEff, never>, a: (_: Effect<AEff, [Eff] extends [never] ? never : [Eff] extends [Yieldable<infer _S, infer _A, infer E, infer _R>] ? E : never, [Eff] extends [never] ? never : [Eff] extends [Yieldable<infer _S, infer _A, infer _E, infer R>] ? R : never>, ...args: Args) => A, b: (_: A, ...args: Args) => B, c: (_: B, ...args: Args) => C, d: (_: C, ...args: Args) => D, e: (_: D, ...args: Args) => E, f: (_: E, ...args: Args) => F, g: (_: F, ...args: Args) => G, h: (_: G, ...args: Args) => H, i: (_: H, ...args: Args) => I, j: (_: I, ...args: Args) => J, k: (_: J, ...args: Args) => K, l: (_: K, ...args: Args) => L, m: (_: L, ...args: Args) => M, n: (_: M, ...args: Args) => N, o: (_: N, ...args: Args) => O): (...args: Args) => O; // overload 31
export declare const fnUntracedEager: <Self, Eff extends Yieldable<any, any, any, any>, AEff, Args extends Array<any>, A, B, C, D, E, F, G, H, I, J, K, L, M, N, O>(body: (this: Self, ...args: Args) => Generator<Eff, AEff, never>, a: (_: Effect<AEff, [Eff] extends [never] ? never : [Eff] extends [Yieldable<infer _S, infer _A, infer E, infer _R>] ? E : never, [Eff] extends [never] ? never : [Eff] extends [Yieldable<infer _S, infer _A, infer _E, infer R>] ? R : never>, ...args: Args) => A, b: (_: A, ...args: Args) => B, c: (_: B, ...args: Args) => C, d: (_: C, ...args: Args) => D, e: (_: D, ...args: Args) => E, f: (_: E, ...args: Args) => F, g: (_: F, ...args: Args) => G, h: (_: G, ...args: Args) => H, i: (_: H, ...args: Args) => I, j: (_: I, ...args: Args) => J, k: (_: J, ...args: Args) => K, l: (_: K, ...args: Args) => L, m: (_: L, ...args: Args) => M, n: (_: M, ...args: Args) => N, o: (_: N, ...args: Args) => O): (this: Self, ...args: Args) => O; // overload 32
export declare const fnUntracedEager: <Eff extends Yieldable<any, any, any, any>, AEff, Args extends Array<any>, A, B, C, D, E, F, G, H, I, J, K, L, M, N, O, P>(body: (this: unassigned, ...args: Args) => Generator<Eff, AEff, never>, a: (_: Effect<AEff, [Eff] extends [never] ? never : [Eff] extends [Yieldable<infer _S, infer _A, infer E, infer _R>] ? E : never, [Eff] extends [never] ? never : [Eff] extends [Yieldable<infer _S, infer _A, infer _E, infer R>] ? R : never>, ...args: Args) => A, b: (_: A, ...args: Args) => B, c: (_: B, ...args: Args) => C, d: (_: C, ...args: Args) => D, e: (_: D, ...args: Args) => E, f: (_: E, ...args: Args) => F, g: (_: F, ...args: Args) => G, h: (_: G, ...args: Args) => H, i: (_: H, ...args: Args) => I, j: (_: I, ...args: Args) => J, k: (_: J, ...args: Args) => K, l: (_: K, ...args: Args) => L, m: (_: L, ...args: Args) => M, n: (_: M, ...args: Args) => N, o: (_: N, ...args: Args) => O, p: (_: O, ...args: Args) => P): (...args: Args) => P; // overload 33
export declare const fnUntracedEager: <Self, Eff extends Yieldable<any, any, any, any>, AEff, Args extends Array<any>, A, B, C, D, E, F, G, H, I, J, K, L, M, N, O, P>(body: (this: Self, ...args: Args) => Generator<Eff, AEff, never>, a: (_: Effect<AEff, [Eff] extends [never] ? never : [Eff] extends [Yieldable<infer _S, infer _A, infer E, infer _R>] ? E : never, [Eff] extends [never] ? never : [Eff] extends [Yieldable<infer _S, infer _A, infer _E, infer R>] ? R : never>, ...args: Args) => A, b: (_: A, ...args: Args) => B, c: (_: B, ...args: Args) => C, d: (_: C, ...args: Args) => D, e: (_: D, ...args: Args) => E, f: (_: E, ...args: Args) => F, g: (_: F, ...args: Args) => G, h: (_: G, ...args: Args) => H, i: (_: H, ...args: Args) => I, j: (_: I, ...args: Args) => J, k: (_: J, ...args: Args) => K, l: (_: K, ...args: Args) => L, m: (_: L, ...args: Args) => M, n: (_: M, ...args: Args) => N, o: (_: N, ...args: Args) => O, p: (_: O, ...args: Args) => P): (this: Self, ...args: Args) => P; // overload 34
export declare const fnUntracedEager: <Eff extends Yieldable<any, any, any, any>, AEff, Args extends Array<any>, A, B, C, D, E, F, G, H, I, J, K, L, M, N, O, P, Q>(body: (this: unassigned, ...args: Args) => Generator<Eff, AEff, never>, a: (_: Effect<AEff, [Eff] extends [never] ? never : [Eff] extends [Yieldable<infer _S, infer _A, infer E, infer _R>] ? E : never, [Eff] extends [never] ? never : [Eff] extends [Yieldable<infer _S, infer _A, infer _E, infer R>] ? R : never>, ...args: Args) => A, b: (_: A, ...args: Args) => B, c: (_: B, ...args: Args) => C, d: (_: C, ...args: Args) => D, e: (_: D, ...args: Args) => E, f: (_: E, ...args: Args) => F, g: (_: F, ...args: Args) => G, h: (_: G, ...args: Args) => H, i: (_: H, ...args: Args) => I, j: (_: I, ...args: Args) => J, k: (_: J, ...args: Args) => K, l: (_: K, ...args: Args) => L, m: (_: L, ...args: Args) => M, n: (_: M, ...args: Args) => N, o: (_: N, ...args: Args) => O, p: (_: O, ...args: Args) => P, q: (_: P, ...args: Args) => Q): (...args: Args) => Q; // overload 35
export declare const fnUntracedEager: <Self, Eff extends Yieldable<any, any, any, any>, AEff, Args extends Array<any>, A, B, C, D, E, F, G, H, I, J, K, L, M, N, O, P, Q>(body: (this: Self, ...args: Args) => Generator<Eff, AEff, never>, a: (_: Effect<AEff, [Eff] extends [never] ? never : [Eff] extends [Yieldable<infer _S, infer _A, infer E, infer _R>] ? E : never, [Eff] extends [never] ? never : [Eff] extends [Yieldable<infer _S, infer _A, infer _E, infer R>] ? R : never>, ...args: Args) => A, b: (_: A, ...args: Args) => B, c: (_: B, ...args: Args) => C, d: (_: C, ...args: Args) => D, e: (_: D, ...args: Args) => E, f: (_: E, ...args: Args) => F, g: (_: F, ...args: Args) => G, h: (_: G, ...args: Args) => H, i: (_: H, ...args: Args) => I, j: (_: I, ...args: Args) => J, k: (_: J, ...args: Args) => K, l: (_: K, ...args: Args) => L, m: (_: L, ...args: Args) => M, n: (_: M, ...args: Args) => N, o: (_: N, ...args: Args) => O, p: (_: O, ...args: Args) => P, q: (_: P, ...args: Args) => Q): (this: Self, ...args: Args) => Q; // overload 36
export declare const fnUntracedEager: <Eff extends Yieldable<any, any, any, any>, AEff, Args extends Array<any>, A, B, C, D, E, F, G, H, I, J, K, L, M, N, O, P, Q, R>(body: (this: unassigned, ...args: Args) => Generator<Eff, AEff, never>, a: (_: Effect<AEff, [Eff] extends [never] ? never : [Eff] extends [Yieldable<infer _S, infer _A, infer E, infer _R>] ? E : never, [Eff] extends [never] ? never : [Eff] extends [Yieldable<infer _S, infer _A, infer _E, infer R>] ? R : never>, ...args: Args) => A, b: (_: A, ...args: Args) => B, c: (_: B, ...args: Args) => C, d: (_: C, ...args: Args) => D, e: (_: D, ...args: Args) => E, f: (_: E, ...args: Args) => F, g: (_: F, ...args: Args) => G, h: (_: G, ...args: Args) => H, i: (_: H, ...args: Args) => I, j: (_: I, ...args: Args) => J, k: (_: J, ...args: Args) => K, l: (_: K, ...args: Args) => L, m: (_: L, ...args: Args) => M, n: (_: M, ...args: Args) => N, o: (_: N, ...args: Args) => O, p: (_: O, ...args: Args) => P, q: (_: P, ...args: Args) => Q, r: (_: Q, ...args: Args) => R): (...args: Args) => R; // overload 37
export declare const fnUntracedEager: <Self, Eff extends Yieldable<any, any, any, any>, AEff, Args extends Array<any>, A, B, C, D, E, F, G, H, I, J, K, L, M, N, O, P, Q, R>(body: (this: Self, ...args: Args) => Generator<Eff, AEff, never>, a: (_: Effect<AEff, [Eff] extends [never] ? never : [Eff] extends [Yieldable<infer _S, infer _A, infer E, infer _R>] ? E : never, [Eff] extends [never] ? never : [Eff] extends [Yieldable<infer _S, infer _A, infer _E, infer R>] ? R : never>, ...args: Args) => A, b: (_: A, ...args: Args) => B, c: (_: B, ...args: Args) => C, d: (_: C, ...args: Args) => D, e: (_: D, ...args: Args) => E, f: (_: E, ...args: Args) => F, g: (_: F, ...args: Args) => G, h: (_: G, ...args: Args) => H, i: (_: H, ...args: Args) => I, j: (_: I, ...args: Args) => J, k: (_: J, ...args: Args) => K, l: (_: K, ...args: Args) => L, m: (_: L, ...args: Args) => M, n: (_: M, ...args: Args) => N, o: (_: N, ...args: Args) => O, p: (_: O, ...args: Args) => P, q: (_: P, ...args: Args) => Q, r: (_: Q, ...args: Args) => R): (this: Self, ...args: Args) => R; // overload 38
export declare const fnUntracedEager: <Eff extends Yieldable<any, any, any, any>, AEff, Args extends Array<any>, A, B, C, D, E, F, G, H, I, J, K, L, M, N, O, P, Q, R, S>(body: (this: unassigned, ...args: Args) => Generator<Eff, AEff, never>, a: (_: Effect<AEff, [Eff] extends [never] ? never : [Eff] extends [Yieldable<infer _S, infer _A, infer E, infer _R>] ? E : never, [Eff] extends [never] ? never : [Eff] extends [Yieldable<infer _S, infer _A, infer _E, infer R>] ? R : never>, ...args: Args) => A, b: (_: A, ...args: Args) => B, c: (_: B, ...args: Args) => C, d: (_: C, ...args: Args) => D, e: (_: D, ...args: Args) => E, f: (_: E, ...args: Args) => F, g: (_: F, ...args: Args) => G, h: (_: G, ...args: Args) => H, i: (_: H, ...args: Args) => I, j: (_: I, ...args: Args) => J, k: (_: J, ...args: Args) => K, l: (_: K, ...args: Args) => L, m: (_: L, ...args: Args) => M, n: (_: M, ...args: Args) => N, o: (_: N, ...args: Args) => O, p: (_: O, ...args: Args) => P, q: (_: P, ...args: Args) => Q, r: (_: Q, ...args: Args) => R, s: (_: R, ...args: Args) => S): (...args: Args) => S; // overload 39
export declare const fnUntracedEager: <Self, Eff extends Yieldable<any, any, any, any>, AEff, Args extends Array<any>, A, B, C, D, E, F, G, H, I, J, K, L, M, N, O, P, Q, R, S>(body: (this: Self, ...args: Args) => Generator<Eff, AEff, never>, a: (_: Effect<AEff, [Eff] extends [never] ? never : [Eff] extends [Yieldable<infer _S, infer _A, infer E, infer _R>] ? E : never, [Eff] extends [never] ? never : [Eff] extends [Yieldable<infer _S, infer _A, infer _E, infer R>] ? R : never>, ...args: Args) => A, b: (_: A, ...args: Args) => B, c: (_: B, ...args: Args) => C, d: (_: C, ...args: Args) => D, e: (_: D, ...args: Args) => E, f: (_: E, ...args: Args) => F, g: (_: F, ...args: Args) => G, h: (_: G, ...args: Args) => H, i: (_: H, ...args: Args) => I, j: (_: I, ...args: Args) => J, k: (_: J, ...args: Args) => K, l: (_: K, ...args: Args) => L, m: (_: L, ...args: Args) => M, n: (_: M, ...args: Args) => N, o: (_: N, ...args: Args) => O, p: (_: O, ...args: Args) => P, q: (_: P, ...args: Args) => Q, r: (_: Q, ...args: Args) => R, s: (_: R, ...args: Args) => S): (this: Self, ...args: Args) => S; // overload 40
export declare const fnUntracedEager: <Eff extends Yieldable<any, any, any, any>, AEff, Args extends Array<any>, A, B, C, D, E, F, G, H, I, J, K, L, M, N, O, P, Q, R, S, T>(body: (this: unassigned, ...args: Args) => Generator<Eff, AEff, never>, a: (_: Effect<AEff, [Eff] extends [never] ? never : [Eff] extends [Yieldable<infer _S, infer _A, infer E, infer _R>] ? E : never, [Eff] extends [never] ? never : [Eff] extends [Yieldable<infer _S, infer _A, infer _E, infer R>] ? R : never>, ...args: Args) => A, b: (_: A, ...args: Args) => B, c: (_: B, ...args: Args) => C, d: (_: C, ...args: Args) => D, e: (_: D, ...args: Args) => E, f: (_: E, ...args: Args) => F, g: (_: F, ...args: Args) => G, h: (_: G, ...args: Args) => H, i: (_: H, ...args: Args) => I, j: (_: I, ...args: Args) => J, k: (_: J, ...args: Args) => K, l: (_: K, ...args: Args) => L, m: (_: L, ...args: Args) => M, n: (_: M, ...args: Args) => N, o: (_: N, ...args: Args) => O, p: (_: O, ...args: Args) => P, q: (_: P, ...args: Args) => Q, r: (_: Q, ...args: Args) => R, s: (_: R, ...args: Args) => S, t: (_: S, ...args: Args) => T): (...args: Args) => T; // overload 41
export declare const fnUntracedEager: <Self, Eff extends Yieldable<any, any, any, any>, AEff, Args extends Array<any>, A, B, C, D, E, F, G, H, I, J, K, L, M, N, O, P, Q, R, S, T>(body: (this: Self, ...args: Args) => Generator<Eff, AEff, never>, a: (_: Effect<AEff, [Eff] extends [never] ? never : [Eff] extends [Yieldable<infer _S, infer _A, infer E, infer _R>] ? E : never, [Eff] extends [never] ? never : [Eff] extends [Yieldable<infer _S, infer _A, infer _E, infer R>] ? R : never>, ...args: Args) => A, b: (_: A, ...args: Args) => B, c: (_: B, ...args: Args) => C, d: (_: C, ...args: Args) => D, e: (_: D, ...args: Args) => E, f: (_: E, ...args: Args) => F, g: (_: F, ...args: Args) => G, h: (_: G, ...args: Args) => H, i: (_: H, ...args: Args) => I, j: (_: I, ...args: Args) => J, k: (_: J, ...args: Args) => K, l: (_: K, ...args: Args) => L, m: (_: L, ...args: Args) => M, n: (_: M, ...args: Args) => N, o: (_: N, ...args: Args) => O, p: (_: O, ...args: Args) => P, q: (_: P, ...args: Args) => Q, r: (_: Q, ...args: Args) => R, s: (_: R, ...args: Args) => S, t: (_: S, ...args: Args) => T): (this: Self, ...args: Args) => T; // overload 42
export declare const forkChild: <Arg extends Effect<any, any, any> | { readonly startImmediately?: boolean | undefined; readonly uninterruptible?: boolean | "inherit" | undefined; } | undefined = { readonly startImmediately?: boolean | undefined; readonly uninterruptible?: boolean | "inherit" | undefined; }>(effectOrOptions?: Arg, options?: { readonly startImmediately?: boolean | undefined; readonly uninterruptible?: boolean | "inherit" | undefined; } | undefined): [Arg] extends [Effect<infer _A, infer _E, infer _R>] ? Effect<Fiber<_A, _E>, never, _R> : <A, E, R>(self: Effect<A, E, R>) => Effect<Fiber<A, E>, never, R>;
export declare const forkDetach: <Arg extends Effect<any, any, any> | { readonly startImmediately?: boolean | undefined; readonly uninterruptible?: boolean | "inherit" | undefined; } | undefined = { readonly startImmediately?: boolean | undefined; readonly uninterruptible?: boolean | "inherit" | undefined; }>(effectOrOptions?: Arg, options?: { readonly startImmediately?: boolean | undefined; readonly uninterruptible?: boolean | "inherit" | undefined; } | undefined): [Arg] extends [Effect<infer _A, infer _E, infer _R>] ? Effect<Fiber<_A, _E>, never, _R> : <A, E, R>(self: Effect<A, E, R>) => Effect<Fiber<A, E>, never, R>;
export declare const forkIn: (scope: Scope, options?: { readonly startImmediately?: boolean | undefined; readonly uninterruptible?: boolean | "inherit" | undefined; }): <A, E, R>(self: Effect<A, E, R>) => Effect<Fiber<A, E>, never, R>; // overload 1
export declare const forkIn: <A, E, R>(self: Effect<A, E, R>, scope: Scope, options?: { readonly startImmediately?: boolean | undefined; readonly uninterruptible?: boolean | "inherit" | undefined; }): Effect<Fiber<A, E>, never, R>; // overload 2
export declare const forkScoped: <Arg extends Effect<any, any, any> | { readonly startImmediately?: boolean | undefined; readonly uninterruptible?: boolean | "inherit" | undefined; } | undefined = { readonly startImmediately?: boolean | undefined; readonly uninterruptible?: boolean | "inherit" | undefined; }>(effectOrOptions?: Arg, options?: { readonly startImmediately?: boolean | undefined; readonly uninterruptible?: boolean | "inherit" | undefined; } | undefined): [Arg] extends [Effect<infer _A, infer _E, infer _R>] ? Effect<Fiber<_A, _E>, never, _R> : <A, E, R>(self: Effect<A, E, R>) => Effect<Fiber<A, E>, never, R | Scope>;
export declare const interruptible: <A, E, R>(self: Effect<A, E, R>): Effect<A, E, R>;
export declare const interruptibleMask: <A, E, R>(f: (restore: <AX, EX, RX>(effect: Effect<AX, EX, RX>) => Effect<AX, EX, RX>) => Effect<A, E, R>): Effect<A, E, R>;
export declare const logTrace: (...message: ReadonlyArray<any>): Effect<void>;
export declare const onInterrupt: <XE, XR>(finalizer: (interruptors: ReadonlySet<number>) => Effect<void, XE, XR>): <A, E, R>(self: Effect<A, E, R>) => Effect<A, E | XE, R | XR>; // overload 1
export declare const onInterrupt: <A, E, R, XE, XR>(self: Effect<A, E, R>, finalizer: (interruptors: ReadonlySet<number>) => Effect<void, XE, XR>): Effect<A, E | XE, R | XR>; // overload 2
export declare const race: <A2, E2, R2>(that: Effect<A2, E2, R2>, options?: { readonly onWinner?: (options: { readonly fiber: Fiber<any, any>; readonly index: number; readonly parentFiber: Fiber<any, any>; }) => void; }): <A, E, R>(self: Effect<A, E, R>) => Effect<A | A2, E | E2, R | R2>; // overload 1
export declare const race: <A, E, R, A2, E2, R2>(self: Effect<A, E, R>, that: Effect<A2, E2, R2>, options?: { readonly onWinner?: (options: { readonly fiber: Fiber<any, any>; readonly index: number; readonly parentFiber: Fiber<any, any>; }) => void; }): Effect<A | A2, E | E2, R | R2>; // overload 2
export declare const raceAll: <Eff extends Effect<any, any, any>>(all: Iterable<Eff>, options?: { readonly onWinner?: (options: { readonly fiber: Fiber<any, any>; readonly index: number; readonly parentFiber: Fiber<any, any>; }) => void; }): Effect<Success<Eff>, Error<Eff>, Services<Eff>>;
export declare const raceAllFirst: <Eff extends Effect<any, any, any>>(all: Iterable<Eff>, options?: { readonly onWinner?: (options: { readonly fiber: Fiber<any, any>; readonly index: number; readonly parentFiber: Fiber<any, any>; }) => void; }): Effect<Success<Eff>, Error<Eff>, Services<Eff>>;
export declare const raceFirst: <A2, E2, R2>(that: Effect<A2, E2, R2>, options?: { readonly onWinner?: (options: { readonly fiber: Fiber<any, any>; readonly index: number; readonly parentFiber: Fiber<any, any>; }) => void; }): <A, E, R>(self: Effect<A, E, R>) => Effect<A | A2, E | E2, R | R2>; // overload 1
export declare const raceFirst: <A, E, R, A2, E2, R2>(self: Effect<A, E, R>, that: Effect<A2, E2, R2>, options?: { readonly onWinner?: (options: { readonly fiber: Fiber<any, any>; readonly index: number; readonly parentFiber: Fiber<any, any>; }) => void; }): Effect<A | A2, E | E2, R | R2>; // overload 2
export declare const runFork: <A, E>(effect: Effect<A, E, never>, options?: RunOptions | undefined): Fiber<A, E>;
export declare const runForkWith: <R>(services: ServiceMap.ServiceMap<R>): <A, E>(effect: Effect<A, E, R>, options?: RunOptions | undefined) => Fiber<A, E>;
export declare const uninterruptible: <A, E, R>(self: Effect<A, E, R>): Effect<A, E, R>;
export declare const uninterruptibleMask: <A, E, R>(f: (restore: <AX, EX, RX>(effect: Effect<AX, EX, RX>) => Effect<AX, EX, RX>) => Effect<A, E, R>): Effect<A, E, R>;
export declare const withConcurrency: (concurrency: number | "unbounded"): <A, E, R>(self: Effect<A, E, R>) => Effect<A, E, R>; // overload 1
export declare const withConcurrency: <A, E, R>(self: Effect<A, E, R>, concurrency: number | "unbounded"): Effect<A, E, R>; // overload 2
export declare const withFiber: <A, E = never, R = never>(evaluate: (fiber: Fiber<unknown, unknown>) => Effect<A, E, R>): Effect<A, E, R>;
export declare const withTracer: (value: Tracer): <A, E, R>(effect: Effect<A, E, R>) => Effect<A, E, R>; // overload 1
export declare const withTracer: <A, E, R>(effect: Effect<A, E, R>, value: Tracer): Effect<A, E, R>; // overload 2
export declare const withTracerEnabled: (enabled: boolean): <A, E, R>(effect: Effect<A, E, R>) => Effect<A, E, R>; // overload 1
export declare const withTracerEnabled: <A, E, R>(effect: Effect<A, E, R>, enabled: boolean): Effect<A, E, R>; // overload 2
export declare const withTracerTiming: (enabled: boolean): <A, E, R>(effect: Effect<A, E, R>) => Effect<A, E, R>; // overload 1
export declare const withTracerTiming: <A, E, R>(effect: Effect<A, E, R>, enabled: boolean): Effect<A, E, R>; // overload 2
```

## Other Exports (Non-Function)

- `fiber` (variable)
- `fiberId` (variable)
- `interrupt` (variable)
- `tracer` (variable)
